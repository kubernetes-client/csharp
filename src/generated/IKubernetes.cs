// <auto-generated>
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace k8s
{
    using Microsoft.Rest;
    using Models;
    using Newtonsoft.Json;
    using System.Collections;
    using System.Collections.Generic;
    using System.IO;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>
    /// </summary>
    public partial interface IKubernetes : System.IDisposable
    {
        /// <summary>
        /// The base URI of the service.
        /// </summary>
        System.Uri BaseUri { get; set; }

        /// <summary>
        /// Gets or sets json serialization settings.
        /// </summary>
        JsonSerializerSettings SerializationSettings { get; }

        /// <summary>
        /// Gets or sets json deserialization settings.
        /// </summary>
        JsonSerializerSettings DeserializationSettings { get; }

        /// <summary>
        /// Subscription credentials which uniquely identify client
        /// subscription.
        /// </summary>
        ServiceClientCredentials Credentials { get; }


        /// <summary>
        /// get available API versions
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIVersions>> GetAPIVersionsWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get available resources
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIResourceList>> GetAPIResourcesWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list objects of kind ComponentStatus
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ComponentStatusList>> ListComponentStatusWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified ComponentStatus
        /// </summary>
        /// <param name='name'>
        /// name of the ComponentStatus
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ComponentStatus>> ReadComponentStatusWithHttpMessagesAsync(string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind ConfigMap
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ConfigMapList>> ListConfigMapForAllNamespacesWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind Endpoints
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1EndpointsList>> ListEndpointsForAllNamespacesWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind Event
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1EventList>> ListEventForAllNamespacesWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind LimitRange
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1LimitRangeList>> ListLimitRangeForAllNamespacesWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind Namespace
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1NamespaceList>> ListNamespaceWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a Namespace
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Namespace>> CreateNamespaceWithHttpMessagesAsync(V1Namespace body, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a Binding
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Binding>> CreateNamespacedBindingWithHttpMessagesAsync(V1Binding body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind ConfigMap
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ConfigMapList>> ListNamespacedConfigMapWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a ConfigMap
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ConfigMap>> CreateNamespacedConfigMapWithHttpMessagesAsync(V1ConfigMap body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of ConfigMap
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedConfigMapWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified ConfigMap
        /// </summary>
        /// <param name='name'>
        /// name of the ConfigMap
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ConfigMap>> ReadNamespacedConfigMapWithHttpMessagesAsync(string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified ConfigMap
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ConfigMap
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ConfigMap>> ReplaceNamespacedConfigMapWithHttpMessagesAsync(V1ConfigMap body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a ConfigMap
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ConfigMap
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedConfigMapWithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified ConfigMap
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ConfigMap
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ConfigMap>> PatchNamespacedConfigMapWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind Endpoints
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1EndpointsList>> ListNamespacedEndpointsWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create Endpoints
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Endpoints>> CreateNamespacedEndpointsWithHttpMessagesAsync(V1Endpoints body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of Endpoints
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedEndpointsWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified Endpoints
        /// </summary>
        /// <param name='name'>
        /// name of the Endpoints
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Endpoints>> ReadNamespacedEndpointsWithHttpMessagesAsync(string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified Endpoints
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Endpoints
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Endpoints>> ReplaceNamespacedEndpointsWithHttpMessagesAsync(V1Endpoints body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete Endpoints
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Endpoints
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedEndpointsWithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified Endpoints
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Endpoints
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Endpoints>> PatchNamespacedEndpointsWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind Event
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1EventList>> ListNamespacedEventWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create an Event
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Event>> CreateNamespacedEventWithHttpMessagesAsync(V1Event body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of Event
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedEventWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified Event
        /// </summary>
        /// <param name='name'>
        /// name of the Event
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Event>> ReadNamespacedEventWithHttpMessagesAsync(string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified Event
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Event
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Event>> ReplaceNamespacedEventWithHttpMessagesAsync(V1Event body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete an Event
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Event
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedEventWithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified Event
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Event
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Event>> PatchNamespacedEventWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind LimitRange
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1LimitRangeList>> ListNamespacedLimitRangeWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a LimitRange
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1LimitRange>> CreateNamespacedLimitRangeWithHttpMessagesAsync(V1LimitRange body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of LimitRange
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedLimitRangeWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified LimitRange
        /// </summary>
        /// <param name='name'>
        /// name of the LimitRange
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1LimitRange>> ReadNamespacedLimitRangeWithHttpMessagesAsync(string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified LimitRange
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the LimitRange
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1LimitRange>> ReplaceNamespacedLimitRangeWithHttpMessagesAsync(V1LimitRange body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a LimitRange
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the LimitRange
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedLimitRangeWithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified LimitRange
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the LimitRange
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1LimitRange>> PatchNamespacedLimitRangeWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind PersistentVolumeClaim
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1PersistentVolumeClaimList>> ListNamespacedPersistentVolumeClaimWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a PersistentVolumeClaim
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1PersistentVolumeClaim>> CreateNamespacedPersistentVolumeClaimWithHttpMessagesAsync(V1PersistentVolumeClaim body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of PersistentVolumeClaim
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedPersistentVolumeClaimWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified PersistentVolumeClaim
        /// </summary>
        /// <param name='name'>
        /// name of the PersistentVolumeClaim
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1PersistentVolumeClaim>> ReadNamespacedPersistentVolumeClaimWithHttpMessagesAsync(string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified PersistentVolumeClaim
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the PersistentVolumeClaim
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1PersistentVolumeClaim>> ReplaceNamespacedPersistentVolumeClaimWithHttpMessagesAsync(V1PersistentVolumeClaim body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a PersistentVolumeClaim
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the PersistentVolumeClaim
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedPersistentVolumeClaimWithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified PersistentVolumeClaim
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the PersistentVolumeClaim
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1PersistentVolumeClaim>> PatchNamespacedPersistentVolumeClaimWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read status of the specified PersistentVolumeClaim
        /// </summary>
        /// <param name='name'>
        /// name of the PersistentVolumeClaim
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1PersistentVolumeClaim>> ReadNamespacedPersistentVolumeClaimStatusWithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace status of the specified PersistentVolumeClaim
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the PersistentVolumeClaim
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1PersistentVolumeClaim>> ReplaceNamespacedPersistentVolumeClaimStatusWithHttpMessagesAsync(V1PersistentVolumeClaim body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update status of the specified PersistentVolumeClaim
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the PersistentVolumeClaim
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1PersistentVolumeClaim>> PatchNamespacedPersistentVolumeClaimStatusWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind Pod
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1PodList>> ListNamespacedPodWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a Pod
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Pod>> CreateNamespacedPodWithHttpMessagesAsync(V1Pod body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of Pod
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedPodWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified Pod
        /// </summary>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Pod>> ReadNamespacedPodWithHttpMessagesAsync(string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified Pod
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Pod>> ReplaceNamespacedPodWithHttpMessagesAsync(V1Pod body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a Pod
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedPodWithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified Pod
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Pod>> PatchNamespacedPodWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect GET requests to attach of Pod
        /// </summary>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='container'>
        /// The container in which to execute the command. Defaults to only
        /// container if there is only one container in the pod.
        /// </param>
        /// <param name='stderr'>
        /// Stderr if true indicates that stderr is to be redirected for the
        /// attach call. Defaults to true.
        /// </param>
        /// <param name='stdin'>
        /// Stdin if true, redirects the standard input stream of the pod for
        /// this call. Defaults to false.
        /// </param>
        /// <param name='stdout'>
        /// Stdout if true indicates that stdout is to be redirected for the
        /// attach call. Defaults to true.
        /// </param>
        /// <param name='tty'>
        /// TTY if true indicates that a tty will be allocated for the attach
        /// call. This is passed through the container runtime so the tty is
        /// allocated on the worker node by the container runtime. Defaults to
        /// false.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectGetNamespacedPodAttachWithHttpMessagesAsync(string name, string namespaceParameter, string container = default(string), bool? stderr = default(bool?), bool? stdin = default(bool?), bool? stdout = default(bool?), bool? tty = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect POST requests to attach of Pod
        /// </summary>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='container'>
        /// The container in which to execute the command. Defaults to only
        /// container if there is only one container in the pod.
        /// </param>
        /// <param name='stderr'>
        /// Stderr if true indicates that stderr is to be redirected for the
        /// attach call. Defaults to true.
        /// </param>
        /// <param name='stdin'>
        /// Stdin if true, redirects the standard input stream of the pod for
        /// this call. Defaults to false.
        /// </param>
        /// <param name='stdout'>
        /// Stdout if true indicates that stdout is to be redirected for the
        /// attach call. Defaults to true.
        /// </param>
        /// <param name='tty'>
        /// TTY if true indicates that a tty will be allocated for the attach
        /// call. This is passed through the container runtime so the tty is
        /// allocated on the worker node by the container runtime. Defaults to
        /// false.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectPostNamespacedPodAttachWithHttpMessagesAsync(string name, string namespaceParameter, string container = default(string), bool? stderr = default(bool?), bool? stdin = default(bool?), bool? stdout = default(bool?), bool? tty = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create binding of a Pod
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Binding
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Binding>> CreateNamespacedPodBindingWithHttpMessagesAsync(V1Binding body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create eviction of a Pod
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Eviction
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1Eviction>> CreateNamespacedPodEvictionWithHttpMessagesAsync(V1beta1Eviction body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect GET requests to exec of Pod
        /// </summary>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='command'>
        /// Command is the remote command to execute. argv array. Not executed
        /// within a shell.
        /// </param>
        /// <param name='container'>
        /// Container in which to execute the command. Defaults to only
        /// container if there is only one container in the pod.
        /// </param>
        /// <param name='stderr'>
        /// Redirect the standard error stream of the pod for this call.
        /// Defaults to true.
        /// </param>
        /// <param name='stdin'>
        /// Redirect the standard input stream of the pod for this call.
        /// Defaults to false.
        /// </param>
        /// <param name='stdout'>
        /// Redirect the standard output stream of the pod for this call.
        /// Defaults to true.
        /// </param>
        /// <param name='tty'>
        /// TTY if true indicates that a tty will be allocated for the exec
        /// call. Defaults to false.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectGetNamespacedPodExecWithHttpMessagesAsync(string name, string namespaceParameter, string command = default(string), string container = default(string), bool? stderr = default(bool?), bool? stdin = default(bool?), bool? stdout = default(bool?), bool? tty = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect POST requests to exec of Pod
        /// </summary>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='command'>
        /// Command is the remote command to execute. argv array. Not executed
        /// within a shell.
        /// </param>
        /// <param name='container'>
        /// Container in which to execute the command. Defaults to only
        /// container if there is only one container in the pod.
        /// </param>
        /// <param name='stderr'>
        /// Redirect the standard error stream of the pod for this call.
        /// Defaults to true.
        /// </param>
        /// <param name='stdin'>
        /// Redirect the standard input stream of the pod for this call.
        /// Defaults to false.
        /// </param>
        /// <param name='stdout'>
        /// Redirect the standard output stream of the pod for this call.
        /// Defaults to true.
        /// </param>
        /// <param name='tty'>
        /// TTY if true indicates that a tty will be allocated for the exec
        /// call. Defaults to false.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectPostNamespacedPodExecWithHttpMessagesAsync(string name, string namespaceParameter, string command = default(string), string container = default(string), bool? stderr = default(bool?), bool? stdin = default(bool?), bool? stdout = default(bool?), bool? tty = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read log of the specified Pod
        /// </summary>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='container'>
        /// The container for which to stream logs. Defaults to only container
        /// if there is one container in the pod.
        /// </param>
        /// <param name='follow'>
        /// Follow the log stream of the pod. Defaults to false.
        /// </param>
        /// <param name='limitBytes'>
        /// If set, the number of bytes to read from the server before
        /// terminating the log output. This may not display a complete final
        /// line of logging, and may return slightly more or slightly less than
        /// the specified limit.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='previous'>
        /// Return previous terminated container logs. Defaults to false.
        /// </param>
        /// <param name='sinceSeconds'>
        /// A relative time in seconds before the current time from which to
        /// show logs. If this value precedes the time a pod was started, only
        /// logs since the pod start will be returned. If this value is in the
        /// future, no logs will be returned. Only one of sinceSeconds or
        /// sinceTime may be specified.
        /// </param>
        /// <param name='tailLines'>
        /// If set, the number of lines from the end of the logs to show. If
        /// not specified, logs are shown from the creation of the container or
        /// sinceSeconds or sinceTime
        /// </param>
        /// <param name='timestamps'>
        /// If true, add an RFC3339 or RFC3339Nano timestamp at the beginning
        /// of every line of log output. Defaults to false.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Stream>> ReadNamespacedPodLogWithHttpMessagesAsync(string name, string namespaceParameter, string container = default(string), bool? follow = default(bool?), int? limitBytes = default(int?), string pretty = default(string), bool? previous = default(bool?), int? sinceSeconds = default(int?), int? tailLines = default(int?), bool? timestamps = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect GET requests to portforward of Pod
        /// </summary>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='ports'>
        /// List of ports to forward Required when using WebSockets
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectGetNamespacedPodPortforwardWithHttpMessagesAsync(string name, string namespaceParameter, int? ports = default(int?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect POST requests to portforward of Pod
        /// </summary>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='ports'>
        /// List of ports to forward Required when using WebSockets
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectPostNamespacedPodPortforwardWithHttpMessagesAsync(string name, string namespaceParameter, int? ports = default(int?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect GET requests to proxy of Pod
        /// </summary>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// Path is the URL path to use for the current proxy request to pod.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectGetNamespacedPodProxyWithHttpMessagesAsync(string name, string namespaceParameter, string path = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect PUT requests to proxy of Pod
        /// </summary>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// Path is the URL path to use for the current proxy request to pod.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectPutNamespacedPodProxyWithHttpMessagesAsync(string name, string namespaceParameter, string path = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect POST requests to proxy of Pod
        /// </summary>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// Path is the URL path to use for the current proxy request to pod.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectPostNamespacedPodProxyWithHttpMessagesAsync(string name, string namespaceParameter, string path = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect DELETE requests to proxy of Pod
        /// </summary>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// Path is the URL path to use for the current proxy request to pod.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectDeleteNamespacedPodProxyWithHttpMessagesAsync(string name, string namespaceParameter, string path = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect HEAD requests to proxy of Pod
        /// </summary>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// Path is the URL path to use for the current proxy request to pod.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectHeadNamespacedPodProxyWithHttpMessagesAsync(string name, string namespaceParameter, string path = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect PATCH requests to proxy of Pod
        /// </summary>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// Path is the URL path to use for the current proxy request to pod.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectPatchNamespacedPodProxyWithHttpMessagesAsync(string name, string namespaceParameter, string path = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect GET requests to proxy of Pod
        /// </summary>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='path1'>
        /// Path is the URL path to use for the current proxy request to pod.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectGetNamespacedPodProxyWithPathWithHttpMessagesAsync(string name, string namespaceParameter, string path, string path1, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect PUT requests to proxy of Pod
        /// </summary>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='path1'>
        /// Path is the URL path to use for the current proxy request to pod.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectPutNamespacedPodProxyWithPathWithHttpMessagesAsync(string name, string namespaceParameter, string path, string path1, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect POST requests to proxy of Pod
        /// </summary>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='path1'>
        /// Path is the URL path to use for the current proxy request to pod.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectPostNamespacedPodProxyWithPathWithHttpMessagesAsync(string name, string namespaceParameter, string path, string path1, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect DELETE requests to proxy of Pod
        /// </summary>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='path1'>
        /// Path is the URL path to use for the current proxy request to pod.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectDeleteNamespacedPodProxyWithPathWithHttpMessagesAsync(string name, string namespaceParameter, string path, string path1, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect HEAD requests to proxy of Pod
        /// </summary>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='path1'>
        /// Path is the URL path to use for the current proxy request to pod.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectHeadNamespacedPodProxyWithPathWithHttpMessagesAsync(string name, string namespaceParameter, string path, string path1, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect PATCH requests to proxy of Pod
        /// </summary>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='path1'>
        /// Path is the URL path to use for the current proxy request to pod.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectPatchNamespacedPodProxyWithPathWithHttpMessagesAsync(string name, string namespaceParameter, string path, string path1, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read status of the specified Pod
        /// </summary>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Pod>> ReadNamespacedPodStatusWithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace status of the specified Pod
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Pod>> ReplaceNamespacedPodStatusWithHttpMessagesAsync(V1Pod body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update status of the specified Pod
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Pod>> PatchNamespacedPodStatusWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind PodTemplate
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1PodTemplateList>> ListNamespacedPodTemplateWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a PodTemplate
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1PodTemplate>> CreateNamespacedPodTemplateWithHttpMessagesAsync(V1PodTemplate body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of PodTemplate
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedPodTemplateWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified PodTemplate
        /// </summary>
        /// <param name='name'>
        /// name of the PodTemplate
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1PodTemplate>> ReadNamespacedPodTemplateWithHttpMessagesAsync(string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified PodTemplate
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the PodTemplate
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1PodTemplate>> ReplaceNamespacedPodTemplateWithHttpMessagesAsync(V1PodTemplate body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a PodTemplate
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the PodTemplate
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedPodTemplateWithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified PodTemplate
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the PodTemplate
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1PodTemplate>> PatchNamespacedPodTemplateWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind ReplicationController
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ReplicationControllerList>> ListNamespacedReplicationControllerWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a ReplicationController
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ReplicationController>> CreateNamespacedReplicationControllerWithHttpMessagesAsync(V1ReplicationController body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of ReplicationController
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedReplicationControllerWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified ReplicationController
        /// </summary>
        /// <param name='name'>
        /// name of the ReplicationController
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ReplicationController>> ReadNamespacedReplicationControllerWithHttpMessagesAsync(string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified ReplicationController
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ReplicationController
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ReplicationController>> ReplaceNamespacedReplicationControllerWithHttpMessagesAsync(V1ReplicationController body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a ReplicationController
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ReplicationController
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedReplicationControllerWithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified ReplicationController
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ReplicationController
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ReplicationController>> PatchNamespacedReplicationControllerWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read scale of the specified ReplicationController
        /// </summary>
        /// <param name='name'>
        /// name of the Scale
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Scale>> ReadNamespacedReplicationControllerScaleWithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace scale of the specified ReplicationController
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Scale
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Scale>> ReplaceNamespacedReplicationControllerScaleWithHttpMessagesAsync(V1Scale body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update scale of the specified ReplicationController
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Scale
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Scale>> PatchNamespacedReplicationControllerScaleWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read status of the specified ReplicationController
        /// </summary>
        /// <param name='name'>
        /// name of the ReplicationController
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ReplicationController>> ReadNamespacedReplicationControllerStatusWithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace status of the specified ReplicationController
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ReplicationController
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ReplicationController>> ReplaceNamespacedReplicationControllerStatusWithHttpMessagesAsync(V1ReplicationController body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update status of the specified ReplicationController
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ReplicationController
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ReplicationController>> PatchNamespacedReplicationControllerStatusWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind ResourceQuota
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ResourceQuotaList>> ListNamespacedResourceQuotaWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a ResourceQuota
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ResourceQuota>> CreateNamespacedResourceQuotaWithHttpMessagesAsync(V1ResourceQuota body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of ResourceQuota
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedResourceQuotaWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified ResourceQuota
        /// </summary>
        /// <param name='name'>
        /// name of the ResourceQuota
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ResourceQuota>> ReadNamespacedResourceQuotaWithHttpMessagesAsync(string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified ResourceQuota
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ResourceQuota
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ResourceQuota>> ReplaceNamespacedResourceQuotaWithHttpMessagesAsync(V1ResourceQuota body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a ResourceQuota
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ResourceQuota
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedResourceQuotaWithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified ResourceQuota
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ResourceQuota
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ResourceQuota>> PatchNamespacedResourceQuotaWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read status of the specified ResourceQuota
        /// </summary>
        /// <param name='name'>
        /// name of the ResourceQuota
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ResourceQuota>> ReadNamespacedResourceQuotaStatusWithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace status of the specified ResourceQuota
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ResourceQuota
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ResourceQuota>> ReplaceNamespacedResourceQuotaStatusWithHttpMessagesAsync(V1ResourceQuota body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update status of the specified ResourceQuota
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ResourceQuota
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ResourceQuota>> PatchNamespacedResourceQuotaStatusWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind Secret
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1SecretList>> ListNamespacedSecretWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a Secret
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Secret>> CreateNamespacedSecretWithHttpMessagesAsync(V1Secret body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of Secret
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedSecretWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified Secret
        /// </summary>
        /// <param name='name'>
        /// name of the Secret
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Secret>> ReadNamespacedSecretWithHttpMessagesAsync(string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified Secret
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Secret
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Secret>> ReplaceNamespacedSecretWithHttpMessagesAsync(V1Secret body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a Secret
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Secret
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedSecretWithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified Secret
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Secret
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Secret>> PatchNamespacedSecretWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind ServiceAccount
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ServiceAccountList>> ListNamespacedServiceAccountWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a ServiceAccount
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ServiceAccount>> CreateNamespacedServiceAccountWithHttpMessagesAsync(V1ServiceAccount body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of ServiceAccount
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedServiceAccountWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified ServiceAccount
        /// </summary>
        /// <param name='name'>
        /// name of the ServiceAccount
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ServiceAccount>> ReadNamespacedServiceAccountWithHttpMessagesAsync(string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified ServiceAccount
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ServiceAccount
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ServiceAccount>> ReplaceNamespacedServiceAccountWithHttpMessagesAsync(V1ServiceAccount body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a ServiceAccount
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ServiceAccount
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedServiceAccountWithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified ServiceAccount
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ServiceAccount
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ServiceAccount>> PatchNamespacedServiceAccountWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind Service
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ServiceList>> ListNamespacedServiceWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a Service
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Service>> CreateNamespacedServiceWithHttpMessagesAsync(V1Service body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified Service
        /// </summary>
        /// <param name='name'>
        /// name of the Service
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Service>> ReadNamespacedServiceWithHttpMessagesAsync(string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified Service
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Service
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Service>> ReplaceNamespacedServiceWithHttpMessagesAsync(V1Service body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a Service
        /// </summary>
        /// <param name='name'>
        /// name of the Service
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedServiceWithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified Service
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Service
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Service>> PatchNamespacedServiceWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect GET requests to proxy of Service
        /// </summary>
        /// <param name='name'>
        /// name of the Service
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// Path is the part of URLs that include service endpoints, suffixes,
        /// and parameters to use for the current proxy request to service. For
        /// example, the whole request URL is
        /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
        /// Path is _search?q=user:kimchy.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectGetNamespacedServiceProxyWithHttpMessagesAsync(string name, string namespaceParameter, string path = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect PUT requests to proxy of Service
        /// </summary>
        /// <param name='name'>
        /// name of the Service
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// Path is the part of URLs that include service endpoints, suffixes,
        /// and parameters to use for the current proxy request to service. For
        /// example, the whole request URL is
        /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
        /// Path is _search?q=user:kimchy.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectPutNamespacedServiceProxyWithHttpMessagesAsync(string name, string namespaceParameter, string path = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect POST requests to proxy of Service
        /// </summary>
        /// <param name='name'>
        /// name of the Service
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// Path is the part of URLs that include service endpoints, suffixes,
        /// and parameters to use for the current proxy request to service. For
        /// example, the whole request URL is
        /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
        /// Path is _search?q=user:kimchy.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectPostNamespacedServiceProxyWithHttpMessagesAsync(string name, string namespaceParameter, string path = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect DELETE requests to proxy of Service
        /// </summary>
        /// <param name='name'>
        /// name of the Service
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// Path is the part of URLs that include service endpoints, suffixes,
        /// and parameters to use for the current proxy request to service. For
        /// example, the whole request URL is
        /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
        /// Path is _search?q=user:kimchy.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectDeleteNamespacedServiceProxyWithHttpMessagesAsync(string name, string namespaceParameter, string path = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect HEAD requests to proxy of Service
        /// </summary>
        /// <param name='name'>
        /// name of the Service
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// Path is the part of URLs that include service endpoints, suffixes,
        /// and parameters to use for the current proxy request to service. For
        /// example, the whole request URL is
        /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
        /// Path is _search?q=user:kimchy.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectHeadNamespacedServiceProxyWithHttpMessagesAsync(string name, string namespaceParameter, string path = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect PATCH requests to proxy of Service
        /// </summary>
        /// <param name='name'>
        /// name of the Service
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// Path is the part of URLs that include service endpoints, suffixes,
        /// and parameters to use for the current proxy request to service. For
        /// example, the whole request URL is
        /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
        /// Path is _search?q=user:kimchy.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectPatchNamespacedServiceProxyWithHttpMessagesAsync(string name, string namespaceParameter, string path = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect GET requests to proxy of Service
        /// </summary>
        /// <param name='name'>
        /// name of the Service
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='path1'>
        /// Path is the part of URLs that include service endpoints, suffixes,
        /// and parameters to use for the current proxy request to service. For
        /// example, the whole request URL is
        /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
        /// Path is _search?q=user:kimchy.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectGetNamespacedServiceProxyWithPathWithHttpMessagesAsync(string name, string namespaceParameter, string path, string path1, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect PUT requests to proxy of Service
        /// </summary>
        /// <param name='name'>
        /// name of the Service
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='path1'>
        /// Path is the part of URLs that include service endpoints, suffixes,
        /// and parameters to use for the current proxy request to service. For
        /// example, the whole request URL is
        /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
        /// Path is _search?q=user:kimchy.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectPutNamespacedServiceProxyWithPathWithHttpMessagesAsync(string name, string namespaceParameter, string path, string path1, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect POST requests to proxy of Service
        /// </summary>
        /// <param name='name'>
        /// name of the Service
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='path1'>
        /// Path is the part of URLs that include service endpoints, suffixes,
        /// and parameters to use for the current proxy request to service. For
        /// example, the whole request URL is
        /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
        /// Path is _search?q=user:kimchy.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectPostNamespacedServiceProxyWithPathWithHttpMessagesAsync(string name, string namespaceParameter, string path, string path1, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect DELETE requests to proxy of Service
        /// </summary>
        /// <param name='name'>
        /// name of the Service
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='path1'>
        /// Path is the part of URLs that include service endpoints, suffixes,
        /// and parameters to use for the current proxy request to service. For
        /// example, the whole request URL is
        /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
        /// Path is _search?q=user:kimchy.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectDeleteNamespacedServiceProxyWithPathWithHttpMessagesAsync(string name, string namespaceParameter, string path, string path1, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect HEAD requests to proxy of Service
        /// </summary>
        /// <param name='name'>
        /// name of the Service
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='path1'>
        /// Path is the part of URLs that include service endpoints, suffixes,
        /// and parameters to use for the current proxy request to service. For
        /// example, the whole request URL is
        /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
        /// Path is _search?q=user:kimchy.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectHeadNamespacedServiceProxyWithPathWithHttpMessagesAsync(string name, string namespaceParameter, string path, string path1, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect PATCH requests to proxy of Service
        /// </summary>
        /// <param name='name'>
        /// name of the Service
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='path1'>
        /// Path is the part of URLs that include service endpoints, suffixes,
        /// and parameters to use for the current proxy request to service. For
        /// example, the whole request URL is
        /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
        /// Path is _search?q=user:kimchy.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectPatchNamespacedServiceProxyWithPathWithHttpMessagesAsync(string name, string namespaceParameter, string path, string path1, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read status of the specified Service
        /// </summary>
        /// <param name='name'>
        /// name of the Service
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Service>> ReadNamespacedServiceStatusWithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace status of the specified Service
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Service
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Service>> ReplaceNamespacedServiceStatusWithHttpMessagesAsync(V1Service body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update status of the specified Service
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Service
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Service>> PatchNamespacedServiceStatusWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified Namespace
        /// </summary>
        /// <param name='name'>
        /// name of the Namespace
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Namespace>> ReadNamespaceWithHttpMessagesAsync(string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified Namespace
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Namespace
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Namespace>> ReplaceNamespaceWithHttpMessagesAsync(V1Namespace body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a Namespace
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Namespace
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespaceWithHttpMessagesAsync(V1DeleteOptions body, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified Namespace
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Namespace
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Namespace>> PatchNamespaceWithHttpMessagesAsync(V1Patch body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace finalize of the specified Namespace
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Namespace
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Namespace>> ReplaceNamespaceFinalizeWithHttpMessagesAsync(V1Namespace body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read status of the specified Namespace
        /// </summary>
        /// <param name='name'>
        /// name of the Namespace
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Namespace>> ReadNamespaceStatusWithHttpMessagesAsync(string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace status of the specified Namespace
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Namespace
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Namespace>> ReplaceNamespaceStatusWithHttpMessagesAsync(V1Namespace body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update status of the specified Namespace
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Namespace
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Namespace>> PatchNamespaceStatusWithHttpMessagesAsync(V1Patch body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind Node
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1NodeList>> ListNodeWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a Node
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Node>> CreateNodeWithHttpMessagesAsync(V1Node body, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of Node
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNodeWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified Node
        /// </summary>
        /// <param name='name'>
        /// name of the Node
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Node>> ReadNodeWithHttpMessagesAsync(string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified Node
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Node
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Node>> ReplaceNodeWithHttpMessagesAsync(V1Node body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a Node
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Node
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNodeWithHttpMessagesAsync(V1DeleteOptions body, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified Node
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Node
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Node>> PatchNodeWithHttpMessagesAsync(V1Patch body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect GET requests to proxy of Node
        /// </summary>
        /// <param name='name'>
        /// name of the Node
        /// </param>
        /// <param name='path'>
        /// Path is the URL path to use for the current proxy request to node.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectGetNodeProxyWithHttpMessagesAsync(string name, string path = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect PUT requests to proxy of Node
        /// </summary>
        /// <param name='name'>
        /// name of the Node
        /// </param>
        /// <param name='path'>
        /// Path is the URL path to use for the current proxy request to node.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectPutNodeProxyWithHttpMessagesAsync(string name, string path = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect POST requests to proxy of Node
        /// </summary>
        /// <param name='name'>
        /// name of the Node
        /// </param>
        /// <param name='path'>
        /// Path is the URL path to use for the current proxy request to node.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectPostNodeProxyWithHttpMessagesAsync(string name, string path = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect DELETE requests to proxy of Node
        /// </summary>
        /// <param name='name'>
        /// name of the Node
        /// </param>
        /// <param name='path'>
        /// Path is the URL path to use for the current proxy request to node.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectDeleteNodeProxyWithHttpMessagesAsync(string name, string path = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect HEAD requests to proxy of Node
        /// </summary>
        /// <param name='name'>
        /// name of the Node
        /// </param>
        /// <param name='path'>
        /// Path is the URL path to use for the current proxy request to node.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectHeadNodeProxyWithHttpMessagesAsync(string name, string path = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect PATCH requests to proxy of Node
        /// </summary>
        /// <param name='name'>
        /// name of the Node
        /// </param>
        /// <param name='path'>
        /// Path is the URL path to use for the current proxy request to node.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectPatchNodeProxyWithHttpMessagesAsync(string name, string path = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect GET requests to proxy of Node
        /// </summary>
        /// <param name='name'>
        /// name of the Node
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='path1'>
        /// Path is the URL path to use for the current proxy request to node.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectGetNodeProxyWithPathWithHttpMessagesAsync(string name, string path, string path1, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect PUT requests to proxy of Node
        /// </summary>
        /// <param name='name'>
        /// name of the Node
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='path1'>
        /// Path is the URL path to use for the current proxy request to node.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectPutNodeProxyWithPathWithHttpMessagesAsync(string name, string path, string path1, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect POST requests to proxy of Node
        /// </summary>
        /// <param name='name'>
        /// name of the Node
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='path1'>
        /// Path is the URL path to use for the current proxy request to node.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectPostNodeProxyWithPathWithHttpMessagesAsync(string name, string path, string path1, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect DELETE requests to proxy of Node
        /// </summary>
        /// <param name='name'>
        /// name of the Node
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='path1'>
        /// Path is the URL path to use for the current proxy request to node.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectDeleteNodeProxyWithPathWithHttpMessagesAsync(string name, string path, string path1, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect HEAD requests to proxy of Node
        /// </summary>
        /// <param name='name'>
        /// name of the Node
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='path1'>
        /// Path is the URL path to use for the current proxy request to node.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectHeadNodeProxyWithPathWithHttpMessagesAsync(string name, string path, string path1, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// connect PATCH requests to proxy of Node
        /// </summary>
        /// <param name='name'>
        /// name of the Node
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='path1'>
        /// Path is the URL path to use for the current proxy request to node.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ConnectPatchNodeProxyWithPathWithHttpMessagesAsync(string name, string path, string path1, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read status of the specified Node
        /// </summary>
        /// <param name='name'>
        /// name of the Node
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Node>> ReadNodeStatusWithHttpMessagesAsync(string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace status of the specified Node
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Node
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Node>> ReplaceNodeStatusWithHttpMessagesAsync(V1Node body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update status of the specified Node
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Node
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Node>> PatchNodeStatusWithHttpMessagesAsync(V1Patch body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind PersistentVolumeClaim
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1PersistentVolumeClaimList>> ListPersistentVolumeClaimForAllNamespacesWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind PersistentVolume
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1PersistentVolumeList>> ListPersistentVolumeWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a PersistentVolume
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1PersistentVolume>> CreatePersistentVolumeWithHttpMessagesAsync(V1PersistentVolume body, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of PersistentVolume
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionPersistentVolumeWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified PersistentVolume
        /// </summary>
        /// <param name='name'>
        /// name of the PersistentVolume
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1PersistentVolume>> ReadPersistentVolumeWithHttpMessagesAsync(string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified PersistentVolume
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the PersistentVolume
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1PersistentVolume>> ReplacePersistentVolumeWithHttpMessagesAsync(V1PersistentVolume body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a PersistentVolume
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the PersistentVolume
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeletePersistentVolumeWithHttpMessagesAsync(V1DeleteOptions body, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified PersistentVolume
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the PersistentVolume
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1PersistentVolume>> PatchPersistentVolumeWithHttpMessagesAsync(V1Patch body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read status of the specified PersistentVolume
        /// </summary>
        /// <param name='name'>
        /// name of the PersistentVolume
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1PersistentVolume>> ReadPersistentVolumeStatusWithHttpMessagesAsync(string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace status of the specified PersistentVolume
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the PersistentVolume
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1PersistentVolume>> ReplacePersistentVolumeStatusWithHttpMessagesAsync(V1PersistentVolume body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update status of the specified PersistentVolume
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the PersistentVolume
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1PersistentVolume>> PatchPersistentVolumeStatusWithHttpMessagesAsync(V1Patch body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind Pod
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1PodList>> ListPodForAllNamespacesWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind PodTemplate
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1PodTemplateList>> ListPodTemplateForAllNamespacesWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy GET requests to Pod
        /// </summary>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyGETNamespacedPodWithHttpMessagesAsync(string name, string namespaceParameter, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy PUT requests to Pod
        /// </summary>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyPUTNamespacedPodWithHttpMessagesAsync(string name, string namespaceParameter, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy POST requests to Pod
        /// </summary>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyPOSTNamespacedPodWithHttpMessagesAsync(string name, string namespaceParameter, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy DELETE requests to Pod
        /// </summary>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyDELETENamespacedPodWithHttpMessagesAsync(string name, string namespaceParameter, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy HEAD requests to Pod
        /// </summary>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyHEADNamespacedPodWithHttpMessagesAsync(string name, string namespaceParameter, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy PATCH requests to Pod
        /// </summary>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyPATCHNamespacedPodWithHttpMessagesAsync(string name, string namespaceParameter, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy GET requests to Pod
        /// </summary>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyGETNamespacedPodWithPathWithHttpMessagesAsync(string name, string namespaceParameter, string path, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy PUT requests to Pod
        /// </summary>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyPUTNamespacedPodWithPathWithHttpMessagesAsync(string name, string namespaceParameter, string path, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy POST requests to Pod
        /// </summary>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyPOSTNamespacedPodWithPathWithHttpMessagesAsync(string name, string namespaceParameter, string path, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy DELETE requests to Pod
        /// </summary>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyDELETENamespacedPodWithPathWithHttpMessagesAsync(string name, string namespaceParameter, string path, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy HEAD requests to Pod
        /// </summary>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyHEADNamespacedPodWithPathWithHttpMessagesAsync(string name, string namespaceParameter, string path, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy PATCH requests to Pod
        /// </summary>
        /// <param name='name'>
        /// name of the Pod
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyPATCHNamespacedPodWithPathWithHttpMessagesAsync(string name, string namespaceParameter, string path, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy GET requests to Service
        /// </summary>
        /// <param name='name'>
        /// name of the Service
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyGETNamespacedServiceWithHttpMessagesAsync(string name, string namespaceParameter, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy PUT requests to Service
        /// </summary>
        /// <param name='name'>
        /// name of the Service
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyPUTNamespacedServiceWithHttpMessagesAsync(string name, string namespaceParameter, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy POST requests to Service
        /// </summary>
        /// <param name='name'>
        /// name of the Service
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyPOSTNamespacedServiceWithHttpMessagesAsync(string name, string namespaceParameter, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy DELETE requests to Service
        /// </summary>
        /// <param name='name'>
        /// name of the Service
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyDELETENamespacedServiceWithHttpMessagesAsync(string name, string namespaceParameter, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy HEAD requests to Service
        /// </summary>
        /// <param name='name'>
        /// name of the Service
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyHEADNamespacedServiceWithHttpMessagesAsync(string name, string namespaceParameter, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy PATCH requests to Service
        /// </summary>
        /// <param name='name'>
        /// name of the Service
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyPATCHNamespacedServiceWithHttpMessagesAsync(string name, string namespaceParameter, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy GET requests to Service
        /// </summary>
        /// <param name='name'>
        /// name of the Service
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyGETNamespacedServiceWithPathWithHttpMessagesAsync(string name, string namespaceParameter, string path, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy PUT requests to Service
        /// </summary>
        /// <param name='name'>
        /// name of the Service
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyPUTNamespacedServiceWithPathWithHttpMessagesAsync(string name, string namespaceParameter, string path, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy POST requests to Service
        /// </summary>
        /// <param name='name'>
        /// name of the Service
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyPOSTNamespacedServiceWithPathWithHttpMessagesAsync(string name, string namespaceParameter, string path, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy DELETE requests to Service
        /// </summary>
        /// <param name='name'>
        /// name of the Service
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyDELETENamespacedServiceWithPathWithHttpMessagesAsync(string name, string namespaceParameter, string path, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy HEAD requests to Service
        /// </summary>
        /// <param name='name'>
        /// name of the Service
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyHEADNamespacedServiceWithPathWithHttpMessagesAsync(string name, string namespaceParameter, string path, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy PATCH requests to Service
        /// </summary>
        /// <param name='name'>
        /// name of the Service
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyPATCHNamespacedServiceWithPathWithHttpMessagesAsync(string name, string namespaceParameter, string path, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy GET requests to Node
        /// </summary>
        /// <param name='name'>
        /// name of the Node
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyGETNodeWithHttpMessagesAsync(string name, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy PUT requests to Node
        /// </summary>
        /// <param name='name'>
        /// name of the Node
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyPUTNodeWithHttpMessagesAsync(string name, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy POST requests to Node
        /// </summary>
        /// <param name='name'>
        /// name of the Node
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyPOSTNodeWithHttpMessagesAsync(string name, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy DELETE requests to Node
        /// </summary>
        /// <param name='name'>
        /// name of the Node
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyDELETENodeWithHttpMessagesAsync(string name, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy HEAD requests to Node
        /// </summary>
        /// <param name='name'>
        /// name of the Node
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyHEADNodeWithHttpMessagesAsync(string name, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy PATCH requests to Node
        /// </summary>
        /// <param name='name'>
        /// name of the Node
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyPATCHNodeWithHttpMessagesAsync(string name, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy GET requests to Node
        /// </summary>
        /// <param name='name'>
        /// name of the Node
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyGETNodeWithPathWithHttpMessagesAsync(string name, string path, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy PUT requests to Node
        /// </summary>
        /// <param name='name'>
        /// name of the Node
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyPUTNodeWithPathWithHttpMessagesAsync(string name, string path, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy POST requests to Node
        /// </summary>
        /// <param name='name'>
        /// name of the Node
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyPOSTNodeWithPathWithHttpMessagesAsync(string name, string path, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy DELETE requests to Node
        /// </summary>
        /// <param name='name'>
        /// name of the Node
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyDELETENodeWithPathWithHttpMessagesAsync(string name, string path, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy HEAD requests to Node
        /// </summary>
        /// <param name='name'>
        /// name of the Node
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyHEADNodeWithPathWithHttpMessagesAsync(string name, string path, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// proxy PATCH requests to Node
        /// </summary>
        /// <param name='name'>
        /// name of the Node
        /// </param>
        /// <param name='path'>
        /// path to the resource
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> ProxyPATCHNodeWithPathWithHttpMessagesAsync(string name, string path, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind ReplicationController
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ReplicationControllerList>> ListReplicationControllerForAllNamespacesWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind ResourceQuota
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ResourceQuotaList>> ListResourceQuotaForAllNamespacesWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind Secret
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1SecretList>> ListSecretForAllNamespacesWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind ServiceAccount
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ServiceAccountList>> ListServiceAccountForAllNamespacesWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind Service
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ServiceList>> ListServiceForAllNamespacesWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get available API versions
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIGroupList>> GetAPIVersions1WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get information of a group
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIGroup>> GetAPIGroupWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get available resources
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources1WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind ExternalAdmissionHookConfiguration
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1ExternalAdmissionHookConfigurationList>> ListExternalAdmissionHookConfigurationWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create an ExternalAdmissionHookConfiguration
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1ExternalAdmissionHookConfiguration>> CreateExternalAdmissionHookConfigurationWithHttpMessagesAsync(V1alpha1ExternalAdmissionHookConfiguration body, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of ExternalAdmissionHookConfiguration
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionExternalAdmissionHookConfigurationWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified ExternalAdmissionHookConfiguration
        /// </summary>
        /// <param name='name'>
        /// name of the ExternalAdmissionHookConfiguration
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1ExternalAdmissionHookConfiguration>> ReadExternalAdmissionHookConfigurationWithHttpMessagesAsync(string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified ExternalAdmissionHookConfiguration
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ExternalAdmissionHookConfiguration
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1ExternalAdmissionHookConfiguration>> ReplaceExternalAdmissionHookConfigurationWithHttpMessagesAsync(V1alpha1ExternalAdmissionHookConfiguration body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete an ExternalAdmissionHookConfiguration
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ExternalAdmissionHookConfiguration
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteExternalAdmissionHookConfigurationWithHttpMessagesAsync(V1DeleteOptions body, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified ExternalAdmissionHookConfiguration
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ExternalAdmissionHookConfiguration
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1ExternalAdmissionHookConfiguration>> PatchExternalAdmissionHookConfigurationWithHttpMessagesAsync(V1Patch body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind InitializerConfiguration
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1InitializerConfigurationList>> ListInitializerConfigurationWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create an InitializerConfiguration
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1InitializerConfiguration>> CreateInitializerConfigurationWithHttpMessagesAsync(V1alpha1InitializerConfiguration body, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of InitializerConfiguration
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionInitializerConfigurationWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified InitializerConfiguration
        /// </summary>
        /// <param name='name'>
        /// name of the InitializerConfiguration
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1InitializerConfiguration>> ReadInitializerConfigurationWithHttpMessagesAsync(string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified InitializerConfiguration
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the InitializerConfiguration
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1InitializerConfiguration>> ReplaceInitializerConfigurationWithHttpMessagesAsync(V1alpha1InitializerConfiguration body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete an InitializerConfiguration
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the InitializerConfiguration
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteInitializerConfigurationWithHttpMessagesAsync(V1DeleteOptions body, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified InitializerConfiguration
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the InitializerConfiguration
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1InitializerConfiguration>> PatchInitializerConfigurationWithHttpMessagesAsync(V1Patch body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get information of a group
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIGroup>> GetAPIGroup1WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get available resources
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources2WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind CustomResourceDefinition
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1CustomResourceDefinitionList>> ListCustomResourceDefinitionWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a CustomResourceDefinition
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1CustomResourceDefinition>> CreateCustomResourceDefinitionWithHttpMessagesAsync(V1beta1CustomResourceDefinition body, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of CustomResourceDefinition
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionCustomResourceDefinitionWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified CustomResourceDefinition
        /// </summary>
        /// <param name='name'>
        /// name of the CustomResourceDefinition
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1CustomResourceDefinition>> ReadCustomResourceDefinitionWithHttpMessagesAsync(string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified CustomResourceDefinition
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the CustomResourceDefinition
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1CustomResourceDefinition>> ReplaceCustomResourceDefinitionWithHttpMessagesAsync(V1beta1CustomResourceDefinition body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a CustomResourceDefinition
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the CustomResourceDefinition
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCustomResourceDefinitionWithHttpMessagesAsync(V1DeleteOptions body, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified CustomResourceDefinition
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the CustomResourceDefinition
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1CustomResourceDefinition>> PatchCustomResourceDefinitionWithHttpMessagesAsync(V1Patch body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace status of the specified CustomResourceDefinition
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the CustomResourceDefinition
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1CustomResourceDefinition>> ReplaceCustomResourceDefinitionStatusWithHttpMessagesAsync(V1beta1CustomResourceDefinition body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get information of a group
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIGroup>> GetAPIGroup2WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get available resources
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources3WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind APIService
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1APIServiceList>> ListAPIServiceWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create an APIService
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1APIService>> CreateAPIServiceWithHttpMessagesAsync(V1beta1APIService body, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of APIService
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionAPIServiceWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified APIService
        /// </summary>
        /// <param name='name'>
        /// name of the APIService
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1APIService>> ReadAPIServiceWithHttpMessagesAsync(string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified APIService
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the APIService
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1APIService>> ReplaceAPIServiceWithHttpMessagesAsync(V1beta1APIService body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete an APIService
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the APIService
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteAPIServiceWithHttpMessagesAsync(V1DeleteOptions body, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified APIService
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the APIService
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1APIService>> PatchAPIServiceWithHttpMessagesAsync(V1Patch body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace status of the specified APIService
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the APIService
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1APIService>> ReplaceAPIServiceStatusWithHttpMessagesAsync(V1beta1APIService body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get information of a group
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIGroup>> GetAPIGroup3WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get available resources
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources4WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind ControllerRevision
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1ControllerRevisionList>> ListControllerRevisionForAllNamespacesWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind Deployment
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Appsv1beta1DeploymentList>> ListDeploymentForAllNamespacesWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind ControllerRevision
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1ControllerRevisionList>> ListNamespacedControllerRevisionWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a ControllerRevision
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1ControllerRevision>> CreateNamespacedControllerRevisionWithHttpMessagesAsync(V1beta1ControllerRevision body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of ControllerRevision
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedControllerRevisionWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified ControllerRevision
        /// </summary>
        /// <param name='name'>
        /// name of the ControllerRevision
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1ControllerRevision>> ReadNamespacedControllerRevisionWithHttpMessagesAsync(string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified ControllerRevision
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ControllerRevision
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1ControllerRevision>> ReplaceNamespacedControllerRevisionWithHttpMessagesAsync(V1beta1ControllerRevision body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a ControllerRevision
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ControllerRevision
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedControllerRevisionWithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified ControllerRevision
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ControllerRevision
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1ControllerRevision>> PatchNamespacedControllerRevisionWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind Deployment
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Appsv1beta1DeploymentList>> ListNamespacedDeploymentWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a Deployment
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Appsv1beta1Deployment>> CreateNamespacedDeploymentWithHttpMessagesAsync(Appsv1beta1Deployment body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of Deployment
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedDeploymentWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified Deployment
        /// </summary>
        /// <param name='name'>
        /// name of the Deployment
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Appsv1beta1Deployment>> ReadNamespacedDeploymentWithHttpMessagesAsync(string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified Deployment
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Deployment
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Appsv1beta1Deployment>> ReplaceNamespacedDeploymentWithHttpMessagesAsync(Appsv1beta1Deployment body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a Deployment
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Deployment
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedDeploymentWithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified Deployment
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Deployment
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Appsv1beta1Deployment>> PatchNamespacedDeploymentWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create rollback of a Deployment
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the DeploymentRollback
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Appsv1beta1DeploymentRollback>> CreateNamespacedDeploymentRollbackWithHttpMessagesAsync(Appsv1beta1DeploymentRollback body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read scale of the specified Deployment
        /// </summary>
        /// <param name='name'>
        /// name of the Scale
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Appsv1beta1Scale>> ReadNamespacedDeploymentScaleWithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace scale of the specified Deployment
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Scale
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Appsv1beta1Scale>> ReplaceNamespacedDeploymentScaleWithHttpMessagesAsync(Appsv1beta1Scale body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update scale of the specified Deployment
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Scale
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Appsv1beta1Scale>> PatchNamespacedDeploymentScaleWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read status of the specified Deployment
        /// </summary>
        /// <param name='name'>
        /// name of the Deployment
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Appsv1beta1Deployment>> ReadNamespacedDeploymentStatusWithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace status of the specified Deployment
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Deployment
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Appsv1beta1Deployment>> ReplaceNamespacedDeploymentStatusWithHttpMessagesAsync(Appsv1beta1Deployment body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update status of the specified Deployment
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Deployment
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Appsv1beta1Deployment>> PatchNamespacedDeploymentStatusWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind StatefulSet
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1StatefulSetList>> ListNamespacedStatefulSetWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a StatefulSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1StatefulSet>> CreateNamespacedStatefulSetWithHttpMessagesAsync(V1beta1StatefulSet body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of StatefulSet
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedStatefulSetWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified StatefulSet
        /// </summary>
        /// <param name='name'>
        /// name of the StatefulSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1StatefulSet>> ReadNamespacedStatefulSetWithHttpMessagesAsync(string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified StatefulSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the StatefulSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1StatefulSet>> ReplaceNamespacedStatefulSetWithHttpMessagesAsync(V1beta1StatefulSet body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a StatefulSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the StatefulSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedStatefulSetWithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified StatefulSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the StatefulSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1StatefulSet>> PatchNamespacedStatefulSetWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read scale of the specified StatefulSet
        /// </summary>
        /// <param name='name'>
        /// name of the Scale
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Appsv1beta1Scale>> ReadNamespacedStatefulSetScaleWithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace scale of the specified StatefulSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Scale
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Appsv1beta1Scale>> ReplaceNamespacedStatefulSetScaleWithHttpMessagesAsync(Appsv1beta1Scale body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update scale of the specified StatefulSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Scale
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Appsv1beta1Scale>> PatchNamespacedStatefulSetScaleWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read status of the specified StatefulSet
        /// </summary>
        /// <param name='name'>
        /// name of the StatefulSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1StatefulSet>> ReadNamespacedStatefulSetStatusWithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace status of the specified StatefulSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the StatefulSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1StatefulSet>> ReplaceNamespacedStatefulSetStatusWithHttpMessagesAsync(V1beta1StatefulSet body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update status of the specified StatefulSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the StatefulSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1StatefulSet>> PatchNamespacedStatefulSetStatusWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind StatefulSet
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1StatefulSetList>> ListStatefulSetForAllNamespacesWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get available resources
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources5WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind ControllerRevision
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2ControllerRevisionList>> ListControllerRevisionForAllNamespaces1WithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind DaemonSet
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2DaemonSetList>> ListDaemonSetForAllNamespacesWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind Deployment
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2DeploymentList>> ListDeploymentForAllNamespaces1WithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind ControllerRevision
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2ControllerRevisionList>> ListNamespacedControllerRevision1WithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a ControllerRevision
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2ControllerRevision>> CreateNamespacedControllerRevision1WithHttpMessagesAsync(V1beta2ControllerRevision body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of ControllerRevision
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedControllerRevision1WithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified ControllerRevision
        /// </summary>
        /// <param name='name'>
        /// name of the ControllerRevision
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2ControllerRevision>> ReadNamespacedControllerRevision1WithHttpMessagesAsync(string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified ControllerRevision
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ControllerRevision
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2ControllerRevision>> ReplaceNamespacedControllerRevision1WithHttpMessagesAsync(V1beta2ControllerRevision body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a ControllerRevision
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ControllerRevision
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedControllerRevision1WithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified ControllerRevision
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ControllerRevision
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2ControllerRevision>> PatchNamespacedControllerRevision1WithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind DaemonSet
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2DaemonSetList>> ListNamespacedDaemonSetWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a DaemonSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2DaemonSet>> CreateNamespacedDaemonSetWithHttpMessagesAsync(V1beta2DaemonSet body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of DaemonSet
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedDaemonSetWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified DaemonSet
        /// </summary>
        /// <param name='name'>
        /// name of the DaemonSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2DaemonSet>> ReadNamespacedDaemonSetWithHttpMessagesAsync(string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified DaemonSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the DaemonSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2DaemonSet>> ReplaceNamespacedDaemonSetWithHttpMessagesAsync(V1beta2DaemonSet body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a DaemonSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the DaemonSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedDaemonSetWithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified DaemonSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the DaemonSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2DaemonSet>> PatchNamespacedDaemonSetWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read status of the specified DaemonSet
        /// </summary>
        /// <param name='name'>
        /// name of the DaemonSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2DaemonSet>> ReadNamespacedDaemonSetStatusWithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace status of the specified DaemonSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the DaemonSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2DaemonSet>> ReplaceNamespacedDaemonSetStatusWithHttpMessagesAsync(V1beta2DaemonSet body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update status of the specified DaemonSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the DaemonSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2DaemonSet>> PatchNamespacedDaemonSetStatusWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind Deployment
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2DeploymentList>> ListNamespacedDeployment1WithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a Deployment
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2Deployment>> CreateNamespacedDeployment1WithHttpMessagesAsync(V1beta2Deployment body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of Deployment
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedDeployment1WithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified Deployment
        /// </summary>
        /// <param name='name'>
        /// name of the Deployment
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2Deployment>> ReadNamespacedDeployment1WithHttpMessagesAsync(string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified Deployment
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Deployment
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2Deployment>> ReplaceNamespacedDeployment1WithHttpMessagesAsync(V1beta2Deployment body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a Deployment
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Deployment
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedDeployment1WithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified Deployment
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Deployment
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2Deployment>> PatchNamespacedDeployment1WithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read scale of the specified Deployment
        /// </summary>
        /// <param name='name'>
        /// name of the Scale
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2Scale>> ReadNamespacedDeploymentScale1WithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace scale of the specified Deployment
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Scale
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2Scale>> ReplaceNamespacedDeploymentScale1WithHttpMessagesAsync(V1beta2Scale body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update scale of the specified Deployment
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Scale
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2Scale>> PatchNamespacedDeploymentScale1WithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read status of the specified Deployment
        /// </summary>
        /// <param name='name'>
        /// name of the Deployment
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2Deployment>> ReadNamespacedDeploymentStatus1WithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace status of the specified Deployment
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Deployment
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2Deployment>> ReplaceNamespacedDeploymentStatus1WithHttpMessagesAsync(V1beta2Deployment body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update status of the specified Deployment
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Deployment
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2Deployment>> PatchNamespacedDeploymentStatus1WithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind ReplicaSet
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2ReplicaSetList>> ListNamespacedReplicaSetWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a ReplicaSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2ReplicaSet>> CreateNamespacedReplicaSetWithHttpMessagesAsync(V1beta2ReplicaSet body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of ReplicaSet
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedReplicaSetWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified ReplicaSet
        /// </summary>
        /// <param name='name'>
        /// name of the ReplicaSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2ReplicaSet>> ReadNamespacedReplicaSetWithHttpMessagesAsync(string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified ReplicaSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ReplicaSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2ReplicaSet>> ReplaceNamespacedReplicaSetWithHttpMessagesAsync(V1beta2ReplicaSet body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a ReplicaSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ReplicaSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedReplicaSetWithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified ReplicaSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ReplicaSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2ReplicaSet>> PatchNamespacedReplicaSetWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read scale of the specified ReplicaSet
        /// </summary>
        /// <param name='name'>
        /// name of the Scale
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2Scale>> ReadNamespacedReplicaSetScaleWithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace scale of the specified ReplicaSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Scale
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2Scale>> ReplaceNamespacedReplicaSetScaleWithHttpMessagesAsync(V1beta2Scale body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update scale of the specified ReplicaSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Scale
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2Scale>> PatchNamespacedReplicaSetScaleWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read status of the specified ReplicaSet
        /// </summary>
        /// <param name='name'>
        /// name of the ReplicaSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2ReplicaSet>> ReadNamespacedReplicaSetStatusWithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace status of the specified ReplicaSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ReplicaSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2ReplicaSet>> ReplaceNamespacedReplicaSetStatusWithHttpMessagesAsync(V1beta2ReplicaSet body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update status of the specified ReplicaSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ReplicaSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2ReplicaSet>> PatchNamespacedReplicaSetStatusWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind StatefulSet
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2StatefulSetList>> ListNamespacedStatefulSet1WithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a StatefulSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2StatefulSet>> CreateNamespacedStatefulSet1WithHttpMessagesAsync(V1beta2StatefulSet body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of StatefulSet
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedStatefulSet1WithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified StatefulSet
        /// </summary>
        /// <param name='name'>
        /// name of the StatefulSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2StatefulSet>> ReadNamespacedStatefulSet1WithHttpMessagesAsync(string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified StatefulSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the StatefulSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2StatefulSet>> ReplaceNamespacedStatefulSet1WithHttpMessagesAsync(V1beta2StatefulSet body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a StatefulSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the StatefulSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedStatefulSet1WithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified StatefulSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the StatefulSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2StatefulSet>> PatchNamespacedStatefulSet1WithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read scale of the specified StatefulSet
        /// </summary>
        /// <param name='name'>
        /// name of the Scale
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2Scale>> ReadNamespacedStatefulSetScale1WithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace scale of the specified StatefulSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Scale
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2Scale>> ReplaceNamespacedStatefulSetScale1WithHttpMessagesAsync(V1beta2Scale body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update scale of the specified StatefulSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Scale
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2Scale>> PatchNamespacedStatefulSetScale1WithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read status of the specified StatefulSet
        /// </summary>
        /// <param name='name'>
        /// name of the StatefulSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2StatefulSet>> ReadNamespacedStatefulSetStatus1WithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace status of the specified StatefulSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the StatefulSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2StatefulSet>> ReplaceNamespacedStatefulSetStatus1WithHttpMessagesAsync(V1beta2StatefulSet body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update status of the specified StatefulSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the StatefulSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2StatefulSet>> PatchNamespacedStatefulSetStatus1WithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind ReplicaSet
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2ReplicaSetList>> ListReplicaSetForAllNamespacesWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind StatefulSet
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta2StatefulSetList>> ListStatefulSetForAllNamespaces1WithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get information of a group
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIGroup>> GetAPIGroup4WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get available resources
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources6WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a TokenReview
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1TokenReview>> CreateTokenReviewWithHttpMessagesAsync(V1TokenReview body, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get available resources
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources7WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a TokenReview
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1TokenReview>> CreateTokenReview1WithHttpMessagesAsync(V1beta1TokenReview body, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get information of a group
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIGroup>> GetAPIGroup5WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get available resources
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources8WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a LocalSubjectAccessReview
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1LocalSubjectAccessReview>> CreateNamespacedLocalSubjectAccessReviewWithHttpMessagesAsync(V1LocalSubjectAccessReview body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a SelfSubjectAccessReview
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1SelfSubjectAccessReview>> CreateSelfSubjectAccessReviewWithHttpMessagesAsync(V1SelfSubjectAccessReview body, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a SelfSubjectRulesReview
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1SelfSubjectRulesReview>> CreateSelfSubjectRulesReviewWithHttpMessagesAsync(V1SelfSubjectRulesReview body, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a SubjectAccessReview
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1SubjectAccessReview>> CreateSubjectAccessReviewWithHttpMessagesAsync(V1SubjectAccessReview body, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get available resources
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources9WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a LocalSubjectAccessReview
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1LocalSubjectAccessReview>> CreateNamespacedLocalSubjectAccessReview1WithHttpMessagesAsync(V1beta1LocalSubjectAccessReview body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a SelfSubjectAccessReview
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1SelfSubjectAccessReview>> CreateSelfSubjectAccessReview1WithHttpMessagesAsync(V1beta1SelfSubjectAccessReview body, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a SelfSubjectRulesReview
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1SelfSubjectRulesReview>> CreateSelfSubjectRulesReview1WithHttpMessagesAsync(V1beta1SelfSubjectRulesReview body, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a SubjectAccessReview
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1SubjectAccessReview>> CreateSubjectAccessReview1WithHttpMessagesAsync(V1beta1SubjectAccessReview body, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get information of a group
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIGroup>> GetAPIGroup6WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get available resources
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources10WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind HorizontalPodAutoscaler
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1HorizontalPodAutoscalerList>> ListHorizontalPodAutoscalerForAllNamespacesWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind HorizontalPodAutoscaler
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1HorizontalPodAutoscalerList>> ListNamespacedHorizontalPodAutoscalerWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a HorizontalPodAutoscaler
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1HorizontalPodAutoscaler>> CreateNamespacedHorizontalPodAutoscalerWithHttpMessagesAsync(V1HorizontalPodAutoscaler body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of HorizontalPodAutoscaler
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedHorizontalPodAutoscalerWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified HorizontalPodAutoscaler
        /// </summary>
        /// <param name='name'>
        /// name of the HorizontalPodAutoscaler
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1HorizontalPodAutoscaler>> ReadNamespacedHorizontalPodAutoscalerWithHttpMessagesAsync(string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified HorizontalPodAutoscaler
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the HorizontalPodAutoscaler
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1HorizontalPodAutoscaler>> ReplaceNamespacedHorizontalPodAutoscalerWithHttpMessagesAsync(V1HorizontalPodAutoscaler body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a HorizontalPodAutoscaler
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the HorizontalPodAutoscaler
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedHorizontalPodAutoscalerWithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified HorizontalPodAutoscaler
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the HorizontalPodAutoscaler
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1HorizontalPodAutoscaler>> PatchNamespacedHorizontalPodAutoscalerWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read status of the specified HorizontalPodAutoscaler
        /// </summary>
        /// <param name='name'>
        /// name of the HorizontalPodAutoscaler
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1HorizontalPodAutoscaler>> ReadNamespacedHorizontalPodAutoscalerStatusWithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace status of the specified HorizontalPodAutoscaler
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the HorizontalPodAutoscaler
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1HorizontalPodAutoscaler>> ReplaceNamespacedHorizontalPodAutoscalerStatusWithHttpMessagesAsync(V1HorizontalPodAutoscaler body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update status of the specified HorizontalPodAutoscaler
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the HorizontalPodAutoscaler
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1HorizontalPodAutoscaler>> PatchNamespacedHorizontalPodAutoscalerStatusWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get available resources
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources11WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind HorizontalPodAutoscaler
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V2beta1HorizontalPodAutoscalerList>> ListHorizontalPodAutoscalerForAllNamespaces1WithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind HorizontalPodAutoscaler
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V2beta1HorizontalPodAutoscalerList>> ListNamespacedHorizontalPodAutoscaler1WithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a HorizontalPodAutoscaler
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V2beta1HorizontalPodAutoscaler>> CreateNamespacedHorizontalPodAutoscaler1WithHttpMessagesAsync(V2beta1HorizontalPodAutoscaler body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of HorizontalPodAutoscaler
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedHorizontalPodAutoscaler1WithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified HorizontalPodAutoscaler
        /// </summary>
        /// <param name='name'>
        /// name of the HorizontalPodAutoscaler
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V2beta1HorizontalPodAutoscaler>> ReadNamespacedHorizontalPodAutoscaler1WithHttpMessagesAsync(string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified HorizontalPodAutoscaler
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the HorizontalPodAutoscaler
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V2beta1HorizontalPodAutoscaler>> ReplaceNamespacedHorizontalPodAutoscaler1WithHttpMessagesAsync(V2beta1HorizontalPodAutoscaler body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a HorizontalPodAutoscaler
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the HorizontalPodAutoscaler
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedHorizontalPodAutoscaler1WithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified HorizontalPodAutoscaler
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the HorizontalPodAutoscaler
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V2beta1HorizontalPodAutoscaler>> PatchNamespacedHorizontalPodAutoscaler1WithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read status of the specified HorizontalPodAutoscaler
        /// </summary>
        /// <param name='name'>
        /// name of the HorizontalPodAutoscaler
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V2beta1HorizontalPodAutoscaler>> ReadNamespacedHorizontalPodAutoscalerStatus1WithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace status of the specified HorizontalPodAutoscaler
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the HorizontalPodAutoscaler
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V2beta1HorizontalPodAutoscaler>> ReplaceNamespacedHorizontalPodAutoscalerStatus1WithHttpMessagesAsync(V2beta1HorizontalPodAutoscaler body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update status of the specified HorizontalPodAutoscaler
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the HorizontalPodAutoscaler
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V2beta1HorizontalPodAutoscaler>> PatchNamespacedHorizontalPodAutoscalerStatus1WithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get information of a group
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIGroup>> GetAPIGroup7WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get available resources
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources12WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind Job
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1JobList>> ListJobForAllNamespacesWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind Job
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1JobList>> ListNamespacedJobWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a Job
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Job>> CreateNamespacedJobWithHttpMessagesAsync(V1Job body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of Job
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedJobWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified Job
        /// </summary>
        /// <param name='name'>
        /// name of the Job
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Job>> ReadNamespacedJobWithHttpMessagesAsync(string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified Job
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Job
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Job>> ReplaceNamespacedJobWithHttpMessagesAsync(V1Job body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a Job
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Job
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedJobWithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified Job
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Job
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Job>> PatchNamespacedJobWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read status of the specified Job
        /// </summary>
        /// <param name='name'>
        /// name of the Job
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Job>> ReadNamespacedJobStatusWithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace status of the specified Job
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Job
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Job>> ReplaceNamespacedJobStatusWithHttpMessagesAsync(V1Job body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update status of the specified Job
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Job
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Job>> PatchNamespacedJobStatusWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get available resources
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources13WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind CronJob
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1CronJobList>> ListCronJobForAllNamespacesWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind CronJob
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1CronJobList>> ListNamespacedCronJobWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a CronJob
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1CronJob>> CreateNamespacedCronJobWithHttpMessagesAsync(V1beta1CronJob body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of CronJob
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedCronJobWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified CronJob
        /// </summary>
        /// <param name='name'>
        /// name of the CronJob
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1CronJob>> ReadNamespacedCronJobWithHttpMessagesAsync(string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified CronJob
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the CronJob
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1CronJob>> ReplaceNamespacedCronJobWithHttpMessagesAsync(V1beta1CronJob body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a CronJob
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the CronJob
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedCronJobWithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified CronJob
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the CronJob
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1CronJob>> PatchNamespacedCronJobWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read status of the specified CronJob
        /// </summary>
        /// <param name='name'>
        /// name of the CronJob
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1CronJob>> ReadNamespacedCronJobStatusWithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace status of the specified CronJob
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the CronJob
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1CronJob>> ReplaceNamespacedCronJobStatusWithHttpMessagesAsync(V1beta1CronJob body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update status of the specified CronJob
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the CronJob
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1CronJob>> PatchNamespacedCronJobStatusWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get available resources
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources14WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind CronJob
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V2alpha1CronJobList>> ListCronJobForAllNamespaces1WithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind CronJob
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V2alpha1CronJobList>> ListNamespacedCronJob1WithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a CronJob
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V2alpha1CronJob>> CreateNamespacedCronJob1WithHttpMessagesAsync(V2alpha1CronJob body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of CronJob
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedCronJob1WithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified CronJob
        /// </summary>
        /// <param name='name'>
        /// name of the CronJob
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V2alpha1CronJob>> ReadNamespacedCronJob1WithHttpMessagesAsync(string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified CronJob
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the CronJob
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V2alpha1CronJob>> ReplaceNamespacedCronJob1WithHttpMessagesAsync(V2alpha1CronJob body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a CronJob
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the CronJob
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedCronJob1WithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified CronJob
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the CronJob
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V2alpha1CronJob>> PatchNamespacedCronJob1WithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read status of the specified CronJob
        /// </summary>
        /// <param name='name'>
        /// name of the CronJob
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V2alpha1CronJob>> ReadNamespacedCronJobStatus1WithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace status of the specified CronJob
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the CronJob
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V2alpha1CronJob>> ReplaceNamespacedCronJobStatus1WithHttpMessagesAsync(V2alpha1CronJob body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update status of the specified CronJob
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the CronJob
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V2alpha1CronJob>> PatchNamespacedCronJobStatus1WithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get information of a group
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIGroup>> GetAPIGroup8WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get available resources
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources15WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind CertificateSigningRequest
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1CertificateSigningRequestList>> ListCertificateSigningRequestWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a CertificateSigningRequest
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1CertificateSigningRequest>> CreateCertificateSigningRequestWithHttpMessagesAsync(V1beta1CertificateSigningRequest body, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of CertificateSigningRequest
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionCertificateSigningRequestWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified CertificateSigningRequest
        /// </summary>
        /// <param name='name'>
        /// name of the CertificateSigningRequest
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1CertificateSigningRequest>> ReadCertificateSigningRequestWithHttpMessagesAsync(string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified CertificateSigningRequest
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the CertificateSigningRequest
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1CertificateSigningRequest>> ReplaceCertificateSigningRequestWithHttpMessagesAsync(V1beta1CertificateSigningRequest body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a CertificateSigningRequest
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the CertificateSigningRequest
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCertificateSigningRequestWithHttpMessagesAsync(V1DeleteOptions body, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified CertificateSigningRequest
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the CertificateSigningRequest
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1CertificateSigningRequest>> PatchCertificateSigningRequestWithHttpMessagesAsync(V1Patch body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace approval of the specified CertificateSigningRequest
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the CertificateSigningRequest
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1CertificateSigningRequest>> ReplaceCertificateSigningRequestApprovalWithHttpMessagesAsync(V1beta1CertificateSigningRequest body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace status of the specified CertificateSigningRequest
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the CertificateSigningRequest
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1CertificateSigningRequest>> ReplaceCertificateSigningRequestStatusWithHttpMessagesAsync(V1beta1CertificateSigningRequest body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get information of a group
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIGroup>> GetAPIGroup9WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get available resources
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources16WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind DaemonSet
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1DaemonSetList>> ListDaemonSetForAllNamespaces1WithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind Deployment
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Extensionsv1beta1DeploymentList>> ListDeploymentForAllNamespaces2WithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind Ingress
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1IngressList>> ListIngressForAllNamespacesWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind DaemonSet
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1DaemonSetList>> ListNamespacedDaemonSet1WithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a DaemonSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1DaemonSet>> CreateNamespacedDaemonSet1WithHttpMessagesAsync(V1beta1DaemonSet body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of DaemonSet
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedDaemonSet1WithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified DaemonSet
        /// </summary>
        /// <param name='name'>
        /// name of the DaemonSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1DaemonSet>> ReadNamespacedDaemonSet1WithHttpMessagesAsync(string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified DaemonSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the DaemonSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1DaemonSet>> ReplaceNamespacedDaemonSet1WithHttpMessagesAsync(V1beta1DaemonSet body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a DaemonSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the DaemonSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedDaemonSet1WithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified DaemonSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the DaemonSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1DaemonSet>> PatchNamespacedDaemonSet1WithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read status of the specified DaemonSet
        /// </summary>
        /// <param name='name'>
        /// name of the DaemonSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1DaemonSet>> ReadNamespacedDaemonSetStatus1WithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace status of the specified DaemonSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the DaemonSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1DaemonSet>> ReplaceNamespacedDaemonSetStatus1WithHttpMessagesAsync(V1beta1DaemonSet body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update status of the specified DaemonSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the DaemonSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1DaemonSet>> PatchNamespacedDaemonSetStatus1WithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind Deployment
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Extensionsv1beta1DeploymentList>> ListNamespacedDeployment2WithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a Deployment
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Extensionsv1beta1Deployment>> CreateNamespacedDeployment2WithHttpMessagesAsync(Extensionsv1beta1Deployment body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of Deployment
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedDeployment2WithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified Deployment
        /// </summary>
        /// <param name='name'>
        /// name of the Deployment
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Extensionsv1beta1Deployment>> ReadNamespacedDeployment2WithHttpMessagesAsync(string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified Deployment
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Deployment
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Extensionsv1beta1Deployment>> ReplaceNamespacedDeployment2WithHttpMessagesAsync(Extensionsv1beta1Deployment body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a Deployment
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Deployment
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedDeployment2WithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified Deployment
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Deployment
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Extensionsv1beta1Deployment>> PatchNamespacedDeployment2WithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create rollback of a Deployment
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the DeploymentRollback
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Extensionsv1beta1DeploymentRollback>> CreateNamespacedDeploymentRollback1WithHttpMessagesAsync(Extensionsv1beta1DeploymentRollback body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read scale of the specified Deployment
        /// </summary>
        /// <param name='name'>
        /// name of the Scale
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Extensionsv1beta1Scale>> ReadNamespacedDeploymentScale2WithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace scale of the specified Deployment
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Scale
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Extensionsv1beta1Scale>> ReplaceNamespacedDeploymentScale2WithHttpMessagesAsync(Extensionsv1beta1Scale body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update scale of the specified Deployment
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Scale
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Extensionsv1beta1Scale>> PatchNamespacedDeploymentScale2WithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read status of the specified Deployment
        /// </summary>
        /// <param name='name'>
        /// name of the Deployment
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Extensionsv1beta1Deployment>> ReadNamespacedDeploymentStatus2WithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace status of the specified Deployment
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Deployment
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Extensionsv1beta1Deployment>> ReplaceNamespacedDeploymentStatus2WithHttpMessagesAsync(Extensionsv1beta1Deployment body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update status of the specified Deployment
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Deployment
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Extensionsv1beta1Deployment>> PatchNamespacedDeploymentStatus2WithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind Ingress
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1IngressList>> ListNamespacedIngressWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create an Ingress
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1Ingress>> CreateNamespacedIngressWithHttpMessagesAsync(V1beta1Ingress body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of Ingress
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedIngressWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified Ingress
        /// </summary>
        /// <param name='name'>
        /// name of the Ingress
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1Ingress>> ReadNamespacedIngressWithHttpMessagesAsync(string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified Ingress
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Ingress
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1Ingress>> ReplaceNamespacedIngressWithHttpMessagesAsync(V1beta1Ingress body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete an Ingress
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Ingress
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedIngressWithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified Ingress
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Ingress
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1Ingress>> PatchNamespacedIngressWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read status of the specified Ingress
        /// </summary>
        /// <param name='name'>
        /// name of the Ingress
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1Ingress>> ReadNamespacedIngressStatusWithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace status of the specified Ingress
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Ingress
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1Ingress>> ReplaceNamespacedIngressStatusWithHttpMessagesAsync(V1beta1Ingress body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update status of the specified Ingress
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Ingress
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1Ingress>> PatchNamespacedIngressStatusWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind NetworkPolicy
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1NetworkPolicyList>> ListNamespacedNetworkPolicyWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a NetworkPolicy
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1NetworkPolicy>> CreateNamespacedNetworkPolicyWithHttpMessagesAsync(V1beta1NetworkPolicy body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of NetworkPolicy
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedNetworkPolicyWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified NetworkPolicy
        /// </summary>
        /// <param name='name'>
        /// name of the NetworkPolicy
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1NetworkPolicy>> ReadNamespacedNetworkPolicyWithHttpMessagesAsync(string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified NetworkPolicy
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the NetworkPolicy
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1NetworkPolicy>> ReplaceNamespacedNetworkPolicyWithHttpMessagesAsync(V1beta1NetworkPolicy body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a NetworkPolicy
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the NetworkPolicy
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedNetworkPolicyWithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified NetworkPolicy
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the NetworkPolicy
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1NetworkPolicy>> PatchNamespacedNetworkPolicyWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind ReplicaSet
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1ReplicaSetList>> ListNamespacedReplicaSet1WithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a ReplicaSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1ReplicaSet>> CreateNamespacedReplicaSet1WithHttpMessagesAsync(V1beta1ReplicaSet body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of ReplicaSet
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedReplicaSet1WithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified ReplicaSet
        /// </summary>
        /// <param name='name'>
        /// name of the ReplicaSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1ReplicaSet>> ReadNamespacedReplicaSet1WithHttpMessagesAsync(string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified ReplicaSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ReplicaSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1ReplicaSet>> ReplaceNamespacedReplicaSet1WithHttpMessagesAsync(V1beta1ReplicaSet body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a ReplicaSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ReplicaSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedReplicaSet1WithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified ReplicaSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ReplicaSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1ReplicaSet>> PatchNamespacedReplicaSet1WithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read scale of the specified ReplicaSet
        /// </summary>
        /// <param name='name'>
        /// name of the Scale
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Extensionsv1beta1Scale>> ReadNamespacedReplicaSetScale1WithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace scale of the specified ReplicaSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Scale
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Extensionsv1beta1Scale>> ReplaceNamespacedReplicaSetScale1WithHttpMessagesAsync(Extensionsv1beta1Scale body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update scale of the specified ReplicaSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Scale
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Extensionsv1beta1Scale>> PatchNamespacedReplicaSetScale1WithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read status of the specified ReplicaSet
        /// </summary>
        /// <param name='name'>
        /// name of the ReplicaSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1ReplicaSet>> ReadNamespacedReplicaSetStatus1WithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace status of the specified ReplicaSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ReplicaSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1ReplicaSet>> ReplaceNamespacedReplicaSetStatus1WithHttpMessagesAsync(V1beta1ReplicaSet body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update status of the specified ReplicaSet
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ReplicaSet
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1ReplicaSet>> PatchNamespacedReplicaSetStatus1WithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read scale of the specified ReplicationControllerDummy
        /// </summary>
        /// <param name='name'>
        /// name of the Scale
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Extensionsv1beta1Scale>> ReadNamespacedReplicationControllerDummyScaleWithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace scale of the specified ReplicationControllerDummy
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Scale
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Extensionsv1beta1Scale>> ReplaceNamespacedReplicationControllerDummyScaleWithHttpMessagesAsync(Extensionsv1beta1Scale body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update scale of the specified ReplicationControllerDummy
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Scale
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Extensionsv1beta1Scale>> PatchNamespacedReplicationControllerDummyScaleWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind NetworkPolicy
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1NetworkPolicyList>> ListNetworkPolicyForAllNamespacesWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind PodSecurityPolicy
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1PodSecurityPolicyList>> ListPodSecurityPolicyWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a PodSecurityPolicy
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1PodSecurityPolicy>> CreatePodSecurityPolicyWithHttpMessagesAsync(V1beta1PodSecurityPolicy body, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of PodSecurityPolicy
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionPodSecurityPolicyWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified PodSecurityPolicy
        /// </summary>
        /// <param name='name'>
        /// name of the PodSecurityPolicy
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1PodSecurityPolicy>> ReadPodSecurityPolicyWithHttpMessagesAsync(string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified PodSecurityPolicy
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the PodSecurityPolicy
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1PodSecurityPolicy>> ReplacePodSecurityPolicyWithHttpMessagesAsync(V1beta1PodSecurityPolicy body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a PodSecurityPolicy
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the PodSecurityPolicy
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeletePodSecurityPolicyWithHttpMessagesAsync(V1DeleteOptions body, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified PodSecurityPolicy
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the PodSecurityPolicy
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1PodSecurityPolicy>> PatchPodSecurityPolicyWithHttpMessagesAsync(V1Patch body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind ReplicaSet
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1ReplicaSetList>> ListReplicaSetForAllNamespaces1WithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get information of a group
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIGroup>> GetAPIGroup10WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get available resources
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources17WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind NetworkPolicy
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1NetworkPolicyList>> ListNamespacedNetworkPolicy1WithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a NetworkPolicy
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1NetworkPolicy>> CreateNamespacedNetworkPolicy1WithHttpMessagesAsync(V1NetworkPolicy body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of NetworkPolicy
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedNetworkPolicy1WithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified NetworkPolicy
        /// </summary>
        /// <param name='name'>
        /// name of the NetworkPolicy
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1NetworkPolicy>> ReadNamespacedNetworkPolicy1WithHttpMessagesAsync(string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified NetworkPolicy
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the NetworkPolicy
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1NetworkPolicy>> ReplaceNamespacedNetworkPolicy1WithHttpMessagesAsync(V1NetworkPolicy body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a NetworkPolicy
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the NetworkPolicy
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedNetworkPolicy1WithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified NetworkPolicy
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the NetworkPolicy
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1NetworkPolicy>> PatchNamespacedNetworkPolicy1WithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind NetworkPolicy
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1NetworkPolicyList>> ListNetworkPolicyForAllNamespaces1WithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get information of a group
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIGroup>> GetAPIGroup11WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get available resources
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources18WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind PodDisruptionBudget
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1PodDisruptionBudgetList>> ListNamespacedPodDisruptionBudgetWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a PodDisruptionBudget
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1PodDisruptionBudget>> CreateNamespacedPodDisruptionBudgetWithHttpMessagesAsync(V1beta1PodDisruptionBudget body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of PodDisruptionBudget
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedPodDisruptionBudgetWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified PodDisruptionBudget
        /// </summary>
        /// <param name='name'>
        /// name of the PodDisruptionBudget
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1PodDisruptionBudget>> ReadNamespacedPodDisruptionBudgetWithHttpMessagesAsync(string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified PodDisruptionBudget
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the PodDisruptionBudget
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1PodDisruptionBudget>> ReplaceNamespacedPodDisruptionBudgetWithHttpMessagesAsync(V1beta1PodDisruptionBudget body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a PodDisruptionBudget
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the PodDisruptionBudget
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedPodDisruptionBudgetWithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified PodDisruptionBudget
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the PodDisruptionBudget
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1PodDisruptionBudget>> PatchNamespacedPodDisruptionBudgetWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read status of the specified PodDisruptionBudget
        /// </summary>
        /// <param name='name'>
        /// name of the PodDisruptionBudget
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1PodDisruptionBudget>> ReadNamespacedPodDisruptionBudgetStatusWithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace status of the specified PodDisruptionBudget
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the PodDisruptionBudget
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1PodDisruptionBudget>> ReplaceNamespacedPodDisruptionBudgetStatusWithHttpMessagesAsync(V1beta1PodDisruptionBudget body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update status of the specified PodDisruptionBudget
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the PodDisruptionBudget
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1PodDisruptionBudget>> PatchNamespacedPodDisruptionBudgetStatusWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind PodDisruptionBudget
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1PodDisruptionBudgetList>> ListPodDisruptionBudgetForAllNamespacesWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get information of a group
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIGroup>> GetAPIGroup12WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get available resources
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources19WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind ClusterRoleBinding
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ClusterRoleBindingList>> ListClusterRoleBindingWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a ClusterRoleBinding
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ClusterRoleBinding>> CreateClusterRoleBindingWithHttpMessagesAsync(V1ClusterRoleBinding body, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of ClusterRoleBinding
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionClusterRoleBindingWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified ClusterRoleBinding
        /// </summary>
        /// <param name='name'>
        /// name of the ClusterRoleBinding
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ClusterRoleBinding>> ReadClusterRoleBindingWithHttpMessagesAsync(string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified ClusterRoleBinding
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ClusterRoleBinding
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ClusterRoleBinding>> ReplaceClusterRoleBindingWithHttpMessagesAsync(V1ClusterRoleBinding body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a ClusterRoleBinding
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ClusterRoleBinding
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteClusterRoleBindingWithHttpMessagesAsync(V1DeleteOptions body, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified ClusterRoleBinding
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ClusterRoleBinding
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ClusterRoleBinding>> PatchClusterRoleBindingWithHttpMessagesAsync(V1Patch body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind ClusterRole
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ClusterRoleList>> ListClusterRoleWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a ClusterRole
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ClusterRole>> CreateClusterRoleWithHttpMessagesAsync(V1ClusterRole body, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of ClusterRole
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionClusterRoleWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified ClusterRole
        /// </summary>
        /// <param name='name'>
        /// name of the ClusterRole
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ClusterRole>> ReadClusterRoleWithHttpMessagesAsync(string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified ClusterRole
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ClusterRole
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ClusterRole>> ReplaceClusterRoleWithHttpMessagesAsync(V1ClusterRole body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a ClusterRole
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ClusterRole
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteClusterRoleWithHttpMessagesAsync(V1DeleteOptions body, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified ClusterRole
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ClusterRole
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1ClusterRole>> PatchClusterRoleWithHttpMessagesAsync(V1Patch body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind RoleBinding
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1RoleBindingList>> ListNamespacedRoleBindingWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a RoleBinding
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1RoleBinding>> CreateNamespacedRoleBindingWithHttpMessagesAsync(V1RoleBinding body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of RoleBinding
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedRoleBindingWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified RoleBinding
        /// </summary>
        /// <param name='name'>
        /// name of the RoleBinding
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1RoleBinding>> ReadNamespacedRoleBindingWithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified RoleBinding
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the RoleBinding
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1RoleBinding>> ReplaceNamespacedRoleBindingWithHttpMessagesAsync(V1RoleBinding body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a RoleBinding
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the RoleBinding
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedRoleBindingWithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified RoleBinding
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the RoleBinding
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1RoleBinding>> PatchNamespacedRoleBindingWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind Role
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1RoleList>> ListNamespacedRoleWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a Role
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Role>> CreateNamespacedRoleWithHttpMessagesAsync(V1Role body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of Role
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedRoleWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified Role
        /// </summary>
        /// <param name='name'>
        /// name of the Role
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Role>> ReadNamespacedRoleWithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified Role
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Role
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Role>> ReplaceNamespacedRoleWithHttpMessagesAsync(V1Role body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a Role
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Role
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedRoleWithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified Role
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Role
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Role>> PatchNamespacedRoleWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind RoleBinding
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1RoleBindingList>> ListRoleBindingForAllNamespacesWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind Role
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1RoleList>> ListRoleForAllNamespacesWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get available resources
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources20WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind ClusterRoleBinding
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1ClusterRoleBindingList>> ListClusterRoleBinding1WithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a ClusterRoleBinding
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1ClusterRoleBinding>> CreateClusterRoleBinding1WithHttpMessagesAsync(V1alpha1ClusterRoleBinding body, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of ClusterRoleBinding
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionClusterRoleBinding1WithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified ClusterRoleBinding
        /// </summary>
        /// <param name='name'>
        /// name of the ClusterRoleBinding
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1ClusterRoleBinding>> ReadClusterRoleBinding1WithHttpMessagesAsync(string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified ClusterRoleBinding
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ClusterRoleBinding
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1ClusterRoleBinding>> ReplaceClusterRoleBinding1WithHttpMessagesAsync(V1alpha1ClusterRoleBinding body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a ClusterRoleBinding
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ClusterRoleBinding
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteClusterRoleBinding1WithHttpMessagesAsync(V1DeleteOptions body, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified ClusterRoleBinding
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ClusterRoleBinding
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1ClusterRoleBinding>> PatchClusterRoleBinding1WithHttpMessagesAsync(V1Patch body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind ClusterRole
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1ClusterRoleList>> ListClusterRole1WithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a ClusterRole
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1ClusterRole>> CreateClusterRole1WithHttpMessagesAsync(V1alpha1ClusterRole body, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of ClusterRole
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionClusterRole1WithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified ClusterRole
        /// </summary>
        /// <param name='name'>
        /// name of the ClusterRole
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1ClusterRole>> ReadClusterRole1WithHttpMessagesAsync(string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified ClusterRole
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ClusterRole
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1ClusterRole>> ReplaceClusterRole1WithHttpMessagesAsync(V1alpha1ClusterRole body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a ClusterRole
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ClusterRole
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteClusterRole1WithHttpMessagesAsync(V1DeleteOptions body, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified ClusterRole
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ClusterRole
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1ClusterRole>> PatchClusterRole1WithHttpMessagesAsync(V1Patch body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind RoleBinding
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1RoleBindingList>> ListNamespacedRoleBinding1WithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a RoleBinding
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1RoleBinding>> CreateNamespacedRoleBinding1WithHttpMessagesAsync(V1alpha1RoleBinding body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of RoleBinding
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedRoleBinding1WithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified RoleBinding
        /// </summary>
        /// <param name='name'>
        /// name of the RoleBinding
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1RoleBinding>> ReadNamespacedRoleBinding1WithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified RoleBinding
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the RoleBinding
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1RoleBinding>> ReplaceNamespacedRoleBinding1WithHttpMessagesAsync(V1alpha1RoleBinding body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a RoleBinding
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the RoleBinding
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedRoleBinding1WithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified RoleBinding
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the RoleBinding
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1RoleBinding>> PatchNamespacedRoleBinding1WithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind Role
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1RoleList>> ListNamespacedRole1WithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a Role
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1Role>> CreateNamespacedRole1WithHttpMessagesAsync(V1alpha1Role body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of Role
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedRole1WithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified Role
        /// </summary>
        /// <param name='name'>
        /// name of the Role
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1Role>> ReadNamespacedRole1WithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified Role
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Role
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1Role>> ReplaceNamespacedRole1WithHttpMessagesAsync(V1alpha1Role body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a Role
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Role
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedRole1WithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified Role
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Role
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1Role>> PatchNamespacedRole1WithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind RoleBinding
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1RoleBindingList>> ListRoleBindingForAllNamespaces1WithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind Role
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1RoleList>> ListRoleForAllNamespaces1WithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get available resources
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources21WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind ClusterRoleBinding
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1ClusterRoleBindingList>> ListClusterRoleBinding2WithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a ClusterRoleBinding
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1ClusterRoleBinding>> CreateClusterRoleBinding2WithHttpMessagesAsync(V1beta1ClusterRoleBinding body, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of ClusterRoleBinding
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionClusterRoleBinding2WithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified ClusterRoleBinding
        /// </summary>
        /// <param name='name'>
        /// name of the ClusterRoleBinding
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1ClusterRoleBinding>> ReadClusterRoleBinding2WithHttpMessagesAsync(string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified ClusterRoleBinding
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ClusterRoleBinding
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1ClusterRoleBinding>> ReplaceClusterRoleBinding2WithHttpMessagesAsync(V1beta1ClusterRoleBinding body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a ClusterRoleBinding
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ClusterRoleBinding
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteClusterRoleBinding2WithHttpMessagesAsync(V1DeleteOptions body, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified ClusterRoleBinding
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ClusterRoleBinding
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1ClusterRoleBinding>> PatchClusterRoleBinding2WithHttpMessagesAsync(V1Patch body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind ClusterRole
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1ClusterRoleList>> ListClusterRole2WithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a ClusterRole
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1ClusterRole>> CreateClusterRole2WithHttpMessagesAsync(V1beta1ClusterRole body, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of ClusterRole
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionClusterRole2WithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified ClusterRole
        /// </summary>
        /// <param name='name'>
        /// name of the ClusterRole
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1ClusterRole>> ReadClusterRole2WithHttpMessagesAsync(string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified ClusterRole
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ClusterRole
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1ClusterRole>> ReplaceClusterRole2WithHttpMessagesAsync(V1beta1ClusterRole body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a ClusterRole
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ClusterRole
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteClusterRole2WithHttpMessagesAsync(V1DeleteOptions body, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified ClusterRole
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the ClusterRole
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1ClusterRole>> PatchClusterRole2WithHttpMessagesAsync(V1Patch body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind RoleBinding
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1RoleBindingList>> ListNamespacedRoleBinding2WithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a RoleBinding
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1RoleBinding>> CreateNamespacedRoleBinding2WithHttpMessagesAsync(V1beta1RoleBinding body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of RoleBinding
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedRoleBinding2WithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified RoleBinding
        /// </summary>
        /// <param name='name'>
        /// name of the RoleBinding
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1RoleBinding>> ReadNamespacedRoleBinding2WithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified RoleBinding
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the RoleBinding
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1RoleBinding>> ReplaceNamespacedRoleBinding2WithHttpMessagesAsync(V1beta1RoleBinding body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a RoleBinding
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the RoleBinding
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedRoleBinding2WithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified RoleBinding
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the RoleBinding
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1RoleBinding>> PatchNamespacedRoleBinding2WithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind Role
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1RoleList>> ListNamespacedRole2WithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a Role
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1Role>> CreateNamespacedRole2WithHttpMessagesAsync(V1beta1Role body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of Role
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedRole2WithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified Role
        /// </summary>
        /// <param name='name'>
        /// name of the Role
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1Role>> ReadNamespacedRole2WithHttpMessagesAsync(string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified Role
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Role
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1Role>> ReplaceNamespacedRole2WithHttpMessagesAsync(V1beta1Role body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a Role
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Role
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedRole2WithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified Role
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the Role
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1Role>> PatchNamespacedRole2WithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind RoleBinding
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1RoleBindingList>> ListRoleBindingForAllNamespaces2WithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind Role
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1RoleList>> ListRoleForAllNamespaces2WithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get information of a group
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIGroup>> GetAPIGroup13WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get available resources
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources22WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind PriorityClass
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1PriorityClassList>> ListPriorityClassWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a PriorityClass
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1PriorityClass>> CreatePriorityClassWithHttpMessagesAsync(V1alpha1PriorityClass body, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of PriorityClass
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionPriorityClassWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified PriorityClass
        /// </summary>
        /// <param name='name'>
        /// name of the PriorityClass
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1PriorityClass>> ReadPriorityClassWithHttpMessagesAsync(string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified PriorityClass
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the PriorityClass
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1PriorityClass>> ReplacePriorityClassWithHttpMessagesAsync(V1alpha1PriorityClass body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a PriorityClass
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the PriorityClass
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeletePriorityClassWithHttpMessagesAsync(V1DeleteOptions body, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified PriorityClass
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the PriorityClass
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1PriorityClass>> PatchPriorityClassWithHttpMessagesAsync(V1Patch body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get information of a group
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIGroup>> GetAPIGroup14WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get available resources
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources23WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind PodPreset
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1PodPresetList>> ListNamespacedPodPresetWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a PodPreset
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1PodPreset>> CreateNamespacedPodPresetWithHttpMessagesAsync(V1alpha1PodPreset body, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of PodPreset
        /// </summary>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedPodPresetWithHttpMessagesAsync(string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified PodPreset
        /// </summary>
        /// <param name='name'>
        /// name of the PodPreset
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1PodPreset>> ReadNamespacedPodPresetWithHttpMessagesAsync(string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified PodPreset
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the PodPreset
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1PodPreset>> ReplaceNamespacedPodPresetWithHttpMessagesAsync(V1alpha1PodPreset body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a PodPreset
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the PodPreset
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteNamespacedPodPresetWithHttpMessagesAsync(V1DeleteOptions body, string name, string namespaceParameter, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified PodPreset
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the PodPreset
        /// </param>
        /// <param name='namespaceParameter'>
        /// object name and auth scope, such as for teams and projects
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1PodPreset>> PatchNamespacedPodPresetWithHttpMessagesAsync(V1Patch body, string name, string namespaceParameter, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind PodPreset
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1alpha1PodPresetList>> ListPodPresetForAllNamespacesWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get information of a group
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIGroup>> GetAPIGroup15WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get available resources
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources24WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind StorageClass
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1StorageClassList>> ListStorageClassWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a StorageClass
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1StorageClass>> CreateStorageClassWithHttpMessagesAsync(V1StorageClass body, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of StorageClass
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionStorageClassWithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified StorageClass
        /// </summary>
        /// <param name='name'>
        /// name of the StorageClass
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1StorageClass>> ReadStorageClassWithHttpMessagesAsync(string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified StorageClass
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the StorageClass
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1StorageClass>> ReplaceStorageClassWithHttpMessagesAsync(V1StorageClass body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a StorageClass
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the StorageClass
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteStorageClassWithHttpMessagesAsync(V1DeleteOptions body, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified StorageClass
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the StorageClass
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1StorageClass>> PatchStorageClassWithHttpMessagesAsync(V1Patch body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get available resources
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources25WithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch objects of kind StorageClass
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1StorageClassList>> ListStorageClass1WithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// create a StorageClass
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1StorageClass>> CreateStorageClass1WithHttpMessagesAsync(V1beta1StorageClass body, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete collection of StorageClass
        /// </summary>
        /// <param name='continueParameter'>
        /// The continue option should be set when retrieving more results from
        /// the server. Since this value is server defined, clients may only
        /// use the continue value from a previous query result with identical
        /// query parameters (except for the value of continue) and the server
        /// may reject a continue value it does not recognize. If the specified
        /// continue value is no longer valid whether due to expiration
        /// (generally five to fifteen minutes) or a configuration change on
        /// the server the server will respond with a 410 ResourceExpired error
        /// indicating the client must restart their list without the continue
        /// field. This field is not supported when watch is true. Clients may
        /// start a watch from the last resourceVersion value returned by the
        /// server and not miss any modifications.
        /// </param>
        /// <param name='fieldSelector'>
        /// A selector to restrict the list of returned objects by their
        /// fields. Defaults to everything.
        /// </param>
        /// <param name='includeUninitialized'>
        /// If true, partially initialized resources are included in the
        /// response.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='limit'>
        /// limit is a maximum number of responses to return for a list call.
        /// If more items exist, the server will set the `continue` field on
        /// the list metadata to a value that can be used with the same initial
        /// query to retrieve the next set of results. Setting a limit may
        /// return fewer than the requested amount of items (up to zero items)
        /// in the event all requested objects are filtered out and clients
        /// should only use the presence of the continue field to determine
        /// whether more results are available. Servers may choose not to
        /// support the limit argument and will return all of the available
        /// results. If limit is specified and the continue field is empty,
        /// clients may assume that no more results are available. This field
        /// is not supported if watch is true.
        ///
        /// The server guarantees that the objects returned when using continue
        /// will be identical to issuing a single list call without a limit -
        /// that is, no objects created, modified, or deleted after the first
        /// request is issued will be included in any subsequent continued
        /// requests. This is sometimes referred to as a consistent snapshot,
        /// and ensures that a client that is using limit to receive smaller
        /// chunks of a very large result can ensure they see all possible
        /// objects. If objects are updated during a chunked list the version
        /// of the object that was present at the time the first list result
        /// was calculated is returned.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='timeoutSeconds'>
        /// Timeout for the list/watch call.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications. Specify
        /// resourceVersion.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteCollectionStorageClass1WithHttpMessagesAsync(string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// read the specified StorageClass
        /// </summary>
        /// <param name='name'>
        /// name of the StorageClass
        /// </param>
        /// <param name='exact'>
        /// Should the export be exact.  Exact export maintains
        /// cluster-specific fields like 'Namespace'.
        /// </param>
        /// <param name='export'>
        /// Should this value be exported.  Export strips fields that a user
        /// can not specify.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1StorageClass>> ReadStorageClass1WithHttpMessagesAsync(string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified StorageClass
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the StorageClass
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1StorageClass>> ReplaceStorageClass1WithHttpMessagesAsync(V1beta1StorageClass body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// delete a StorageClass
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the StorageClass
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1Status>> DeleteStorageClass1WithHttpMessagesAsync(V1DeleteOptions body, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// partially update the specified StorageClass
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='name'>
        /// name of the StorageClass
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<V1beta1StorageClass>> PatchStorageClass1WithHttpMessagesAsync(V1Patch body, string name, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse> LogFileListHandlerWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <param name='logpath'>
        /// path to the log
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse> LogFileHandlerWithHttpMessagesAsync(string logpath, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// get the code version
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<VersionInfo>> GetCodeWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Creates a cluster scoped Custom object
        /// </summary>
        /// <param name='body'>
        /// The JSON schema of the Resource to create.
        /// </param>
        /// <param name='group'>
        /// The custom resource's group name
        /// </param>
        /// <param name='version'>
        /// The custom resource's version
        /// </param>
        /// <param name='plural'>
        /// The custom resource's plural name. For TPRs this would be lowercase
        /// plural kind.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> CreateClusterCustomObjectWithHttpMessagesAsync(object body, string group, string version, string plural, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch cluster scoped custom objects
        /// </summary>
        /// <param name='group'>
        /// The custom resource's group name
        /// </param>
        /// <param name='version'>
        /// The custom resource's version
        /// </param>
        /// <param name='plural'>
        /// The custom resource's plural name. For TPRs this would be lowercase
        /// plural kind.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> ListClusterCustomObjectWithHttpMessagesAsync(string group, string version, string plural, string labelSelector = default(string), string resourceVersion = default(string), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Creates a namespace scoped Custom object
        /// </summary>
        /// <param name='body'>
        /// The JSON schema of the Resource to create.
        /// </param>
        /// <param name='group'>
        /// The custom resource's group name
        /// </param>
        /// <param name='version'>
        /// The custom resource's version
        /// </param>
        /// <param name='namespaceParameter'>
        /// The custom resource's namespace
        /// </param>
        /// <param name='plural'>
        /// The custom resource's plural name. For TPRs this would be lowercase
        /// plural kind.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> CreateNamespacedCustomObjectWithHttpMessagesAsync(object body, string group, string version, string namespaceParameter, string plural, string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// list or watch namespace scoped custom objects
        /// </summary>
        /// <param name='group'>
        /// The custom resource's group name
        /// </param>
        /// <param name='version'>
        /// The custom resource's version
        /// </param>
        /// <param name='namespaceParameter'>
        /// The custom resource's namespace
        /// </param>
        /// <param name='plural'>
        /// The custom resource's plural name. For TPRs this would be lowercase
        /// plural kind.
        /// </param>
        /// <param name='labelSelector'>
        /// A selector to restrict the list of returned objects by their
        /// labels. Defaults to everything.
        /// </param>
        /// <param name='resourceVersion'>
        /// When specified with a watch call, shows changes that occur after
        /// that particular version of a resource. Defaults to changes from the
        /// beginning of history. When specified for list: - if unset, then the
        /// result is returned from remote storage based on quorum-read flag; -
        /// if it's 0, then we simply return what we currently have in cache,
        /// no guarantee; - if set to non zero, then the result is at least as
        /// fresh as given rv.
        /// </param>
        /// <param name='watch'>
        /// Watch for changes to the described resources and return them as a
        /// stream of add, update, and remove notifications.
        /// </param>
        /// <param name='pretty'>
        /// If 'true', then the output is pretty printed.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> ListNamespacedCustomObjectWithHttpMessagesAsync(string group, string version, string namespaceParameter, string plural, string labelSelector = default(string), string resourceVersion = default(string), bool? watch = default(bool?), string pretty = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified cluster scoped custom object
        /// </summary>
        /// <param name='body'>
        /// The JSON schema of the Resource to replace.
        /// </param>
        /// <param name='group'>
        /// the custom resource's group
        /// </param>
        /// <param name='version'>
        /// the custom resource's version
        /// </param>
        /// <param name='plural'>
        /// the custom object's plural name. For TPRs this would be lowercase
        /// plural kind.
        /// </param>
        /// <param name='name'>
        /// the custom object's name
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> ReplaceClusterCustomObjectWithHttpMessagesAsync(object body, string group, string version, string plural, string name, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Deletes the specified cluster scoped custom object
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='group'>
        /// the custom resource's group
        /// </param>
        /// <param name='version'>
        /// the custom resource's version
        /// </param>
        /// <param name='plural'>
        /// the custom object's plural name. For TPRs this would be lowercase
        /// plural kind.
        /// </param>
        /// <param name='name'>
        /// the custom object's name
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> DeleteClusterCustomObjectWithHttpMessagesAsync(V1DeleteOptions body, string group, string version, string plural, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Returns a cluster scoped custom object
        /// </summary>
        /// <param name='group'>
        /// the custom resource's group
        /// </param>
        /// <param name='version'>
        /// the custom resource's version
        /// </param>
        /// <param name='plural'>
        /// the custom object's plural name. For TPRs this would be lowercase
        /// plural kind.
        /// </param>
        /// <param name='name'>
        /// the custom object's name
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> GetClusterCustomObjectWithHttpMessagesAsync(string group, string version, string plural, string name, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// replace the specified namespace scoped custom object
        /// </summary>
        /// <param name='body'>
        /// The JSON schema of the Resource to replace.
        /// </param>
        /// <param name='group'>
        /// the custom resource's group
        /// </param>
        /// <param name='version'>
        /// the custom resource's version
        /// </param>
        /// <param name='namespaceParameter'>
        /// The custom resource's namespace
        /// </param>
        /// <param name='plural'>
        /// the custom resource's plural name. For TPRs this would be lowercase
        /// plural kind.
        /// </param>
        /// <param name='name'>
        /// the custom object's name
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> ReplaceNamespacedCustomObjectWithHttpMessagesAsync(object body, string group, string version, string namespaceParameter, string plural, string name, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Deletes the specified namespace scoped custom object
        /// </summary>
        /// <param name='body'>
        /// </param>
        /// <param name='group'>
        /// the custom resource's group
        /// </param>
        /// <param name='version'>
        /// the custom resource's version
        /// </param>
        /// <param name='namespaceParameter'>
        /// The custom resource's namespace
        /// </param>
        /// <param name='plural'>
        /// the custom resource's plural name. For TPRs this would be lowercase
        /// plural kind.
        /// </param>
        /// <param name='name'>
        /// the custom object's name
        /// </param>
        /// <param name='gracePeriodSeconds'>
        /// The duration in seconds before the object should be deleted. Value
        /// must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period for the
        /// specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </param>
        /// <param name='orphanDependents'>
        /// Deprecated: please use the PropagationPolicy, this field will be
        /// deprecated in 1.7. Should the dependent objects be orphaned. If
        /// true/false, the "orphan" finalizer will be added to/removed from
        /// the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </param>
        /// <param name='propagationPolicy'>
        /// Whether and how garbage collection will be performed. Either this
        /// field or OrphanDependents may be set, but not both. The default
        /// policy is decided by the existing finalizer set in the
        /// metadata.finalizers and the resource-specific default policy.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> DeleteNamespacedCustomObjectWithHttpMessagesAsync(V1DeleteOptions body, string group, string version, string namespaceParameter, string plural, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Returns a namespace scoped custom object
        /// </summary>
        /// <param name='group'>
        /// the custom resource's group
        /// </param>
        /// <param name='version'>
        /// the custom resource's version
        /// </param>
        /// <param name='namespaceParameter'>
        /// The custom resource's namespace
        /// </param>
        /// <param name='plural'>
        /// the custom resource's plural name. For TPRs this would be lowercase
        /// plural kind.
        /// </param>
        /// <param name='name'>
        /// the custom object's name
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> GetNamespacedCustomObjectWithHttpMessagesAsync(string group, string version, string namespaceParameter, string plural, string name, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

    }
}
