// <auto-generated>
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace k8s
{
    using Models;
    using System.IO;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>
    /// Extension methods for Kubernetes.
    /// </summary>
    public static partial class KubernetesExtensions
    {
            /// <summary>
            /// get available API versions
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIVersions GetAPIVersions(this IKubernetes operations)
            {
                return operations.GetAPIVersionsAsync().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available API versions
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIVersions> GetAPIVersionsAsync(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIVersionsWithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIResourceList GetAPIResources(this IKubernetes operations)
            {
                return operations.GetAPIResourcesAsync().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIResourceList> GetAPIResourcesAsync(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIResourcesWithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list objects of kind ComponentStatus
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1ComponentStatusList ListComponentStatus(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListComponentStatusAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list objects of kind ComponentStatus
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ComponentStatusList> ListComponentStatusAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListComponentStatusWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified ComponentStatus
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ComponentStatus
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ComponentStatus ReadComponentStatus(this IKubernetes operations, string name, string pretty = default(string))
            {
                return operations.ReadComponentStatusAsync(name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified ComponentStatus
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ComponentStatus
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ComponentStatus> ReadComponentStatusAsync(this IKubernetes operations, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadComponentStatusWithHttpMessagesAsync(name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind ConfigMap
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1ConfigMapList ListConfigMapForAllNamespaces(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListConfigMapForAllNamespacesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind ConfigMap
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ConfigMapList> ListConfigMapForAllNamespacesAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListConfigMapForAllNamespacesWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind Endpoints
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1EndpointsList ListEndpointsForAllNamespaces(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListEndpointsForAllNamespacesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind Endpoints
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1EndpointsList> ListEndpointsForAllNamespacesAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListEndpointsForAllNamespacesWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind Event
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1EventList ListEventForAllNamespaces(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListEventForAllNamespacesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind Event
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1EventList> ListEventForAllNamespacesAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListEventForAllNamespacesWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind LimitRange
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1LimitRangeList ListLimitRangeForAllNamespaces(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListLimitRangeForAllNamespacesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind LimitRange
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1LimitRangeList> ListLimitRangeForAllNamespacesAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListLimitRangeForAllNamespacesWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind Namespace
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1NamespaceList ListNamespace(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespaceAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind Namespace
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1NamespaceList> ListNamespaceAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespaceWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a Namespace
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Namespace CreateNamespace(this IKubernetes operations, V1Namespace body, string pretty = default(string))
            {
                return operations.CreateNamespaceAsync(body, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a Namespace
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Namespace> CreateNamespaceAsync(this IKubernetes operations, V1Namespace body, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespaceWithHttpMessagesAsync(body, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a Binding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Binding CreateNamespacedBinding(this IKubernetes operations, V1Binding body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedBindingAsync(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a Binding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Binding> CreateNamespacedBindingAsync(this IKubernetes operations, V1Binding body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedBindingWithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind ConfigMap
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ConfigMapList ListNamespacedConfigMap(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedConfigMapAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind ConfigMap
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ConfigMapList> ListNamespacedConfigMapAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedConfigMapWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a ConfigMap
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ConfigMap CreateNamespacedConfigMap(this IKubernetes operations, V1ConfigMap body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedConfigMapAsync(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a ConfigMap
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ConfigMap> CreateNamespacedConfigMapAsync(this IKubernetes operations, V1ConfigMap body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedConfigMapWithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of ConfigMap
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedConfigMap(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedConfigMapAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of ConfigMap
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedConfigMapAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedConfigMapWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified ConfigMap
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ConfigMap
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ConfigMap ReadNamespacedConfigMap(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedConfigMapAsync(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified ConfigMap
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ConfigMap
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ConfigMap> ReadNamespacedConfigMapAsync(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedConfigMapWithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified ConfigMap
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ConfigMap
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ConfigMap ReplaceNamespacedConfigMap(this IKubernetes operations, V1ConfigMap body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedConfigMapAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified ConfigMap
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ConfigMap
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ConfigMap> ReplaceNamespacedConfigMapAsync(this IKubernetes operations, V1ConfigMap body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedConfigMapWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a ConfigMap
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ConfigMap
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedConfigMap(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedConfigMapAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a ConfigMap
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ConfigMap
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedConfigMapAsync(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedConfigMapWithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified ConfigMap
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ConfigMap
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ConfigMap PatchNamespacedConfigMap(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedConfigMapAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified ConfigMap
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ConfigMap
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ConfigMap> PatchNamespacedConfigMapAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedConfigMapWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind Endpoints
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1EndpointsList ListNamespacedEndpoints(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedEndpointsAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind Endpoints
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1EndpointsList> ListNamespacedEndpointsAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedEndpointsWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create Endpoints
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Endpoints CreateNamespacedEndpoints(this IKubernetes operations, V1Endpoints body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedEndpointsAsync(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create Endpoints
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Endpoints> CreateNamespacedEndpointsAsync(this IKubernetes operations, V1Endpoints body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedEndpointsWithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of Endpoints
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedEndpoints(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedEndpointsAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of Endpoints
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedEndpointsAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedEndpointsWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified Endpoints
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Endpoints
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Endpoints ReadNamespacedEndpoints(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedEndpointsAsync(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified Endpoints
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Endpoints
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Endpoints> ReadNamespacedEndpointsAsync(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedEndpointsWithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified Endpoints
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Endpoints
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Endpoints ReplaceNamespacedEndpoints(this IKubernetes operations, V1Endpoints body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedEndpointsAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified Endpoints
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Endpoints
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Endpoints> ReplaceNamespacedEndpointsAsync(this IKubernetes operations, V1Endpoints body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedEndpointsWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete Endpoints
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Endpoints
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedEndpoints(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedEndpointsAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete Endpoints
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Endpoints
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedEndpointsAsync(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedEndpointsWithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified Endpoints
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Endpoints
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Endpoints PatchNamespacedEndpoints(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedEndpointsAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified Endpoints
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Endpoints
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Endpoints> PatchNamespacedEndpointsAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedEndpointsWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind Event
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1EventList ListNamespacedEvent(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedEventAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind Event
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1EventList> ListNamespacedEventAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedEventWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create an Event
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Event CreateNamespacedEvent(this IKubernetes operations, V1Event body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedEventAsync(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create an Event
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Event> CreateNamespacedEventAsync(this IKubernetes operations, V1Event body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedEventWithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of Event
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedEvent(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedEventAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of Event
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedEventAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedEventWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified Event
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Event
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Event ReadNamespacedEvent(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedEventAsync(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified Event
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Event
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Event> ReadNamespacedEventAsync(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedEventWithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified Event
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Event
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Event ReplaceNamespacedEvent(this IKubernetes operations, V1Event body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedEventAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified Event
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Event
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Event> ReplaceNamespacedEventAsync(this IKubernetes operations, V1Event body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedEventWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete an Event
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Event
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedEvent(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedEventAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete an Event
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Event
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedEventAsync(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedEventWithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified Event
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Event
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Event PatchNamespacedEvent(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedEventAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified Event
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Event
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Event> PatchNamespacedEventAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedEventWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind LimitRange
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1LimitRangeList ListNamespacedLimitRange(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedLimitRangeAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind LimitRange
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1LimitRangeList> ListNamespacedLimitRangeAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedLimitRangeWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a LimitRange
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1LimitRange CreateNamespacedLimitRange(this IKubernetes operations, V1LimitRange body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedLimitRangeAsync(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a LimitRange
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1LimitRange> CreateNamespacedLimitRangeAsync(this IKubernetes operations, V1LimitRange body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedLimitRangeWithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of LimitRange
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedLimitRange(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedLimitRangeAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of LimitRange
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedLimitRangeAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedLimitRangeWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified LimitRange
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the LimitRange
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1LimitRange ReadNamespacedLimitRange(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedLimitRangeAsync(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified LimitRange
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the LimitRange
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1LimitRange> ReadNamespacedLimitRangeAsync(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedLimitRangeWithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified LimitRange
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the LimitRange
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1LimitRange ReplaceNamespacedLimitRange(this IKubernetes operations, V1LimitRange body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedLimitRangeAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified LimitRange
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the LimitRange
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1LimitRange> ReplaceNamespacedLimitRangeAsync(this IKubernetes operations, V1LimitRange body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedLimitRangeWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a LimitRange
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the LimitRange
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedLimitRange(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedLimitRangeAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a LimitRange
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the LimitRange
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedLimitRangeAsync(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedLimitRangeWithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified LimitRange
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the LimitRange
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1LimitRange PatchNamespacedLimitRange(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedLimitRangeAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified LimitRange
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the LimitRange
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1LimitRange> PatchNamespacedLimitRangeAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedLimitRangeWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind PersistentVolumeClaim
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1PersistentVolumeClaimList ListNamespacedPersistentVolumeClaim(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedPersistentVolumeClaimAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind PersistentVolumeClaim
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1PersistentVolumeClaimList> ListNamespacedPersistentVolumeClaimAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedPersistentVolumeClaimWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a PersistentVolumeClaim
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1PersistentVolumeClaim CreateNamespacedPersistentVolumeClaim(this IKubernetes operations, V1PersistentVolumeClaim body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedPersistentVolumeClaimAsync(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a PersistentVolumeClaim
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1PersistentVolumeClaim> CreateNamespacedPersistentVolumeClaimAsync(this IKubernetes operations, V1PersistentVolumeClaim body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedPersistentVolumeClaimWithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of PersistentVolumeClaim
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedPersistentVolumeClaim(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedPersistentVolumeClaimAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of PersistentVolumeClaim
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedPersistentVolumeClaimAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedPersistentVolumeClaimWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified PersistentVolumeClaim
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PersistentVolumeClaim
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1PersistentVolumeClaim ReadNamespacedPersistentVolumeClaim(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedPersistentVolumeClaimAsync(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified PersistentVolumeClaim
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PersistentVolumeClaim
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1PersistentVolumeClaim> ReadNamespacedPersistentVolumeClaimAsync(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedPersistentVolumeClaimWithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified PersistentVolumeClaim
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PersistentVolumeClaim
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1PersistentVolumeClaim ReplaceNamespacedPersistentVolumeClaim(this IKubernetes operations, V1PersistentVolumeClaim body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedPersistentVolumeClaimAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified PersistentVolumeClaim
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PersistentVolumeClaim
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1PersistentVolumeClaim> ReplaceNamespacedPersistentVolumeClaimAsync(this IKubernetes operations, V1PersistentVolumeClaim body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedPersistentVolumeClaimWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a PersistentVolumeClaim
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PersistentVolumeClaim
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedPersistentVolumeClaim(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedPersistentVolumeClaimAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a PersistentVolumeClaim
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PersistentVolumeClaim
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedPersistentVolumeClaimAsync(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedPersistentVolumeClaimWithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified PersistentVolumeClaim
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PersistentVolumeClaim
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1PersistentVolumeClaim PatchNamespacedPersistentVolumeClaim(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedPersistentVolumeClaimAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified PersistentVolumeClaim
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PersistentVolumeClaim
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1PersistentVolumeClaim> PatchNamespacedPersistentVolumeClaimAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedPersistentVolumeClaimWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified PersistentVolumeClaim
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PersistentVolumeClaim
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1PersistentVolumeClaim ReadNamespacedPersistentVolumeClaimStatus(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedPersistentVolumeClaimStatusAsync(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified PersistentVolumeClaim
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PersistentVolumeClaim
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1PersistentVolumeClaim> ReadNamespacedPersistentVolumeClaimStatusAsync(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedPersistentVolumeClaimStatusWithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the specified PersistentVolumeClaim
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PersistentVolumeClaim
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1PersistentVolumeClaim ReplaceNamespacedPersistentVolumeClaimStatus(this IKubernetes operations, V1PersistentVolumeClaim body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedPersistentVolumeClaimStatusAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the specified PersistentVolumeClaim
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PersistentVolumeClaim
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1PersistentVolumeClaim> ReplaceNamespacedPersistentVolumeClaimStatusAsync(this IKubernetes operations, V1PersistentVolumeClaim body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedPersistentVolumeClaimStatusWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified PersistentVolumeClaim
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PersistentVolumeClaim
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1PersistentVolumeClaim PatchNamespacedPersistentVolumeClaimStatus(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedPersistentVolumeClaimStatusAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified PersistentVolumeClaim
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PersistentVolumeClaim
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1PersistentVolumeClaim> PatchNamespacedPersistentVolumeClaimStatusAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedPersistentVolumeClaimStatusWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1PodList ListNamespacedPod(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedPodAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1PodList> ListNamespacedPodAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedPodWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Pod CreateNamespacedPod(this IKubernetes operations, V1Pod body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedPodAsync(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Pod> CreateNamespacedPodAsync(this IKubernetes operations, V1Pod body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedPodWithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedPod(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedPodAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedPodAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedPodWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Pod
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Pod ReadNamespacedPod(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedPodAsync(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Pod
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Pod> ReadNamespacedPodAsync(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedPodWithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Pod
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Pod ReplaceNamespacedPod(this IKubernetes operations, V1Pod body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedPodAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Pod
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Pod> ReplaceNamespacedPodAsync(this IKubernetes operations, V1Pod body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedPodWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Pod
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedPod(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedPodAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Pod
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedPodAsync(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedPodWithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Pod
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Pod PatchNamespacedPod(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedPodAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Pod
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Pod> PatchNamespacedPodAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedPodWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect GET requests to attach of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodAttachOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='container'>
            /// The container in which to execute the command. Defaults to only container
            /// if there is only one container in the pod.
            /// </param>
            /// <param name='stderr'>
            /// Stderr if true indicates that stderr is to be redirected for the attach
            /// call. Defaults to true.
            /// </param>
            /// <param name='stdin'>
            /// Stdin if true, redirects the standard input stream of the pod for this
            /// call. Defaults to false.
            /// </param>
            /// <param name='stdout'>
            /// Stdout if true indicates that stdout is to be redirected for the attach
            /// call. Defaults to true.
            /// </param>
            /// <param name='tty'>
            /// TTY if true indicates that a tty will be allocated for the attach call.
            /// This is passed through the container runtime so the tty is allocated on the
            /// worker node by the container runtime. Defaults to false.
            /// </param>
            public static string ConnectGetNamespacedPodAttach(this IKubernetes operations, string name, string namespaceParameter, string container = default(string), bool? stderr = default(bool?), bool? stdin = default(bool?), bool? stdout = default(bool?), bool? tty = default(bool?))
            {
                return operations.ConnectGetNamespacedPodAttachAsync(name, namespaceParameter, container, stderr, stdin, stdout, tty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect GET requests to attach of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodAttachOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='container'>
            /// The container in which to execute the command. Defaults to only container
            /// if there is only one container in the pod.
            /// </param>
            /// <param name='stderr'>
            /// Stderr if true indicates that stderr is to be redirected for the attach
            /// call. Defaults to true.
            /// </param>
            /// <param name='stdin'>
            /// Stdin if true, redirects the standard input stream of the pod for this
            /// call. Defaults to false.
            /// </param>
            /// <param name='stdout'>
            /// Stdout if true indicates that stdout is to be redirected for the attach
            /// call. Defaults to true.
            /// </param>
            /// <param name='tty'>
            /// TTY if true indicates that a tty will be allocated for the attach call.
            /// This is passed through the container runtime so the tty is allocated on the
            /// worker node by the container runtime. Defaults to false.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectGetNamespacedPodAttachAsync(this IKubernetes operations, string name, string namespaceParameter, string container = default(string), bool? stderr = default(bool?), bool? stdin = default(bool?), bool? stdout = default(bool?), bool? tty = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectGetNamespacedPodAttachWithHttpMessagesAsync(name, namespaceParameter, container, stderr, stdin, stdout, tty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect POST requests to attach of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodAttachOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='container'>
            /// The container in which to execute the command. Defaults to only container
            /// if there is only one container in the pod.
            /// </param>
            /// <param name='stderr'>
            /// Stderr if true indicates that stderr is to be redirected for the attach
            /// call. Defaults to true.
            /// </param>
            /// <param name='stdin'>
            /// Stdin if true, redirects the standard input stream of the pod for this
            /// call. Defaults to false.
            /// </param>
            /// <param name='stdout'>
            /// Stdout if true indicates that stdout is to be redirected for the attach
            /// call. Defaults to true.
            /// </param>
            /// <param name='tty'>
            /// TTY if true indicates that a tty will be allocated for the attach call.
            /// This is passed through the container runtime so the tty is allocated on the
            /// worker node by the container runtime. Defaults to false.
            /// </param>
            public static string ConnectPostNamespacedPodAttach(this IKubernetes operations, string name, string namespaceParameter, string container = default(string), bool? stderr = default(bool?), bool? stdin = default(bool?), bool? stdout = default(bool?), bool? tty = default(bool?))
            {
                return operations.ConnectPostNamespacedPodAttachAsync(name, namespaceParameter, container, stderr, stdin, stdout, tty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect POST requests to attach of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodAttachOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='container'>
            /// The container in which to execute the command. Defaults to only container
            /// if there is only one container in the pod.
            /// </param>
            /// <param name='stderr'>
            /// Stderr if true indicates that stderr is to be redirected for the attach
            /// call. Defaults to true.
            /// </param>
            /// <param name='stdin'>
            /// Stdin if true, redirects the standard input stream of the pod for this
            /// call. Defaults to false.
            /// </param>
            /// <param name='stdout'>
            /// Stdout if true indicates that stdout is to be redirected for the attach
            /// call. Defaults to true.
            /// </param>
            /// <param name='tty'>
            /// TTY if true indicates that a tty will be allocated for the attach call.
            /// This is passed through the container runtime so the tty is allocated on the
            /// worker node by the container runtime. Defaults to false.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectPostNamespacedPodAttachAsync(this IKubernetes operations, string name, string namespaceParameter, string container = default(string), bool? stderr = default(bool?), bool? stdin = default(bool?), bool? stdout = default(bool?), bool? tty = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectPostNamespacedPodAttachWithHttpMessagesAsync(name, namespaceParameter, container, stderr, stdin, stdout, tty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create binding of a Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Binding
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Binding CreateNamespacedPodBinding(this IKubernetes operations, V1Binding body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedPodBindingAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create binding of a Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Binding
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Binding> CreateNamespacedPodBindingAsync(this IKubernetes operations, V1Binding body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedPodBindingWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create eviction of a Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Eviction
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1Eviction CreateNamespacedPodEviction(this IKubernetes operations, V1beta1Eviction body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedPodEvictionAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create eviction of a Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Eviction
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1Eviction> CreateNamespacedPodEvictionAsync(this IKubernetes operations, V1beta1Eviction body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedPodEvictionWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect GET requests to exec of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodExecOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='command'>
            /// Command is the remote command to execute. argv array. Not executed within a
            /// shell.
            /// </param>
            /// <param name='container'>
            /// Container in which to execute the command. Defaults to only container if
            /// there is only one container in the pod.
            /// </param>
            /// <param name='stderr'>
            /// Redirect the standard error stream of the pod for this call. Defaults to
            /// true.
            /// </param>
            /// <param name='stdin'>
            /// Redirect the standard input stream of the pod for this call. Defaults to
            /// false.
            /// </param>
            /// <param name='stdout'>
            /// Redirect the standard output stream of the pod for this call. Defaults to
            /// true.
            /// </param>
            /// <param name='tty'>
            /// TTY if true indicates that a tty will be allocated for the exec call.
            /// Defaults to false.
            /// </param>
            public static string ConnectGetNamespacedPodExec(this IKubernetes operations, string name, string namespaceParameter, string command = default(string), string container = default(string), bool? stderr = default(bool?), bool? stdin = default(bool?), bool? stdout = default(bool?), bool? tty = default(bool?))
            {
                return operations.ConnectGetNamespacedPodExecAsync(name, namespaceParameter, command, container, stderr, stdin, stdout, tty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect GET requests to exec of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodExecOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='command'>
            /// Command is the remote command to execute. argv array. Not executed within a
            /// shell.
            /// </param>
            /// <param name='container'>
            /// Container in which to execute the command. Defaults to only container if
            /// there is only one container in the pod.
            /// </param>
            /// <param name='stderr'>
            /// Redirect the standard error stream of the pod for this call. Defaults to
            /// true.
            /// </param>
            /// <param name='stdin'>
            /// Redirect the standard input stream of the pod for this call. Defaults to
            /// false.
            /// </param>
            /// <param name='stdout'>
            /// Redirect the standard output stream of the pod for this call. Defaults to
            /// true.
            /// </param>
            /// <param name='tty'>
            /// TTY if true indicates that a tty will be allocated for the exec call.
            /// Defaults to false.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectGetNamespacedPodExecAsync(this IKubernetes operations, string name, string namespaceParameter, string command = default(string), string container = default(string), bool? stderr = default(bool?), bool? stdin = default(bool?), bool? stdout = default(bool?), bool? tty = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectGetNamespacedPodExecWithHttpMessagesAsync(name, namespaceParameter, command, container, stderr, stdin, stdout, tty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect POST requests to exec of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodExecOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='command'>
            /// Command is the remote command to execute. argv array. Not executed within a
            /// shell.
            /// </param>
            /// <param name='container'>
            /// Container in which to execute the command. Defaults to only container if
            /// there is only one container in the pod.
            /// </param>
            /// <param name='stderr'>
            /// Redirect the standard error stream of the pod for this call. Defaults to
            /// true.
            /// </param>
            /// <param name='stdin'>
            /// Redirect the standard input stream of the pod for this call. Defaults to
            /// false.
            /// </param>
            /// <param name='stdout'>
            /// Redirect the standard output stream of the pod for this call. Defaults to
            /// true.
            /// </param>
            /// <param name='tty'>
            /// TTY if true indicates that a tty will be allocated for the exec call.
            /// Defaults to false.
            /// </param>
            public static string ConnectPostNamespacedPodExec(this IKubernetes operations, string name, string namespaceParameter, string command = default(string), string container = default(string), bool? stderr = default(bool?), bool? stdin = default(bool?), bool? stdout = default(bool?), bool? tty = default(bool?))
            {
                return operations.ConnectPostNamespacedPodExecAsync(name, namespaceParameter, command, container, stderr, stdin, stdout, tty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect POST requests to exec of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodExecOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='command'>
            /// Command is the remote command to execute. argv array. Not executed within a
            /// shell.
            /// </param>
            /// <param name='container'>
            /// Container in which to execute the command. Defaults to only container if
            /// there is only one container in the pod.
            /// </param>
            /// <param name='stderr'>
            /// Redirect the standard error stream of the pod for this call. Defaults to
            /// true.
            /// </param>
            /// <param name='stdin'>
            /// Redirect the standard input stream of the pod for this call. Defaults to
            /// false.
            /// </param>
            /// <param name='stdout'>
            /// Redirect the standard output stream of the pod for this call. Defaults to
            /// true.
            /// </param>
            /// <param name='tty'>
            /// TTY if true indicates that a tty will be allocated for the exec call.
            /// Defaults to false.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectPostNamespacedPodExecAsync(this IKubernetes operations, string name, string namespaceParameter, string command = default(string), string container = default(string), bool? stderr = default(bool?), bool? stdin = default(bool?), bool? stdout = default(bool?), bool? tty = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectPostNamespacedPodExecWithHttpMessagesAsync(name, namespaceParameter, command, container, stderr, stdin, stdout, tty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read log of the specified Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Pod
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='container'>
            /// The container for which to stream logs. Defaults to only container if there
            /// is one container in the pod.
            /// </param>
            /// <param name='follow'>
            /// Follow the log stream of the pod. Defaults to false.
            /// </param>
            /// <param name='limitBytes'>
            /// If set, the number of bytes to read from the server before terminating the
            /// log output. This may not display a complete final line of logging, and may
            /// return slightly more or slightly less than the specified limit.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='previous'>
            /// Return previous terminated container logs. Defaults to false.
            /// </param>
            /// <param name='sinceSeconds'>
            /// A relative time in seconds before the current time from which to show logs.
            /// If this value precedes the time a pod was started, only logs since the pod
            /// start will be returned. If this value is in the future, no logs will be
            /// returned. Only one of sinceSeconds or sinceTime may be specified.
            /// </param>
            /// <param name='tailLines'>
            /// If set, the number of lines from the end of the logs to show. If not
            /// specified, logs are shown from the creation of the container or
            /// sinceSeconds or sinceTime
            /// </param>
            /// <param name='timestamps'>
            /// If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every
            /// line of log output. Defaults to false.
            /// </param>
            public static Stream ReadNamespacedPodLog(this IKubernetes operations, string name, string namespaceParameter, string container = default(string), bool? follow = default(bool?), int? limitBytes = default(int?), string pretty = default(string), bool? previous = default(bool?), int? sinceSeconds = default(int?), int? tailLines = default(int?), bool? timestamps = default(bool?))
            {
                return operations.ReadNamespacedPodLogAsync(name, namespaceParameter, container, follow, limitBytes, pretty, previous, sinceSeconds, tailLines, timestamps).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read log of the specified Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Pod
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='container'>
            /// The container for which to stream logs. Defaults to only container if there
            /// is one container in the pod.
            /// </param>
            /// <param name='follow'>
            /// Follow the log stream of the pod. Defaults to false.
            /// </param>
            /// <param name='limitBytes'>
            /// If set, the number of bytes to read from the server before terminating the
            /// log output. This may not display a complete final line of logging, and may
            /// return slightly more or slightly less than the specified limit.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='previous'>
            /// Return previous terminated container logs. Defaults to false.
            /// </param>
            /// <param name='sinceSeconds'>
            /// A relative time in seconds before the current time from which to show logs.
            /// If this value precedes the time a pod was started, only logs since the pod
            /// start will be returned. If this value is in the future, no logs will be
            /// returned. Only one of sinceSeconds or sinceTime may be specified.
            /// </param>
            /// <param name='tailLines'>
            /// If set, the number of lines from the end of the logs to show. If not
            /// specified, logs are shown from the creation of the container or
            /// sinceSeconds or sinceTime
            /// </param>
            /// <param name='timestamps'>
            /// If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every
            /// line of log output. Defaults to false.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Stream> ReadNamespacedPodLogAsync(this IKubernetes operations, string name, string namespaceParameter, string container = default(string), bool? follow = default(bool?), int? limitBytes = default(int?), string pretty = default(string), bool? previous = default(bool?), int? sinceSeconds = default(int?), int? tailLines = default(int?), bool? timestamps = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                var _result = await operations.ReadNamespacedPodLogWithHttpMessagesAsync(name, namespaceParameter, container, follow, limitBytes, pretty, previous, sinceSeconds, tailLines, timestamps, null, cancellationToken).ConfigureAwait(false);
                _result.Request.Dispose();
                return _result.Body;
            }

            /// <summary>
            /// connect GET requests to portforward of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodPortForwardOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='ports'>
            /// List of ports to forward Required when using WebSockets
            /// </param>
            public static string ConnectGetNamespacedPodPortforward(this IKubernetes operations, string name, string namespaceParameter, int? ports = default(int?))
            {
                return operations.ConnectGetNamespacedPodPortforwardAsync(name, namespaceParameter, ports).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect GET requests to portforward of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodPortForwardOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='ports'>
            /// List of ports to forward Required when using WebSockets
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectGetNamespacedPodPortforwardAsync(this IKubernetes operations, string name, string namespaceParameter, int? ports = default(int?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectGetNamespacedPodPortforwardWithHttpMessagesAsync(name, namespaceParameter, ports, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect POST requests to portforward of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodPortForwardOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='ports'>
            /// List of ports to forward Required when using WebSockets
            /// </param>
            public static string ConnectPostNamespacedPodPortforward(this IKubernetes operations, string name, string namespaceParameter, int? ports = default(int?))
            {
                return operations.ConnectPostNamespacedPodPortforwardAsync(name, namespaceParameter, ports).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect POST requests to portforward of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodPortForwardOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='ports'>
            /// List of ports to forward Required when using WebSockets
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectPostNamespacedPodPortforwardAsync(this IKubernetes operations, string name, string namespaceParameter, int? ports = default(int?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectPostNamespacedPodPortforwardWithHttpMessagesAsync(name, namespaceParameter, ports, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect GET requests to proxy of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// Path is the URL path to use for the current proxy request to pod.
            /// </param>
            public static string ConnectGetNamespacedPodProxy(this IKubernetes operations, string name, string namespaceParameter, string path = default(string))
            {
                return operations.ConnectGetNamespacedPodProxyAsync(name, namespaceParameter, path).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect GET requests to proxy of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// Path is the URL path to use for the current proxy request to pod.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectGetNamespacedPodProxyAsync(this IKubernetes operations, string name, string namespaceParameter, string path = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectGetNamespacedPodProxyWithHttpMessagesAsync(name, namespaceParameter, path, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect PUT requests to proxy of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// Path is the URL path to use for the current proxy request to pod.
            /// </param>
            public static string ConnectPutNamespacedPodProxy(this IKubernetes operations, string name, string namespaceParameter, string path = default(string))
            {
                return operations.ConnectPutNamespacedPodProxyAsync(name, namespaceParameter, path).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect PUT requests to proxy of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// Path is the URL path to use for the current proxy request to pod.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectPutNamespacedPodProxyAsync(this IKubernetes operations, string name, string namespaceParameter, string path = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectPutNamespacedPodProxyWithHttpMessagesAsync(name, namespaceParameter, path, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect POST requests to proxy of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// Path is the URL path to use for the current proxy request to pod.
            /// </param>
            public static string ConnectPostNamespacedPodProxy(this IKubernetes operations, string name, string namespaceParameter, string path = default(string))
            {
                return operations.ConnectPostNamespacedPodProxyAsync(name, namespaceParameter, path).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect POST requests to proxy of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// Path is the URL path to use for the current proxy request to pod.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectPostNamespacedPodProxyAsync(this IKubernetes operations, string name, string namespaceParameter, string path = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectPostNamespacedPodProxyWithHttpMessagesAsync(name, namespaceParameter, path, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect DELETE requests to proxy of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// Path is the URL path to use for the current proxy request to pod.
            /// </param>
            public static string ConnectDeleteNamespacedPodProxy(this IKubernetes operations, string name, string namespaceParameter, string path = default(string))
            {
                return operations.ConnectDeleteNamespacedPodProxyAsync(name, namespaceParameter, path).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect DELETE requests to proxy of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// Path is the URL path to use for the current proxy request to pod.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectDeleteNamespacedPodProxyAsync(this IKubernetes operations, string name, string namespaceParameter, string path = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectDeleteNamespacedPodProxyWithHttpMessagesAsync(name, namespaceParameter, path, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect HEAD requests to proxy of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// Path is the URL path to use for the current proxy request to pod.
            /// </param>
            public static string ConnectHeadNamespacedPodProxy(this IKubernetes operations, string name, string namespaceParameter, string path = default(string))
            {
                return operations.ConnectHeadNamespacedPodProxyAsync(name, namespaceParameter, path).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect HEAD requests to proxy of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// Path is the URL path to use for the current proxy request to pod.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectHeadNamespacedPodProxyAsync(this IKubernetes operations, string name, string namespaceParameter, string path = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectHeadNamespacedPodProxyWithHttpMessagesAsync(name, namespaceParameter, path, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect PATCH requests to proxy of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// Path is the URL path to use for the current proxy request to pod.
            /// </param>
            public static string ConnectPatchNamespacedPodProxy(this IKubernetes operations, string name, string namespaceParameter, string path = default(string))
            {
                return operations.ConnectPatchNamespacedPodProxyAsync(name, namespaceParameter, path).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect PATCH requests to proxy of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// Path is the URL path to use for the current proxy request to pod.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectPatchNamespacedPodProxyAsync(this IKubernetes operations, string name, string namespaceParameter, string path = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectPatchNamespacedPodProxyWithHttpMessagesAsync(name, namespaceParameter, path, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect GET requests to proxy of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the URL path to use for the current proxy request to pod.
            /// </param>
            public static string ConnectGetNamespacedPodProxyWithPath(this IKubernetes operations, string name, string namespaceParameter, string path, string path1)
            {
                return operations.ConnectGetNamespacedPodProxyWithPathAsync(name, namespaceParameter, path, path1).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect GET requests to proxy of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the URL path to use for the current proxy request to pod.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectGetNamespacedPodProxyWithPathAsync(this IKubernetes operations, string name, string namespaceParameter, string path, string path1, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectGetNamespacedPodProxyWithPathWithHttpMessagesAsync(name, namespaceParameter, path, path1, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect PUT requests to proxy of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the URL path to use for the current proxy request to pod.
            /// </param>
            public static string ConnectPutNamespacedPodProxyWithPath(this IKubernetes operations, string name, string namespaceParameter, string path, string path1)
            {
                return operations.ConnectPutNamespacedPodProxyWithPathAsync(name, namespaceParameter, path, path1).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect PUT requests to proxy of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the URL path to use for the current proxy request to pod.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectPutNamespacedPodProxyWithPathAsync(this IKubernetes operations, string name, string namespaceParameter, string path, string path1, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectPutNamespacedPodProxyWithPathWithHttpMessagesAsync(name, namespaceParameter, path, path1, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect POST requests to proxy of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the URL path to use for the current proxy request to pod.
            /// </param>
            public static string ConnectPostNamespacedPodProxyWithPath(this IKubernetes operations, string name, string namespaceParameter, string path, string path1)
            {
                return operations.ConnectPostNamespacedPodProxyWithPathAsync(name, namespaceParameter, path, path1).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect POST requests to proxy of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the URL path to use for the current proxy request to pod.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectPostNamespacedPodProxyWithPathAsync(this IKubernetes operations, string name, string namespaceParameter, string path, string path1, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectPostNamespacedPodProxyWithPathWithHttpMessagesAsync(name, namespaceParameter, path, path1, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect DELETE requests to proxy of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the URL path to use for the current proxy request to pod.
            /// </param>
            public static string ConnectDeleteNamespacedPodProxyWithPath(this IKubernetes operations, string name, string namespaceParameter, string path, string path1)
            {
                return operations.ConnectDeleteNamespacedPodProxyWithPathAsync(name, namespaceParameter, path, path1).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect DELETE requests to proxy of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the URL path to use for the current proxy request to pod.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectDeleteNamespacedPodProxyWithPathAsync(this IKubernetes operations, string name, string namespaceParameter, string path, string path1, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectDeleteNamespacedPodProxyWithPathWithHttpMessagesAsync(name, namespaceParameter, path, path1, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect HEAD requests to proxy of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the URL path to use for the current proxy request to pod.
            /// </param>
            public static string ConnectHeadNamespacedPodProxyWithPath(this IKubernetes operations, string name, string namespaceParameter, string path, string path1)
            {
                return operations.ConnectHeadNamespacedPodProxyWithPathAsync(name, namespaceParameter, path, path1).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect HEAD requests to proxy of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the URL path to use for the current proxy request to pod.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectHeadNamespacedPodProxyWithPathAsync(this IKubernetes operations, string name, string namespaceParameter, string path, string path1, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectHeadNamespacedPodProxyWithPathWithHttpMessagesAsync(name, namespaceParameter, path, path1, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect PATCH requests to proxy of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the URL path to use for the current proxy request to pod.
            /// </param>
            public static string ConnectPatchNamespacedPodProxyWithPath(this IKubernetes operations, string name, string namespaceParameter, string path, string path1)
            {
                return operations.ConnectPatchNamespacedPodProxyWithPathAsync(name, namespaceParameter, path, path1).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect PATCH requests to proxy of Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the URL path to use for the current proxy request to pod.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectPatchNamespacedPodProxyWithPathAsync(this IKubernetes operations, string name, string namespaceParameter, string path, string path1, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectPatchNamespacedPodProxyWithPathWithHttpMessagesAsync(name, namespaceParameter, path, path1, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Pod
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Pod ReadNamespacedPodStatus(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedPodStatusAsync(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Pod
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Pod> ReadNamespacedPodStatusAsync(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedPodStatusWithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the specified Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Pod
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Pod ReplaceNamespacedPodStatus(this IKubernetes operations, V1Pod body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedPodStatusAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the specified Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Pod
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Pod> ReplaceNamespacedPodStatusAsync(this IKubernetes operations, V1Pod body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedPodStatusWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Pod
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Pod PatchNamespacedPodStatus(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedPodStatusAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Pod
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Pod> PatchNamespacedPodStatusAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedPodStatusWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind PodTemplate
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1PodTemplateList ListNamespacedPodTemplate(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedPodTemplateAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind PodTemplate
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1PodTemplateList> ListNamespacedPodTemplateAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedPodTemplateWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a PodTemplate
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1PodTemplate CreateNamespacedPodTemplate(this IKubernetes operations, V1PodTemplate body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedPodTemplateAsync(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a PodTemplate
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1PodTemplate> CreateNamespacedPodTemplateAsync(this IKubernetes operations, V1PodTemplate body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedPodTemplateWithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of PodTemplate
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedPodTemplate(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedPodTemplateAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of PodTemplate
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedPodTemplateAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedPodTemplateWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified PodTemplate
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodTemplate
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1PodTemplate ReadNamespacedPodTemplate(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedPodTemplateAsync(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified PodTemplate
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodTemplate
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1PodTemplate> ReadNamespacedPodTemplateAsync(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedPodTemplateWithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified PodTemplate
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PodTemplate
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1PodTemplate ReplaceNamespacedPodTemplate(this IKubernetes operations, V1PodTemplate body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedPodTemplateAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified PodTemplate
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PodTemplate
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1PodTemplate> ReplaceNamespacedPodTemplateAsync(this IKubernetes operations, V1PodTemplate body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedPodTemplateWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a PodTemplate
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PodTemplate
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedPodTemplate(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedPodTemplateAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a PodTemplate
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PodTemplate
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedPodTemplateAsync(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedPodTemplateWithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified PodTemplate
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PodTemplate
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1PodTemplate PatchNamespacedPodTemplate(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedPodTemplateAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified PodTemplate
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PodTemplate
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1PodTemplate> PatchNamespacedPodTemplateAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedPodTemplateWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind ReplicationController
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ReplicationControllerList ListNamespacedReplicationController(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedReplicationControllerAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind ReplicationController
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ReplicationControllerList> ListNamespacedReplicationControllerAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedReplicationControllerWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a ReplicationController
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ReplicationController CreateNamespacedReplicationController(this IKubernetes operations, V1ReplicationController body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedReplicationControllerAsync(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a ReplicationController
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ReplicationController> CreateNamespacedReplicationControllerAsync(this IKubernetes operations, V1ReplicationController body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedReplicationControllerWithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of ReplicationController
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedReplicationController(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedReplicationControllerAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of ReplicationController
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedReplicationControllerAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedReplicationControllerWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified ReplicationController
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ReplicationController
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ReplicationController ReadNamespacedReplicationController(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedReplicationControllerAsync(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified ReplicationController
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ReplicationController
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ReplicationController> ReadNamespacedReplicationControllerAsync(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedReplicationControllerWithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified ReplicationController
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicationController
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ReplicationController ReplaceNamespacedReplicationController(this IKubernetes operations, V1ReplicationController body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedReplicationControllerAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified ReplicationController
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicationController
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ReplicationController> ReplaceNamespacedReplicationControllerAsync(this IKubernetes operations, V1ReplicationController body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedReplicationControllerWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a ReplicationController
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicationController
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedReplicationController(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedReplicationControllerAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a ReplicationController
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicationController
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedReplicationControllerAsync(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedReplicationControllerWithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified ReplicationController
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicationController
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ReplicationController PatchNamespacedReplicationController(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedReplicationControllerAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified ReplicationController
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicationController
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ReplicationController> PatchNamespacedReplicationControllerAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedReplicationControllerWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read scale of the specified ReplicationController
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Scale ReadNamespacedReplicationControllerScale(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedReplicationControllerScaleAsync(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read scale of the specified ReplicationController
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Scale> ReadNamespacedReplicationControllerScaleAsync(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedReplicationControllerScaleWithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace scale of the specified ReplicationController
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Scale ReplaceNamespacedReplicationControllerScale(this IKubernetes operations, V1Scale body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedReplicationControllerScaleAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace scale of the specified ReplicationController
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Scale> ReplaceNamespacedReplicationControllerScaleAsync(this IKubernetes operations, V1Scale body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedReplicationControllerScaleWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update scale of the specified ReplicationController
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Scale PatchNamespacedReplicationControllerScale(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedReplicationControllerScaleAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update scale of the specified ReplicationController
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Scale> PatchNamespacedReplicationControllerScaleAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedReplicationControllerScaleWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified ReplicationController
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ReplicationController
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ReplicationController ReadNamespacedReplicationControllerStatus(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedReplicationControllerStatusAsync(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified ReplicationController
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ReplicationController
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ReplicationController> ReadNamespacedReplicationControllerStatusAsync(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedReplicationControllerStatusWithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the specified ReplicationController
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicationController
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ReplicationController ReplaceNamespacedReplicationControllerStatus(this IKubernetes operations, V1ReplicationController body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedReplicationControllerStatusAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the specified ReplicationController
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicationController
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ReplicationController> ReplaceNamespacedReplicationControllerStatusAsync(this IKubernetes operations, V1ReplicationController body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedReplicationControllerStatusWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified ReplicationController
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicationController
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ReplicationController PatchNamespacedReplicationControllerStatus(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedReplicationControllerStatusAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified ReplicationController
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicationController
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ReplicationController> PatchNamespacedReplicationControllerStatusAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedReplicationControllerStatusWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind ResourceQuota
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ResourceQuotaList ListNamespacedResourceQuota(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedResourceQuotaAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind ResourceQuota
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ResourceQuotaList> ListNamespacedResourceQuotaAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedResourceQuotaWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a ResourceQuota
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ResourceQuota CreateNamespacedResourceQuota(this IKubernetes operations, V1ResourceQuota body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedResourceQuotaAsync(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a ResourceQuota
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ResourceQuota> CreateNamespacedResourceQuotaAsync(this IKubernetes operations, V1ResourceQuota body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedResourceQuotaWithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of ResourceQuota
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedResourceQuota(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedResourceQuotaAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of ResourceQuota
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedResourceQuotaAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedResourceQuotaWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified ResourceQuota
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ResourceQuota
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ResourceQuota ReadNamespacedResourceQuota(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedResourceQuotaAsync(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified ResourceQuota
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ResourceQuota
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ResourceQuota> ReadNamespacedResourceQuotaAsync(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedResourceQuotaWithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified ResourceQuota
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ResourceQuota
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ResourceQuota ReplaceNamespacedResourceQuota(this IKubernetes operations, V1ResourceQuota body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedResourceQuotaAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified ResourceQuota
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ResourceQuota
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ResourceQuota> ReplaceNamespacedResourceQuotaAsync(this IKubernetes operations, V1ResourceQuota body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedResourceQuotaWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a ResourceQuota
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ResourceQuota
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedResourceQuota(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedResourceQuotaAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a ResourceQuota
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ResourceQuota
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedResourceQuotaAsync(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedResourceQuotaWithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified ResourceQuota
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ResourceQuota
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ResourceQuota PatchNamespacedResourceQuota(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedResourceQuotaAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified ResourceQuota
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ResourceQuota
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ResourceQuota> PatchNamespacedResourceQuotaAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedResourceQuotaWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified ResourceQuota
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ResourceQuota
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ResourceQuota ReadNamespacedResourceQuotaStatus(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedResourceQuotaStatusAsync(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified ResourceQuota
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ResourceQuota
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ResourceQuota> ReadNamespacedResourceQuotaStatusAsync(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedResourceQuotaStatusWithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the specified ResourceQuota
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ResourceQuota
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ResourceQuota ReplaceNamespacedResourceQuotaStatus(this IKubernetes operations, V1ResourceQuota body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedResourceQuotaStatusAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the specified ResourceQuota
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ResourceQuota
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ResourceQuota> ReplaceNamespacedResourceQuotaStatusAsync(this IKubernetes operations, V1ResourceQuota body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedResourceQuotaStatusWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified ResourceQuota
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ResourceQuota
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ResourceQuota PatchNamespacedResourceQuotaStatus(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedResourceQuotaStatusAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified ResourceQuota
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ResourceQuota
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ResourceQuota> PatchNamespacedResourceQuotaStatusAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedResourceQuotaStatusWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind Secret
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1SecretList ListNamespacedSecret(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedSecretAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind Secret
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1SecretList> ListNamespacedSecretAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedSecretWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a Secret
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Secret CreateNamespacedSecret(this IKubernetes operations, V1Secret body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedSecretAsync(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a Secret
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Secret> CreateNamespacedSecretAsync(this IKubernetes operations, V1Secret body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedSecretWithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of Secret
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedSecret(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedSecretAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of Secret
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedSecretAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedSecretWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified Secret
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Secret
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Secret ReadNamespacedSecret(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedSecretAsync(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified Secret
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Secret
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Secret> ReadNamespacedSecretAsync(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedSecretWithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified Secret
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Secret
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Secret ReplaceNamespacedSecret(this IKubernetes operations, V1Secret body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedSecretAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified Secret
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Secret
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Secret> ReplaceNamespacedSecretAsync(this IKubernetes operations, V1Secret body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedSecretWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a Secret
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Secret
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedSecret(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedSecretAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a Secret
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Secret
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedSecretAsync(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedSecretWithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified Secret
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Secret
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Secret PatchNamespacedSecret(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedSecretAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified Secret
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Secret
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Secret> PatchNamespacedSecretAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedSecretWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind ServiceAccount
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ServiceAccountList ListNamespacedServiceAccount(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedServiceAccountAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind ServiceAccount
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ServiceAccountList> ListNamespacedServiceAccountAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedServiceAccountWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a ServiceAccount
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ServiceAccount CreateNamespacedServiceAccount(this IKubernetes operations, V1ServiceAccount body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedServiceAccountAsync(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a ServiceAccount
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ServiceAccount> CreateNamespacedServiceAccountAsync(this IKubernetes operations, V1ServiceAccount body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedServiceAccountWithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of ServiceAccount
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedServiceAccount(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedServiceAccountAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of ServiceAccount
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedServiceAccountAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedServiceAccountWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified ServiceAccount
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ServiceAccount
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ServiceAccount ReadNamespacedServiceAccount(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedServiceAccountAsync(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified ServiceAccount
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ServiceAccount
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ServiceAccount> ReadNamespacedServiceAccountAsync(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedServiceAccountWithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified ServiceAccount
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ServiceAccount
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ServiceAccount ReplaceNamespacedServiceAccount(this IKubernetes operations, V1ServiceAccount body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedServiceAccountAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified ServiceAccount
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ServiceAccount
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ServiceAccount> ReplaceNamespacedServiceAccountAsync(this IKubernetes operations, V1ServiceAccount body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedServiceAccountWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a ServiceAccount
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ServiceAccount
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedServiceAccount(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedServiceAccountAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a ServiceAccount
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ServiceAccount
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedServiceAccountAsync(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedServiceAccountWithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified ServiceAccount
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ServiceAccount
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ServiceAccount PatchNamespacedServiceAccount(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedServiceAccountAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified ServiceAccount
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ServiceAccount
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ServiceAccount> PatchNamespacedServiceAccountAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedServiceAccountWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ServiceList ListNamespacedService(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedServiceAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ServiceList> ListNamespacedServiceAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedServiceWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Service CreateNamespacedService(this IKubernetes operations, V1Service body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedServiceAsync(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Service> CreateNamespacedServiceAsync(this IKubernetes operations, V1Service body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedServiceWithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Service
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Service ReadNamespacedService(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedServiceAsync(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Service
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Service> ReadNamespacedServiceAsync(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedServiceWithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Service
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Service ReplaceNamespacedService(this IKubernetes operations, V1Service body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedServiceAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Service
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Service> ReplaceNamespacedServiceAsync(this IKubernetes operations, V1Service body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedServiceWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Service
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedService(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedServiceAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Service
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedServiceAsync(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedServiceWithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Service
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Service PatchNamespacedService(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedServiceAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Service
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Service> PatchNamespacedServiceAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedServiceWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect GET requests to proxy of Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ServiceProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// Path is the part of URLs that include service endpoints, suffixes, and
            /// parameters to use for the current proxy request to service. For example,
            /// the whole request URL is
            /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
            /// Path is _search?q=user:kimchy.
            /// </param>
            public static string ConnectGetNamespacedServiceProxy(this IKubernetes operations, string name, string namespaceParameter, string path = default(string))
            {
                return operations.ConnectGetNamespacedServiceProxyAsync(name, namespaceParameter, path).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect GET requests to proxy of Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ServiceProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// Path is the part of URLs that include service endpoints, suffixes, and
            /// parameters to use for the current proxy request to service. For example,
            /// the whole request URL is
            /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
            /// Path is _search?q=user:kimchy.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectGetNamespacedServiceProxyAsync(this IKubernetes operations, string name, string namespaceParameter, string path = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectGetNamespacedServiceProxyWithHttpMessagesAsync(name, namespaceParameter, path, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect PUT requests to proxy of Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ServiceProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// Path is the part of URLs that include service endpoints, suffixes, and
            /// parameters to use for the current proxy request to service. For example,
            /// the whole request URL is
            /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
            /// Path is _search?q=user:kimchy.
            /// </param>
            public static string ConnectPutNamespacedServiceProxy(this IKubernetes operations, string name, string namespaceParameter, string path = default(string))
            {
                return operations.ConnectPutNamespacedServiceProxyAsync(name, namespaceParameter, path).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect PUT requests to proxy of Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ServiceProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// Path is the part of URLs that include service endpoints, suffixes, and
            /// parameters to use for the current proxy request to service. For example,
            /// the whole request URL is
            /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
            /// Path is _search?q=user:kimchy.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectPutNamespacedServiceProxyAsync(this IKubernetes operations, string name, string namespaceParameter, string path = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectPutNamespacedServiceProxyWithHttpMessagesAsync(name, namespaceParameter, path, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect POST requests to proxy of Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ServiceProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// Path is the part of URLs that include service endpoints, suffixes, and
            /// parameters to use for the current proxy request to service. For example,
            /// the whole request URL is
            /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
            /// Path is _search?q=user:kimchy.
            /// </param>
            public static string ConnectPostNamespacedServiceProxy(this IKubernetes operations, string name, string namespaceParameter, string path = default(string))
            {
                return operations.ConnectPostNamespacedServiceProxyAsync(name, namespaceParameter, path).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect POST requests to proxy of Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ServiceProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// Path is the part of URLs that include service endpoints, suffixes, and
            /// parameters to use for the current proxy request to service. For example,
            /// the whole request URL is
            /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
            /// Path is _search?q=user:kimchy.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectPostNamespacedServiceProxyAsync(this IKubernetes operations, string name, string namespaceParameter, string path = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectPostNamespacedServiceProxyWithHttpMessagesAsync(name, namespaceParameter, path, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect DELETE requests to proxy of Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ServiceProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// Path is the part of URLs that include service endpoints, suffixes, and
            /// parameters to use for the current proxy request to service. For example,
            /// the whole request URL is
            /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
            /// Path is _search?q=user:kimchy.
            /// </param>
            public static string ConnectDeleteNamespacedServiceProxy(this IKubernetes operations, string name, string namespaceParameter, string path = default(string))
            {
                return operations.ConnectDeleteNamespacedServiceProxyAsync(name, namespaceParameter, path).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect DELETE requests to proxy of Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ServiceProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// Path is the part of URLs that include service endpoints, suffixes, and
            /// parameters to use for the current proxy request to service. For example,
            /// the whole request URL is
            /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
            /// Path is _search?q=user:kimchy.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectDeleteNamespacedServiceProxyAsync(this IKubernetes operations, string name, string namespaceParameter, string path = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectDeleteNamespacedServiceProxyWithHttpMessagesAsync(name, namespaceParameter, path, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect HEAD requests to proxy of Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ServiceProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// Path is the part of URLs that include service endpoints, suffixes, and
            /// parameters to use for the current proxy request to service. For example,
            /// the whole request URL is
            /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
            /// Path is _search?q=user:kimchy.
            /// </param>
            public static string ConnectHeadNamespacedServiceProxy(this IKubernetes operations, string name, string namespaceParameter, string path = default(string))
            {
                return operations.ConnectHeadNamespacedServiceProxyAsync(name, namespaceParameter, path).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect HEAD requests to proxy of Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ServiceProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// Path is the part of URLs that include service endpoints, suffixes, and
            /// parameters to use for the current proxy request to service. For example,
            /// the whole request URL is
            /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
            /// Path is _search?q=user:kimchy.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectHeadNamespacedServiceProxyAsync(this IKubernetes operations, string name, string namespaceParameter, string path = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectHeadNamespacedServiceProxyWithHttpMessagesAsync(name, namespaceParameter, path, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect PATCH requests to proxy of Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ServiceProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// Path is the part of URLs that include service endpoints, suffixes, and
            /// parameters to use for the current proxy request to service. For example,
            /// the whole request URL is
            /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
            /// Path is _search?q=user:kimchy.
            /// </param>
            public static string ConnectPatchNamespacedServiceProxy(this IKubernetes operations, string name, string namespaceParameter, string path = default(string))
            {
                return operations.ConnectPatchNamespacedServiceProxyAsync(name, namespaceParameter, path).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect PATCH requests to proxy of Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ServiceProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// Path is the part of URLs that include service endpoints, suffixes, and
            /// parameters to use for the current proxy request to service. For example,
            /// the whole request URL is
            /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
            /// Path is _search?q=user:kimchy.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectPatchNamespacedServiceProxyAsync(this IKubernetes operations, string name, string namespaceParameter, string path = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectPatchNamespacedServiceProxyWithHttpMessagesAsync(name, namespaceParameter, path, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect GET requests to proxy of Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ServiceProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the part of URLs that include service endpoints, suffixes, and
            /// parameters to use for the current proxy request to service. For example,
            /// the whole request URL is
            /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
            /// Path is _search?q=user:kimchy.
            /// </param>
            public static string ConnectGetNamespacedServiceProxyWithPath(this IKubernetes operations, string name, string namespaceParameter, string path, string path1)
            {
                return operations.ConnectGetNamespacedServiceProxyWithPathAsync(name, namespaceParameter, path, path1).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect GET requests to proxy of Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ServiceProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the part of URLs that include service endpoints, suffixes, and
            /// parameters to use for the current proxy request to service. For example,
            /// the whole request URL is
            /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
            /// Path is _search?q=user:kimchy.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectGetNamespacedServiceProxyWithPathAsync(this IKubernetes operations, string name, string namespaceParameter, string path, string path1, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectGetNamespacedServiceProxyWithPathWithHttpMessagesAsync(name, namespaceParameter, path, path1, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect PUT requests to proxy of Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ServiceProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the part of URLs that include service endpoints, suffixes, and
            /// parameters to use for the current proxy request to service. For example,
            /// the whole request URL is
            /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
            /// Path is _search?q=user:kimchy.
            /// </param>
            public static string ConnectPutNamespacedServiceProxyWithPath(this IKubernetes operations, string name, string namespaceParameter, string path, string path1)
            {
                return operations.ConnectPutNamespacedServiceProxyWithPathAsync(name, namespaceParameter, path, path1).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect PUT requests to proxy of Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ServiceProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the part of URLs that include service endpoints, suffixes, and
            /// parameters to use for the current proxy request to service. For example,
            /// the whole request URL is
            /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
            /// Path is _search?q=user:kimchy.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectPutNamespacedServiceProxyWithPathAsync(this IKubernetes operations, string name, string namespaceParameter, string path, string path1, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectPutNamespacedServiceProxyWithPathWithHttpMessagesAsync(name, namespaceParameter, path, path1, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect POST requests to proxy of Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ServiceProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the part of URLs that include service endpoints, suffixes, and
            /// parameters to use for the current proxy request to service. For example,
            /// the whole request URL is
            /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
            /// Path is _search?q=user:kimchy.
            /// </param>
            public static string ConnectPostNamespacedServiceProxyWithPath(this IKubernetes operations, string name, string namespaceParameter, string path, string path1)
            {
                return operations.ConnectPostNamespacedServiceProxyWithPathAsync(name, namespaceParameter, path, path1).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect POST requests to proxy of Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ServiceProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the part of URLs that include service endpoints, suffixes, and
            /// parameters to use for the current proxy request to service. For example,
            /// the whole request URL is
            /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
            /// Path is _search?q=user:kimchy.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectPostNamespacedServiceProxyWithPathAsync(this IKubernetes operations, string name, string namespaceParameter, string path, string path1, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectPostNamespacedServiceProxyWithPathWithHttpMessagesAsync(name, namespaceParameter, path, path1, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect DELETE requests to proxy of Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ServiceProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the part of URLs that include service endpoints, suffixes, and
            /// parameters to use for the current proxy request to service. For example,
            /// the whole request URL is
            /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
            /// Path is _search?q=user:kimchy.
            /// </param>
            public static string ConnectDeleteNamespacedServiceProxyWithPath(this IKubernetes operations, string name, string namespaceParameter, string path, string path1)
            {
                return operations.ConnectDeleteNamespacedServiceProxyWithPathAsync(name, namespaceParameter, path, path1).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect DELETE requests to proxy of Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ServiceProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the part of URLs that include service endpoints, suffixes, and
            /// parameters to use for the current proxy request to service. For example,
            /// the whole request URL is
            /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
            /// Path is _search?q=user:kimchy.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectDeleteNamespacedServiceProxyWithPathAsync(this IKubernetes operations, string name, string namespaceParameter, string path, string path1, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectDeleteNamespacedServiceProxyWithPathWithHttpMessagesAsync(name, namespaceParameter, path, path1, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect HEAD requests to proxy of Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ServiceProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the part of URLs that include service endpoints, suffixes, and
            /// parameters to use for the current proxy request to service. For example,
            /// the whole request URL is
            /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
            /// Path is _search?q=user:kimchy.
            /// </param>
            public static string ConnectHeadNamespacedServiceProxyWithPath(this IKubernetes operations, string name, string namespaceParameter, string path, string path1)
            {
                return operations.ConnectHeadNamespacedServiceProxyWithPathAsync(name, namespaceParameter, path, path1).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect HEAD requests to proxy of Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ServiceProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the part of URLs that include service endpoints, suffixes, and
            /// parameters to use for the current proxy request to service. For example,
            /// the whole request URL is
            /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
            /// Path is _search?q=user:kimchy.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectHeadNamespacedServiceProxyWithPathAsync(this IKubernetes operations, string name, string namespaceParameter, string path, string path1, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectHeadNamespacedServiceProxyWithPathWithHttpMessagesAsync(name, namespaceParameter, path, path1, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect PATCH requests to proxy of Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ServiceProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the part of URLs that include service endpoints, suffixes, and
            /// parameters to use for the current proxy request to service. For example,
            /// the whole request URL is
            /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
            /// Path is _search?q=user:kimchy.
            /// </param>
            public static string ConnectPatchNamespacedServiceProxyWithPath(this IKubernetes operations, string name, string namespaceParameter, string path, string path1)
            {
                return operations.ConnectPatchNamespacedServiceProxyWithPathAsync(name, namespaceParameter, path, path1).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect PATCH requests to proxy of Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ServiceProxyOptions
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the part of URLs that include service endpoints, suffixes, and
            /// parameters to use for the current proxy request to service. For example,
            /// the whole request URL is
            /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
            /// Path is _search?q=user:kimchy.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectPatchNamespacedServiceProxyWithPathAsync(this IKubernetes operations, string name, string namespaceParameter, string path, string path1, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectPatchNamespacedServiceProxyWithPathWithHttpMessagesAsync(name, namespaceParameter, path, path1, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Service
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Service ReadNamespacedServiceStatus(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedServiceStatusAsync(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Service
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Service> ReadNamespacedServiceStatusAsync(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedServiceStatusWithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the specified Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Service
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Service ReplaceNamespacedServiceStatus(this IKubernetes operations, V1Service body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedServiceStatusAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the specified Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Service
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Service> ReplaceNamespacedServiceStatusAsync(this IKubernetes operations, V1Service body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedServiceStatusWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Service
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Service PatchNamespacedServiceStatus(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedServiceStatusAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Service
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Service> PatchNamespacedServiceStatusAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedServiceStatusWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified Namespace
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Namespace
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Namespace ReadNamespace(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespaceAsync(name, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified Namespace
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Namespace
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Namespace> ReadNamespaceAsync(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespaceWithHttpMessagesAsync(name, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified Namespace
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Namespace
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Namespace ReplaceNamespace(this IKubernetes operations, V1Namespace body, string name, string pretty = default(string))
            {
                return operations.ReplaceNamespaceAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified Namespace
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Namespace
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Namespace> ReplaceNamespaceAsync(this IKubernetes operations, V1Namespace body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespaceWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a Namespace
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Namespace
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespace(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespaceAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a Namespace
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Namespace
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespaceAsync(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespaceWithHttpMessagesAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified Namespace
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Namespace
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Namespace PatchNamespace(this IKubernetes operations, V1Patch body, string name, string pretty = default(string))
            {
                return operations.PatchNamespaceAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified Namespace
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Namespace
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Namespace> PatchNamespaceAsync(this IKubernetes operations, V1Patch body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespaceWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace finalize of the specified Namespace
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Namespace
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Namespace ReplaceNamespaceFinalize(this IKubernetes operations, V1Namespace body, string name, string pretty = default(string))
            {
                return operations.ReplaceNamespaceFinalizeAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace finalize of the specified Namespace
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Namespace
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Namespace> ReplaceNamespaceFinalizeAsync(this IKubernetes operations, V1Namespace body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespaceFinalizeWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified Namespace
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Namespace
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Namespace ReadNamespaceStatus(this IKubernetes operations, string name, string pretty = default(string))
            {
                return operations.ReadNamespaceStatusAsync(name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified Namespace
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Namespace
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Namespace> ReadNamespaceStatusAsync(this IKubernetes operations, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespaceStatusWithHttpMessagesAsync(name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the specified Namespace
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Namespace
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Namespace ReplaceNamespaceStatus(this IKubernetes operations, V1Namespace body, string name, string pretty = default(string))
            {
                return operations.ReplaceNamespaceStatusAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the specified Namespace
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Namespace
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Namespace> ReplaceNamespaceStatusAsync(this IKubernetes operations, V1Namespace body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespaceStatusWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified Namespace
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Namespace
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Namespace PatchNamespaceStatus(this IKubernetes operations, V1Patch body, string name, string pretty = default(string))
            {
                return operations.PatchNamespaceStatusAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified Namespace
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Namespace
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Namespace> PatchNamespaceStatusAsync(this IKubernetes operations, V1Patch body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespaceStatusWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1NodeList ListNode(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNodeAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1NodeList> ListNodeAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNodeWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Node CreateNode(this IKubernetes operations, V1Node body, string pretty = default(string))
            {
                return operations.CreateNodeAsync(body, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Node> CreateNodeAsync(this IKubernetes operations, V1Node body, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNodeWithHttpMessagesAsync(body, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNode(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNodeAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNodeAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNodeWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Node
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Node ReadNode(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNodeAsync(name, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Node
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Node> ReadNodeAsync(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNodeWithHttpMessagesAsync(name, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Node
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Node ReplaceNode(this IKubernetes operations, V1Node body, string name, string pretty = default(string))
            {
                return operations.ReplaceNodeAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Node
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Node> ReplaceNodeAsync(this IKubernetes operations, V1Node body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNodeWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Node
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNode(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNodeAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Node
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNodeAsync(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNodeWithHttpMessagesAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Node
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Node PatchNode(this IKubernetes operations, V1Patch body, string name, string pretty = default(string))
            {
                return operations.PatchNodeAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Node
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Node> PatchNodeAsync(this IKubernetes operations, V1Patch body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNodeWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect GET requests to proxy of Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the NodeProxyOptions
            /// </param>
            /// <param name='path'>
            /// Path is the URL path to use for the current proxy request to node.
            /// </param>
            public static string ConnectGetNodeProxy(this IKubernetes operations, string name, string path = default(string))
            {
                return operations.ConnectGetNodeProxyAsync(name, path).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect GET requests to proxy of Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the NodeProxyOptions
            /// </param>
            /// <param name='path'>
            /// Path is the URL path to use for the current proxy request to node.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectGetNodeProxyAsync(this IKubernetes operations, string name, string path = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectGetNodeProxyWithHttpMessagesAsync(name, path, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect PUT requests to proxy of Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the NodeProxyOptions
            /// </param>
            /// <param name='path'>
            /// Path is the URL path to use for the current proxy request to node.
            /// </param>
            public static string ConnectPutNodeProxy(this IKubernetes operations, string name, string path = default(string))
            {
                return operations.ConnectPutNodeProxyAsync(name, path).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect PUT requests to proxy of Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the NodeProxyOptions
            /// </param>
            /// <param name='path'>
            /// Path is the URL path to use for the current proxy request to node.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectPutNodeProxyAsync(this IKubernetes operations, string name, string path = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectPutNodeProxyWithHttpMessagesAsync(name, path, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect POST requests to proxy of Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the NodeProxyOptions
            /// </param>
            /// <param name='path'>
            /// Path is the URL path to use for the current proxy request to node.
            /// </param>
            public static string ConnectPostNodeProxy(this IKubernetes operations, string name, string path = default(string))
            {
                return operations.ConnectPostNodeProxyAsync(name, path).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect POST requests to proxy of Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the NodeProxyOptions
            /// </param>
            /// <param name='path'>
            /// Path is the URL path to use for the current proxy request to node.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectPostNodeProxyAsync(this IKubernetes operations, string name, string path = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectPostNodeProxyWithHttpMessagesAsync(name, path, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect DELETE requests to proxy of Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the NodeProxyOptions
            /// </param>
            /// <param name='path'>
            /// Path is the URL path to use for the current proxy request to node.
            /// </param>
            public static string ConnectDeleteNodeProxy(this IKubernetes operations, string name, string path = default(string))
            {
                return operations.ConnectDeleteNodeProxyAsync(name, path).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect DELETE requests to proxy of Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the NodeProxyOptions
            /// </param>
            /// <param name='path'>
            /// Path is the URL path to use for the current proxy request to node.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectDeleteNodeProxyAsync(this IKubernetes operations, string name, string path = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectDeleteNodeProxyWithHttpMessagesAsync(name, path, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect HEAD requests to proxy of Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the NodeProxyOptions
            /// </param>
            /// <param name='path'>
            /// Path is the URL path to use for the current proxy request to node.
            /// </param>
            public static string ConnectHeadNodeProxy(this IKubernetes operations, string name, string path = default(string))
            {
                return operations.ConnectHeadNodeProxyAsync(name, path).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect HEAD requests to proxy of Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the NodeProxyOptions
            /// </param>
            /// <param name='path'>
            /// Path is the URL path to use for the current proxy request to node.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectHeadNodeProxyAsync(this IKubernetes operations, string name, string path = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectHeadNodeProxyWithHttpMessagesAsync(name, path, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect PATCH requests to proxy of Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the NodeProxyOptions
            /// </param>
            /// <param name='path'>
            /// Path is the URL path to use for the current proxy request to node.
            /// </param>
            public static string ConnectPatchNodeProxy(this IKubernetes operations, string name, string path = default(string))
            {
                return operations.ConnectPatchNodeProxyAsync(name, path).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect PATCH requests to proxy of Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the NodeProxyOptions
            /// </param>
            /// <param name='path'>
            /// Path is the URL path to use for the current proxy request to node.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectPatchNodeProxyAsync(this IKubernetes operations, string name, string path = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectPatchNodeProxyWithHttpMessagesAsync(name, path, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect GET requests to proxy of Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the NodeProxyOptions
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the URL path to use for the current proxy request to node.
            /// </param>
            public static string ConnectGetNodeProxyWithPath(this IKubernetes operations, string name, string path, string path1)
            {
                return operations.ConnectGetNodeProxyWithPathAsync(name, path, path1).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect GET requests to proxy of Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the NodeProxyOptions
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the URL path to use for the current proxy request to node.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectGetNodeProxyWithPathAsync(this IKubernetes operations, string name, string path, string path1, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectGetNodeProxyWithPathWithHttpMessagesAsync(name, path, path1, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect PUT requests to proxy of Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the NodeProxyOptions
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the URL path to use for the current proxy request to node.
            /// </param>
            public static string ConnectPutNodeProxyWithPath(this IKubernetes operations, string name, string path, string path1)
            {
                return operations.ConnectPutNodeProxyWithPathAsync(name, path, path1).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect PUT requests to proxy of Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the NodeProxyOptions
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the URL path to use for the current proxy request to node.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectPutNodeProxyWithPathAsync(this IKubernetes operations, string name, string path, string path1, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectPutNodeProxyWithPathWithHttpMessagesAsync(name, path, path1, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect POST requests to proxy of Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the NodeProxyOptions
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the URL path to use for the current proxy request to node.
            /// </param>
            public static string ConnectPostNodeProxyWithPath(this IKubernetes operations, string name, string path, string path1)
            {
                return operations.ConnectPostNodeProxyWithPathAsync(name, path, path1).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect POST requests to proxy of Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the NodeProxyOptions
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the URL path to use for the current proxy request to node.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectPostNodeProxyWithPathAsync(this IKubernetes operations, string name, string path, string path1, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectPostNodeProxyWithPathWithHttpMessagesAsync(name, path, path1, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect DELETE requests to proxy of Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the NodeProxyOptions
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the URL path to use for the current proxy request to node.
            /// </param>
            public static string ConnectDeleteNodeProxyWithPath(this IKubernetes operations, string name, string path, string path1)
            {
                return operations.ConnectDeleteNodeProxyWithPathAsync(name, path, path1).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect DELETE requests to proxy of Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the NodeProxyOptions
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the URL path to use for the current proxy request to node.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectDeleteNodeProxyWithPathAsync(this IKubernetes operations, string name, string path, string path1, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectDeleteNodeProxyWithPathWithHttpMessagesAsync(name, path, path1, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect HEAD requests to proxy of Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the NodeProxyOptions
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the URL path to use for the current proxy request to node.
            /// </param>
            public static string ConnectHeadNodeProxyWithPath(this IKubernetes operations, string name, string path, string path1)
            {
                return operations.ConnectHeadNodeProxyWithPathAsync(name, path, path1).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect HEAD requests to proxy of Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the NodeProxyOptions
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the URL path to use for the current proxy request to node.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectHeadNodeProxyWithPathAsync(this IKubernetes operations, string name, string path, string path1, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectHeadNodeProxyWithPathWithHttpMessagesAsync(name, path, path1, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// connect PATCH requests to proxy of Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the NodeProxyOptions
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the URL path to use for the current proxy request to node.
            /// </param>
            public static string ConnectPatchNodeProxyWithPath(this IKubernetes operations, string name, string path, string path1)
            {
                return operations.ConnectPatchNodeProxyWithPathAsync(name, path, path1).GetAwaiter().GetResult();
            }

            /// <summary>
            /// connect PATCH requests to proxy of Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the NodeProxyOptions
            /// </param>
            /// <param name='path'>
            /// path to the resource
            /// </param>
            /// <param name='path1'>
            /// Path is the URL path to use for the current proxy request to node.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<string> ConnectPatchNodeProxyWithPathAsync(this IKubernetes operations, string name, string path, string path1, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ConnectPatchNodeProxyWithPathWithHttpMessagesAsync(name, path, path1, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Node
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Node ReadNodeStatus(this IKubernetes operations, string name, string pretty = default(string))
            {
                return operations.ReadNodeStatusAsync(name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Node
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Node> ReadNodeStatusAsync(this IKubernetes operations, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNodeStatusWithHttpMessagesAsync(name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the specified Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Node
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Node ReplaceNodeStatus(this IKubernetes operations, V1Node body, string name, string pretty = default(string))
            {
                return operations.ReplaceNodeStatusAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the specified Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Node
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Node> ReplaceNodeStatusAsync(this IKubernetes operations, V1Node body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNodeStatusWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Node
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Node PatchNodeStatus(this IKubernetes operations, V1Patch body, string name, string pretty = default(string))
            {
                return operations.PatchNodeStatusAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified Node
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Node
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Node> PatchNodeStatusAsync(this IKubernetes operations, V1Patch body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNodeStatusWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind PersistentVolumeClaim
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1PersistentVolumeClaimList ListPersistentVolumeClaimForAllNamespaces(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListPersistentVolumeClaimForAllNamespacesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind PersistentVolumeClaim
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1PersistentVolumeClaimList> ListPersistentVolumeClaimForAllNamespacesAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListPersistentVolumeClaimForAllNamespacesWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind PersistentVolume
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1PersistentVolumeList ListPersistentVolume(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListPersistentVolumeAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind PersistentVolume
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1PersistentVolumeList> ListPersistentVolumeAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListPersistentVolumeWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a PersistentVolume
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1PersistentVolume CreatePersistentVolume(this IKubernetes operations, V1PersistentVolume body, string pretty = default(string))
            {
                return operations.CreatePersistentVolumeAsync(body, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a PersistentVolume
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1PersistentVolume> CreatePersistentVolumeAsync(this IKubernetes operations, V1PersistentVolume body, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreatePersistentVolumeWithHttpMessagesAsync(body, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of PersistentVolume
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionPersistentVolume(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionPersistentVolumeAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of PersistentVolume
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionPersistentVolumeAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionPersistentVolumeWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified PersistentVolume
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PersistentVolume
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1PersistentVolume ReadPersistentVolume(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadPersistentVolumeAsync(name, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified PersistentVolume
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PersistentVolume
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1PersistentVolume> ReadPersistentVolumeAsync(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadPersistentVolumeWithHttpMessagesAsync(name, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified PersistentVolume
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PersistentVolume
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1PersistentVolume ReplacePersistentVolume(this IKubernetes operations, V1PersistentVolume body, string name, string pretty = default(string))
            {
                return operations.ReplacePersistentVolumeAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified PersistentVolume
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PersistentVolume
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1PersistentVolume> ReplacePersistentVolumeAsync(this IKubernetes operations, V1PersistentVolume body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplacePersistentVolumeWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a PersistentVolume
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PersistentVolume
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeletePersistentVolume(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeletePersistentVolumeAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a PersistentVolume
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PersistentVolume
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeletePersistentVolumeAsync(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeletePersistentVolumeWithHttpMessagesAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified PersistentVolume
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PersistentVolume
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1PersistentVolume PatchPersistentVolume(this IKubernetes operations, V1Patch body, string name, string pretty = default(string))
            {
                return operations.PatchPersistentVolumeAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified PersistentVolume
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PersistentVolume
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1PersistentVolume> PatchPersistentVolumeAsync(this IKubernetes operations, V1Patch body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchPersistentVolumeWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified PersistentVolume
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PersistentVolume
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1PersistentVolume ReadPersistentVolumeStatus(this IKubernetes operations, string name, string pretty = default(string))
            {
                return operations.ReadPersistentVolumeStatusAsync(name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified PersistentVolume
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PersistentVolume
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1PersistentVolume> ReadPersistentVolumeStatusAsync(this IKubernetes operations, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadPersistentVolumeStatusWithHttpMessagesAsync(name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the specified PersistentVolume
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PersistentVolume
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1PersistentVolume ReplacePersistentVolumeStatus(this IKubernetes operations, V1PersistentVolume body, string name, string pretty = default(string))
            {
                return operations.ReplacePersistentVolumeStatusAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the specified PersistentVolume
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PersistentVolume
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1PersistentVolume> ReplacePersistentVolumeStatusAsync(this IKubernetes operations, V1PersistentVolume body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplacePersistentVolumeStatusWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified PersistentVolume
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PersistentVolume
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1PersistentVolume PatchPersistentVolumeStatus(this IKubernetes operations, V1Patch body, string name, string pretty = default(string))
            {
                return operations.PatchPersistentVolumeStatusAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified PersistentVolume
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PersistentVolume
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1PersistentVolume> PatchPersistentVolumeStatusAsync(this IKubernetes operations, V1Patch body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchPersistentVolumeStatusWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1PodList ListPodForAllNamespaces(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListPodForAllNamespacesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind Pod
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1PodList> ListPodForAllNamespacesAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListPodForAllNamespacesWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind PodTemplate
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1PodTemplateList ListPodTemplateForAllNamespaces(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListPodTemplateForAllNamespacesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind PodTemplate
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1PodTemplateList> ListPodTemplateForAllNamespacesAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListPodTemplateForAllNamespacesWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind ReplicationController
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1ReplicationControllerList ListReplicationControllerForAllNamespaces(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListReplicationControllerForAllNamespacesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind ReplicationController
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ReplicationControllerList> ListReplicationControllerForAllNamespacesAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListReplicationControllerForAllNamespacesWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind ResourceQuota
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1ResourceQuotaList ListResourceQuotaForAllNamespaces(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListResourceQuotaForAllNamespacesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind ResourceQuota
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ResourceQuotaList> ListResourceQuotaForAllNamespacesAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListResourceQuotaForAllNamespacesWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind Secret
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1SecretList ListSecretForAllNamespaces(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListSecretForAllNamespacesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind Secret
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1SecretList> ListSecretForAllNamespacesAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListSecretForAllNamespacesWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind ServiceAccount
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1ServiceAccountList ListServiceAccountForAllNamespaces(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListServiceAccountForAllNamespacesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind ServiceAccount
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ServiceAccountList> ListServiceAccountForAllNamespacesAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListServiceAccountForAllNamespacesWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1ServiceList ListServiceForAllNamespaces(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListServiceForAllNamespacesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind Service
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ServiceList> ListServiceForAllNamespacesAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListServiceForAllNamespacesWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available API versions
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIGroupList GetAPIVersions1(this IKubernetes operations)
            {
                return operations.GetAPIVersions1Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available API versions
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIGroupList> GetAPIVersions1Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIVersions1WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIGroup GetAPIGroup(this IKubernetes operations)
            {
                return operations.GetAPIGroupAsync().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIGroup> GetAPIGroupAsync(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIGroupWithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIResourceList GetAPIResources1(this IKubernetes operations)
            {
                return operations.GetAPIResources1Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIResourceList> GetAPIResources1Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIResources1WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind InitializerConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1InitializerConfigurationList ListInitializerConfiguration(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListInitializerConfigurationAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind InitializerConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1InitializerConfigurationList> ListInitializerConfigurationAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListInitializerConfigurationWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create an InitializerConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1InitializerConfiguration CreateInitializerConfiguration(this IKubernetes operations, V1alpha1InitializerConfiguration body, string pretty = default(string))
            {
                return operations.CreateInitializerConfigurationAsync(body, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create an InitializerConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1InitializerConfiguration> CreateInitializerConfigurationAsync(this IKubernetes operations, V1alpha1InitializerConfiguration body, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateInitializerConfigurationWithHttpMessagesAsync(body, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of InitializerConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionInitializerConfiguration(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionInitializerConfigurationAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of InitializerConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionInitializerConfigurationAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionInitializerConfigurationWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified InitializerConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the InitializerConfiguration
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1InitializerConfiguration ReadInitializerConfiguration(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadInitializerConfigurationAsync(name, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified InitializerConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the InitializerConfiguration
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1InitializerConfiguration> ReadInitializerConfigurationAsync(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadInitializerConfigurationWithHttpMessagesAsync(name, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified InitializerConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the InitializerConfiguration
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1InitializerConfiguration ReplaceInitializerConfiguration(this IKubernetes operations, V1alpha1InitializerConfiguration body, string name, string pretty = default(string))
            {
                return operations.ReplaceInitializerConfigurationAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified InitializerConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the InitializerConfiguration
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1InitializerConfiguration> ReplaceInitializerConfigurationAsync(this IKubernetes operations, V1alpha1InitializerConfiguration body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceInitializerConfigurationWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete an InitializerConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the InitializerConfiguration
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteInitializerConfiguration(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteInitializerConfigurationAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete an InitializerConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the InitializerConfiguration
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteInitializerConfigurationAsync(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteInitializerConfigurationWithHttpMessagesAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified InitializerConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the InitializerConfiguration
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1InitializerConfiguration PatchInitializerConfiguration(this IKubernetes operations, V1Patch body, string name, string pretty = default(string))
            {
                return operations.PatchInitializerConfigurationAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified InitializerConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the InitializerConfiguration
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1InitializerConfiguration> PatchInitializerConfigurationAsync(this IKubernetes operations, V1Patch body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchInitializerConfigurationWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIResourceList GetAPIResources2(this IKubernetes operations)
            {
                return operations.GetAPIResources2Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIResourceList> GetAPIResources2Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIResources2WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind MutatingWebhookConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1MutatingWebhookConfigurationList ListMutatingWebhookConfiguration(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListMutatingWebhookConfigurationAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind MutatingWebhookConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1MutatingWebhookConfigurationList> ListMutatingWebhookConfigurationAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListMutatingWebhookConfigurationWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a MutatingWebhookConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1MutatingWebhookConfiguration CreateMutatingWebhookConfiguration(this IKubernetes operations, V1beta1MutatingWebhookConfiguration body, string pretty = default(string))
            {
                return operations.CreateMutatingWebhookConfigurationAsync(body, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a MutatingWebhookConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1MutatingWebhookConfiguration> CreateMutatingWebhookConfigurationAsync(this IKubernetes operations, V1beta1MutatingWebhookConfiguration body, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateMutatingWebhookConfigurationWithHttpMessagesAsync(body, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of MutatingWebhookConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionMutatingWebhookConfiguration(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionMutatingWebhookConfigurationAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of MutatingWebhookConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionMutatingWebhookConfigurationAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionMutatingWebhookConfigurationWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified MutatingWebhookConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the MutatingWebhookConfiguration
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1MutatingWebhookConfiguration ReadMutatingWebhookConfiguration(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadMutatingWebhookConfigurationAsync(name, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified MutatingWebhookConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the MutatingWebhookConfiguration
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1MutatingWebhookConfiguration> ReadMutatingWebhookConfigurationAsync(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadMutatingWebhookConfigurationWithHttpMessagesAsync(name, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified MutatingWebhookConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the MutatingWebhookConfiguration
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1MutatingWebhookConfiguration ReplaceMutatingWebhookConfiguration(this IKubernetes operations, V1beta1MutatingWebhookConfiguration body, string name, string pretty = default(string))
            {
                return operations.ReplaceMutatingWebhookConfigurationAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified MutatingWebhookConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the MutatingWebhookConfiguration
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1MutatingWebhookConfiguration> ReplaceMutatingWebhookConfigurationAsync(this IKubernetes operations, V1beta1MutatingWebhookConfiguration body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceMutatingWebhookConfigurationWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a MutatingWebhookConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the MutatingWebhookConfiguration
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteMutatingWebhookConfiguration(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteMutatingWebhookConfigurationAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a MutatingWebhookConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the MutatingWebhookConfiguration
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteMutatingWebhookConfigurationAsync(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteMutatingWebhookConfigurationWithHttpMessagesAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified MutatingWebhookConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the MutatingWebhookConfiguration
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1MutatingWebhookConfiguration PatchMutatingWebhookConfiguration(this IKubernetes operations, V1Patch body, string name, string pretty = default(string))
            {
                return operations.PatchMutatingWebhookConfigurationAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified MutatingWebhookConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the MutatingWebhookConfiguration
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1MutatingWebhookConfiguration> PatchMutatingWebhookConfigurationAsync(this IKubernetes operations, V1Patch body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchMutatingWebhookConfigurationWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind ValidatingWebhookConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1ValidatingWebhookConfigurationList ListValidatingWebhookConfiguration(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListValidatingWebhookConfigurationAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind ValidatingWebhookConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1ValidatingWebhookConfigurationList> ListValidatingWebhookConfigurationAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListValidatingWebhookConfigurationWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a ValidatingWebhookConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1ValidatingWebhookConfiguration CreateValidatingWebhookConfiguration(this IKubernetes operations, V1beta1ValidatingWebhookConfiguration body, string pretty = default(string))
            {
                return operations.CreateValidatingWebhookConfigurationAsync(body, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a ValidatingWebhookConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1ValidatingWebhookConfiguration> CreateValidatingWebhookConfigurationAsync(this IKubernetes operations, V1beta1ValidatingWebhookConfiguration body, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateValidatingWebhookConfigurationWithHttpMessagesAsync(body, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of ValidatingWebhookConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionValidatingWebhookConfiguration(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionValidatingWebhookConfigurationAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of ValidatingWebhookConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionValidatingWebhookConfigurationAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionValidatingWebhookConfigurationWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified ValidatingWebhookConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ValidatingWebhookConfiguration
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1ValidatingWebhookConfiguration ReadValidatingWebhookConfiguration(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadValidatingWebhookConfigurationAsync(name, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified ValidatingWebhookConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ValidatingWebhookConfiguration
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1ValidatingWebhookConfiguration> ReadValidatingWebhookConfigurationAsync(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadValidatingWebhookConfigurationWithHttpMessagesAsync(name, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified ValidatingWebhookConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ValidatingWebhookConfiguration
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1ValidatingWebhookConfiguration ReplaceValidatingWebhookConfiguration(this IKubernetes operations, V1beta1ValidatingWebhookConfiguration body, string name, string pretty = default(string))
            {
                return operations.ReplaceValidatingWebhookConfigurationAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified ValidatingWebhookConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ValidatingWebhookConfiguration
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1ValidatingWebhookConfiguration> ReplaceValidatingWebhookConfigurationAsync(this IKubernetes operations, V1beta1ValidatingWebhookConfiguration body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceValidatingWebhookConfigurationWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a ValidatingWebhookConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ValidatingWebhookConfiguration
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteValidatingWebhookConfiguration(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteValidatingWebhookConfigurationAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a ValidatingWebhookConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ValidatingWebhookConfiguration
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteValidatingWebhookConfigurationAsync(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteValidatingWebhookConfigurationWithHttpMessagesAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified ValidatingWebhookConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ValidatingWebhookConfiguration
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1ValidatingWebhookConfiguration PatchValidatingWebhookConfiguration(this IKubernetes operations, V1Patch body, string name, string pretty = default(string))
            {
                return operations.PatchValidatingWebhookConfigurationAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified ValidatingWebhookConfiguration
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ValidatingWebhookConfiguration
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1ValidatingWebhookConfiguration> PatchValidatingWebhookConfigurationAsync(this IKubernetes operations, V1Patch body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchValidatingWebhookConfigurationWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIGroup GetAPIGroup1(this IKubernetes operations)
            {
                return operations.GetAPIGroup1Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIGroup> GetAPIGroup1Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIGroup1WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIResourceList GetAPIResources3(this IKubernetes operations)
            {
                return operations.GetAPIResources3Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIResourceList> GetAPIResources3Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIResources3WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind CustomResourceDefinition
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1CustomResourceDefinitionList ListCustomResourceDefinition(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListCustomResourceDefinitionAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind CustomResourceDefinition
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1CustomResourceDefinitionList> ListCustomResourceDefinitionAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListCustomResourceDefinitionWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a CustomResourceDefinition
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1CustomResourceDefinition CreateCustomResourceDefinition(this IKubernetes operations, V1beta1CustomResourceDefinition body, string pretty = default(string))
            {
                return operations.CreateCustomResourceDefinitionAsync(body, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a CustomResourceDefinition
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1CustomResourceDefinition> CreateCustomResourceDefinitionAsync(this IKubernetes operations, V1beta1CustomResourceDefinition body, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateCustomResourceDefinitionWithHttpMessagesAsync(body, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of CustomResourceDefinition
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionCustomResourceDefinition(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionCustomResourceDefinitionAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of CustomResourceDefinition
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionCustomResourceDefinitionAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionCustomResourceDefinitionWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified CustomResourceDefinition
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the CustomResourceDefinition
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1CustomResourceDefinition ReadCustomResourceDefinition(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadCustomResourceDefinitionAsync(name, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified CustomResourceDefinition
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the CustomResourceDefinition
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1CustomResourceDefinition> ReadCustomResourceDefinitionAsync(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadCustomResourceDefinitionWithHttpMessagesAsync(name, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified CustomResourceDefinition
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CustomResourceDefinition
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1CustomResourceDefinition ReplaceCustomResourceDefinition(this IKubernetes operations, V1beta1CustomResourceDefinition body, string name, string pretty = default(string))
            {
                return operations.ReplaceCustomResourceDefinitionAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified CustomResourceDefinition
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CustomResourceDefinition
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1CustomResourceDefinition> ReplaceCustomResourceDefinitionAsync(this IKubernetes operations, V1beta1CustomResourceDefinition body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceCustomResourceDefinitionWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a CustomResourceDefinition
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CustomResourceDefinition
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCustomResourceDefinition(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteCustomResourceDefinitionAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a CustomResourceDefinition
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CustomResourceDefinition
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCustomResourceDefinitionAsync(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCustomResourceDefinitionWithHttpMessagesAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified CustomResourceDefinition
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CustomResourceDefinition
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1CustomResourceDefinition PatchCustomResourceDefinition(this IKubernetes operations, V1Patch body, string name, string pretty = default(string))
            {
                return operations.PatchCustomResourceDefinitionAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified CustomResourceDefinition
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CustomResourceDefinition
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1CustomResourceDefinition> PatchCustomResourceDefinitionAsync(this IKubernetes operations, V1Patch body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchCustomResourceDefinitionWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified CustomResourceDefinition
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the CustomResourceDefinition
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1CustomResourceDefinition ReadCustomResourceDefinitionStatus(this IKubernetes operations, string name, string pretty = default(string))
            {
                return operations.ReadCustomResourceDefinitionStatusAsync(name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified CustomResourceDefinition
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the CustomResourceDefinition
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1CustomResourceDefinition> ReadCustomResourceDefinitionStatusAsync(this IKubernetes operations, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadCustomResourceDefinitionStatusWithHttpMessagesAsync(name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the specified CustomResourceDefinition
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CustomResourceDefinition
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1CustomResourceDefinition ReplaceCustomResourceDefinitionStatus(this IKubernetes operations, V1beta1CustomResourceDefinition body, string name, string pretty = default(string))
            {
                return operations.ReplaceCustomResourceDefinitionStatusAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the specified CustomResourceDefinition
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CustomResourceDefinition
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1CustomResourceDefinition> ReplaceCustomResourceDefinitionStatusAsync(this IKubernetes operations, V1beta1CustomResourceDefinition body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceCustomResourceDefinitionStatusWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified CustomResourceDefinition
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CustomResourceDefinition
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1CustomResourceDefinition PatchCustomResourceDefinitionStatus(this IKubernetes operations, V1Patch body, string name, string pretty = default(string))
            {
                return operations.PatchCustomResourceDefinitionStatusAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified CustomResourceDefinition
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CustomResourceDefinition
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1CustomResourceDefinition> PatchCustomResourceDefinitionStatusAsync(this IKubernetes operations, V1Patch body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchCustomResourceDefinitionStatusWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIGroup GetAPIGroup2(this IKubernetes operations)
            {
                return operations.GetAPIGroup2Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIGroup> GetAPIGroup2Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIGroup2WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIResourceList GetAPIResources4(this IKubernetes operations)
            {
                return operations.GetAPIResources4Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIResourceList> GetAPIResources4Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIResources4WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1APIServiceList ListAPIService(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListAPIServiceAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIServiceList> ListAPIServiceAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListAPIServiceWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create an APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1APIService CreateAPIService(this IKubernetes operations, V1APIService body, string pretty = default(string))
            {
                return operations.CreateAPIServiceAsync(body, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create an APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIService> CreateAPIServiceAsync(this IKubernetes operations, V1APIService body, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateAPIServiceWithHttpMessagesAsync(body, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionAPIService(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionAPIServiceAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionAPIServiceAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionAPIServiceWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the APIService
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1APIService ReadAPIService(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadAPIServiceAsync(name, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the APIService
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIService> ReadAPIServiceAsync(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadAPIServiceWithHttpMessagesAsync(name, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the APIService
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1APIService ReplaceAPIService(this IKubernetes operations, V1APIService body, string name, string pretty = default(string))
            {
                return operations.ReplaceAPIServiceAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the APIService
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIService> ReplaceAPIServiceAsync(this IKubernetes operations, V1APIService body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceAPIServiceWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete an APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the APIService
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteAPIService(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteAPIServiceAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete an APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the APIService
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteAPIServiceAsync(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteAPIServiceWithHttpMessagesAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the APIService
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1APIService PatchAPIService(this IKubernetes operations, V1Patch body, string name, string pretty = default(string))
            {
                return operations.PatchAPIServiceAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the APIService
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIService> PatchAPIServiceAsync(this IKubernetes operations, V1Patch body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchAPIServiceWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the APIService
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1APIService ReadAPIServiceStatus(this IKubernetes operations, string name, string pretty = default(string))
            {
                return operations.ReadAPIServiceStatusAsync(name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the APIService
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIService> ReadAPIServiceStatusAsync(this IKubernetes operations, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadAPIServiceStatusWithHttpMessagesAsync(name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the specified APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the APIService
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1APIService ReplaceAPIServiceStatus(this IKubernetes operations, V1APIService body, string name, string pretty = default(string))
            {
                return operations.ReplaceAPIServiceStatusAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the specified APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the APIService
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIService> ReplaceAPIServiceStatusAsync(this IKubernetes operations, V1APIService body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceAPIServiceStatusWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the APIService
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1APIService PatchAPIServiceStatus(this IKubernetes operations, V1Patch body, string name, string pretty = default(string))
            {
                return operations.PatchAPIServiceStatusAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the APIService
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIService> PatchAPIServiceStatusAsync(this IKubernetes operations, V1Patch body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchAPIServiceStatusWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIResourceList GetAPIResources5(this IKubernetes operations)
            {
                return operations.GetAPIResources5Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIResourceList> GetAPIResources5Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIResources5WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1APIServiceList ListAPIService1(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListAPIService1Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1APIServiceList> ListAPIService1Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListAPIService1WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create an APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1APIService CreateAPIService1(this IKubernetes operations, V1beta1APIService body, string pretty = default(string))
            {
                return operations.CreateAPIService1Async(body, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create an APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1APIService> CreateAPIService1Async(this IKubernetes operations, V1beta1APIService body, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateAPIService1WithHttpMessagesAsync(body, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionAPIService1(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionAPIService1Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionAPIService1Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionAPIService1WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the APIService
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1APIService ReadAPIService1(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadAPIService1Async(name, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the APIService
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1APIService> ReadAPIService1Async(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadAPIService1WithHttpMessagesAsync(name, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the APIService
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1APIService ReplaceAPIService1(this IKubernetes operations, V1beta1APIService body, string name, string pretty = default(string))
            {
                return operations.ReplaceAPIService1Async(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the APIService
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1APIService> ReplaceAPIService1Async(this IKubernetes operations, V1beta1APIService body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceAPIService1WithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete an APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the APIService
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteAPIService1(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteAPIService1Async(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete an APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the APIService
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteAPIService1Async(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteAPIService1WithHttpMessagesAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the APIService
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1APIService PatchAPIService1(this IKubernetes operations, V1Patch body, string name, string pretty = default(string))
            {
                return operations.PatchAPIService1Async(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the APIService
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1APIService> PatchAPIService1Async(this IKubernetes operations, V1Patch body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchAPIService1WithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the APIService
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1APIService ReadAPIServiceStatus1(this IKubernetes operations, string name, string pretty = default(string))
            {
                return operations.ReadAPIServiceStatus1Async(name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the APIService
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1APIService> ReadAPIServiceStatus1Async(this IKubernetes operations, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadAPIServiceStatus1WithHttpMessagesAsync(name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the specified APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the APIService
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1APIService ReplaceAPIServiceStatus1(this IKubernetes operations, V1beta1APIService body, string name, string pretty = default(string))
            {
                return operations.ReplaceAPIServiceStatus1Async(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the specified APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the APIService
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1APIService> ReplaceAPIServiceStatus1Async(this IKubernetes operations, V1beta1APIService body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceAPIServiceStatus1WithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the APIService
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1APIService PatchAPIServiceStatus1(this IKubernetes operations, V1Patch body, string name, string pretty = default(string))
            {
                return operations.PatchAPIServiceStatus1Async(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified APIService
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the APIService
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1APIService> PatchAPIServiceStatus1Async(this IKubernetes operations, V1Patch body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchAPIServiceStatus1WithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIGroup GetAPIGroup3(this IKubernetes operations)
            {
                return operations.GetAPIGroup3Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIGroup> GetAPIGroup3Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIGroup3WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIResourceList GetAPIResources6(this IKubernetes operations)
            {
                return operations.GetAPIResources6Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIResourceList> GetAPIResources6Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIResources6WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1ControllerRevisionList ListControllerRevisionForAllNamespaces(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListControllerRevisionForAllNamespacesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ControllerRevisionList> ListControllerRevisionForAllNamespacesAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListControllerRevisionForAllNamespacesWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1DaemonSetList ListDaemonSetForAllNamespaces(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListDaemonSetForAllNamespacesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1DaemonSetList> ListDaemonSetForAllNamespacesAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListDaemonSetForAllNamespacesWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1DeploymentList ListDeploymentForAllNamespaces(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListDeploymentForAllNamespacesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1DeploymentList> ListDeploymentForAllNamespacesAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListDeploymentForAllNamespacesWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ControllerRevisionList ListNamespacedControllerRevision(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedControllerRevisionAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ControllerRevisionList> ListNamespacedControllerRevisionAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedControllerRevisionWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ControllerRevision CreateNamespacedControllerRevision(this IKubernetes operations, V1ControllerRevision body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedControllerRevisionAsync(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ControllerRevision> CreateNamespacedControllerRevisionAsync(this IKubernetes operations, V1ControllerRevision body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedControllerRevisionWithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedControllerRevision(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedControllerRevisionAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedControllerRevisionAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedControllerRevisionWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ControllerRevision
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ControllerRevision ReadNamespacedControllerRevision(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedControllerRevisionAsync(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ControllerRevision
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ControllerRevision> ReadNamespacedControllerRevisionAsync(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedControllerRevisionWithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ControllerRevision
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ControllerRevision ReplaceNamespacedControllerRevision(this IKubernetes operations, V1ControllerRevision body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedControllerRevisionAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ControllerRevision
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ControllerRevision> ReplaceNamespacedControllerRevisionAsync(this IKubernetes operations, V1ControllerRevision body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedControllerRevisionWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ControllerRevision
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedControllerRevision(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedControllerRevisionAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ControllerRevision
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedControllerRevisionAsync(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedControllerRevisionWithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ControllerRevision
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ControllerRevision PatchNamespacedControllerRevision(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedControllerRevisionAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ControllerRevision
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ControllerRevision> PatchNamespacedControllerRevisionAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedControllerRevisionWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1DaemonSetList ListNamespacedDaemonSet(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedDaemonSetAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1DaemonSetList> ListNamespacedDaemonSetAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedDaemonSetWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1DaemonSet CreateNamespacedDaemonSet(this IKubernetes operations, V1DaemonSet body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedDaemonSetAsync(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1DaemonSet> CreateNamespacedDaemonSetAsync(this IKubernetes operations, V1DaemonSet body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedDaemonSetWithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedDaemonSet(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedDaemonSetAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedDaemonSetAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedDaemonSetWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1DaemonSet ReadNamespacedDaemonSet(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedDaemonSetAsync(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1DaemonSet> ReadNamespacedDaemonSetAsync(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedDaemonSetWithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1DaemonSet ReplaceNamespacedDaemonSet(this IKubernetes operations, V1DaemonSet body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedDaemonSetAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1DaemonSet> ReplaceNamespacedDaemonSetAsync(this IKubernetes operations, V1DaemonSet body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedDaemonSetWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedDaemonSet(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedDaemonSetAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedDaemonSetAsync(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedDaemonSetWithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1DaemonSet PatchNamespacedDaemonSet(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedDaemonSetAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1DaemonSet> PatchNamespacedDaemonSetAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedDaemonSetWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1DaemonSet ReadNamespacedDaemonSetStatus(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedDaemonSetStatusAsync(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1DaemonSet> ReadNamespacedDaemonSetStatusAsync(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedDaemonSetStatusWithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1DaemonSet ReplaceNamespacedDaemonSetStatus(this IKubernetes operations, V1DaemonSet body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedDaemonSetStatusAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1DaemonSet> ReplaceNamespacedDaemonSetStatusAsync(this IKubernetes operations, V1DaemonSet body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedDaemonSetStatusWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1DaemonSet PatchNamespacedDaemonSetStatus(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedDaemonSetStatusAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1DaemonSet> PatchNamespacedDaemonSetStatusAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedDaemonSetStatusWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1DeploymentList ListNamespacedDeployment(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedDeploymentAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1DeploymentList> ListNamespacedDeploymentAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedDeploymentWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Deployment CreateNamespacedDeployment(this IKubernetes operations, V1Deployment body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedDeploymentAsync(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Deployment> CreateNamespacedDeploymentAsync(this IKubernetes operations, V1Deployment body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedDeploymentWithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedDeployment(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedDeploymentAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedDeploymentAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedDeploymentWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Deployment ReadNamespacedDeployment(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedDeploymentAsync(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Deployment> ReadNamespacedDeploymentAsync(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedDeploymentWithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Deployment ReplaceNamespacedDeployment(this IKubernetes operations, V1Deployment body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedDeploymentAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Deployment> ReplaceNamespacedDeploymentAsync(this IKubernetes operations, V1Deployment body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedDeploymentWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedDeployment(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedDeploymentAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedDeploymentAsync(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedDeploymentWithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Deployment PatchNamespacedDeployment(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedDeploymentAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Deployment> PatchNamespacedDeploymentAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedDeploymentWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read scale of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Scale ReadNamespacedDeploymentScale(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedDeploymentScaleAsync(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read scale of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Scale> ReadNamespacedDeploymentScaleAsync(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedDeploymentScaleWithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace scale of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Scale ReplaceNamespacedDeploymentScale(this IKubernetes operations, V1Scale body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedDeploymentScaleAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace scale of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Scale> ReplaceNamespacedDeploymentScaleAsync(this IKubernetes operations, V1Scale body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedDeploymentScaleWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update scale of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Scale PatchNamespacedDeploymentScale(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedDeploymentScaleAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update scale of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Scale> PatchNamespacedDeploymentScaleAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedDeploymentScaleWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Deployment ReadNamespacedDeploymentStatus(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedDeploymentStatusAsync(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Deployment> ReadNamespacedDeploymentStatusAsync(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedDeploymentStatusWithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Deployment ReplaceNamespacedDeploymentStatus(this IKubernetes operations, V1Deployment body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedDeploymentStatusAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Deployment> ReplaceNamespacedDeploymentStatusAsync(this IKubernetes operations, V1Deployment body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedDeploymentStatusWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Deployment PatchNamespacedDeploymentStatus(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedDeploymentStatusAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Deployment> PatchNamespacedDeploymentStatusAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedDeploymentStatusWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ReplicaSetList ListNamespacedReplicaSet(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedReplicaSetAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ReplicaSetList> ListNamespacedReplicaSetAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedReplicaSetWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ReplicaSet CreateNamespacedReplicaSet(this IKubernetes operations, V1ReplicaSet body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedReplicaSetAsync(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ReplicaSet> CreateNamespacedReplicaSetAsync(this IKubernetes operations, V1ReplicaSet body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedReplicaSetWithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedReplicaSet(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedReplicaSetAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedReplicaSetAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedReplicaSetWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ReplicaSet ReadNamespacedReplicaSet(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedReplicaSetAsync(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ReplicaSet> ReadNamespacedReplicaSetAsync(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedReplicaSetWithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ReplicaSet ReplaceNamespacedReplicaSet(this IKubernetes operations, V1ReplicaSet body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedReplicaSetAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ReplicaSet> ReplaceNamespacedReplicaSetAsync(this IKubernetes operations, V1ReplicaSet body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedReplicaSetWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedReplicaSet(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedReplicaSetAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedReplicaSetAsync(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedReplicaSetWithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ReplicaSet PatchNamespacedReplicaSet(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedReplicaSetAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ReplicaSet> PatchNamespacedReplicaSetAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedReplicaSetWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read scale of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Scale ReadNamespacedReplicaSetScale(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedReplicaSetScaleAsync(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read scale of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Scale> ReadNamespacedReplicaSetScaleAsync(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedReplicaSetScaleWithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace scale of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Scale ReplaceNamespacedReplicaSetScale(this IKubernetes operations, V1Scale body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedReplicaSetScaleAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace scale of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Scale> ReplaceNamespacedReplicaSetScaleAsync(this IKubernetes operations, V1Scale body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedReplicaSetScaleWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update scale of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Scale PatchNamespacedReplicaSetScale(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedReplicaSetScaleAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update scale of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Scale> PatchNamespacedReplicaSetScaleAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedReplicaSetScaleWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ReplicaSet ReadNamespacedReplicaSetStatus(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedReplicaSetStatusAsync(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ReplicaSet> ReadNamespacedReplicaSetStatusAsync(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedReplicaSetStatusWithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ReplicaSet ReplaceNamespacedReplicaSetStatus(this IKubernetes operations, V1ReplicaSet body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedReplicaSetStatusAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ReplicaSet> ReplaceNamespacedReplicaSetStatusAsync(this IKubernetes operations, V1ReplicaSet body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedReplicaSetStatusWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ReplicaSet PatchNamespacedReplicaSetStatus(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedReplicaSetStatusAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ReplicaSet> PatchNamespacedReplicaSetStatusAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedReplicaSetStatusWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1StatefulSetList ListNamespacedStatefulSet(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedStatefulSetAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1StatefulSetList> ListNamespacedStatefulSetAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedStatefulSetWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1StatefulSet CreateNamespacedStatefulSet(this IKubernetes operations, V1StatefulSet body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedStatefulSetAsync(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1StatefulSet> CreateNamespacedStatefulSetAsync(this IKubernetes operations, V1StatefulSet body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedStatefulSetWithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedStatefulSet(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedStatefulSetAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedStatefulSetAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedStatefulSetWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1StatefulSet ReadNamespacedStatefulSet(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedStatefulSetAsync(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1StatefulSet> ReadNamespacedStatefulSetAsync(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedStatefulSetWithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1StatefulSet ReplaceNamespacedStatefulSet(this IKubernetes operations, V1StatefulSet body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedStatefulSetAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1StatefulSet> ReplaceNamespacedStatefulSetAsync(this IKubernetes operations, V1StatefulSet body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedStatefulSetWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedStatefulSet(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedStatefulSetAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedStatefulSetAsync(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedStatefulSetWithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1StatefulSet PatchNamespacedStatefulSet(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedStatefulSetAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1StatefulSet> PatchNamespacedStatefulSetAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedStatefulSetWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read scale of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Scale ReadNamespacedStatefulSetScale(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedStatefulSetScaleAsync(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read scale of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Scale> ReadNamespacedStatefulSetScaleAsync(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedStatefulSetScaleWithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace scale of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Scale ReplaceNamespacedStatefulSetScale(this IKubernetes operations, V1Scale body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedStatefulSetScaleAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace scale of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Scale> ReplaceNamespacedStatefulSetScaleAsync(this IKubernetes operations, V1Scale body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedStatefulSetScaleWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update scale of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Scale PatchNamespacedStatefulSetScale(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedStatefulSetScaleAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update scale of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Scale> PatchNamespacedStatefulSetScaleAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedStatefulSetScaleWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1StatefulSet ReadNamespacedStatefulSetStatus(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedStatefulSetStatusAsync(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1StatefulSet> ReadNamespacedStatefulSetStatusAsync(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedStatefulSetStatusWithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1StatefulSet ReplaceNamespacedStatefulSetStatus(this IKubernetes operations, V1StatefulSet body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedStatefulSetStatusAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1StatefulSet> ReplaceNamespacedStatefulSetStatusAsync(this IKubernetes operations, V1StatefulSet body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedStatefulSetStatusWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1StatefulSet PatchNamespacedStatefulSetStatus(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedStatefulSetStatusAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1StatefulSet> PatchNamespacedStatefulSetStatusAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedStatefulSetStatusWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1ReplicaSetList ListReplicaSetForAllNamespaces(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListReplicaSetForAllNamespacesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ReplicaSetList> ListReplicaSetForAllNamespacesAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListReplicaSetForAllNamespacesWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1StatefulSetList ListStatefulSetForAllNamespaces(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListStatefulSetForAllNamespacesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1StatefulSetList> ListStatefulSetForAllNamespacesAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListStatefulSetForAllNamespacesWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIResourceList GetAPIResources7(this IKubernetes operations)
            {
                return operations.GetAPIResources7Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIResourceList> GetAPIResources7Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIResources7WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1beta1ControllerRevisionList ListControllerRevisionForAllNamespaces1(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListControllerRevisionForAllNamespaces1Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1ControllerRevisionList> ListControllerRevisionForAllNamespaces1Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListControllerRevisionForAllNamespaces1WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static Appsv1beta1DeploymentList ListDeploymentForAllNamespaces1(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListDeploymentForAllNamespaces1Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Appsv1beta1DeploymentList> ListDeploymentForAllNamespaces1Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListDeploymentForAllNamespaces1WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1ControllerRevisionList ListNamespacedControllerRevision1(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedControllerRevision1Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1ControllerRevisionList> ListNamespacedControllerRevision1Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedControllerRevision1WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1ControllerRevision CreateNamespacedControllerRevision1(this IKubernetes operations, V1beta1ControllerRevision body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedControllerRevision1Async(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1ControllerRevision> CreateNamespacedControllerRevision1Async(this IKubernetes operations, V1beta1ControllerRevision body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedControllerRevision1WithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedControllerRevision1(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedControllerRevision1Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedControllerRevision1Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedControllerRevision1WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ControllerRevision
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1ControllerRevision ReadNamespacedControllerRevision1(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedControllerRevision1Async(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ControllerRevision
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1ControllerRevision> ReadNamespacedControllerRevision1Async(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedControllerRevision1WithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ControllerRevision
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1ControllerRevision ReplaceNamespacedControllerRevision1(this IKubernetes operations, V1beta1ControllerRevision body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedControllerRevision1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ControllerRevision
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1ControllerRevision> ReplaceNamespacedControllerRevision1Async(this IKubernetes operations, V1beta1ControllerRevision body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedControllerRevision1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ControllerRevision
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedControllerRevision1(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedControllerRevision1Async(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ControllerRevision
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedControllerRevision1Async(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedControllerRevision1WithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ControllerRevision
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1ControllerRevision PatchNamespacedControllerRevision1(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedControllerRevision1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ControllerRevision
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1ControllerRevision> PatchNamespacedControllerRevision1Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedControllerRevision1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Appsv1beta1DeploymentList ListNamespacedDeployment1(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedDeployment1Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Appsv1beta1DeploymentList> ListNamespacedDeployment1Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedDeployment1WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Appsv1beta1Deployment CreateNamespacedDeployment1(this IKubernetes operations, Appsv1beta1Deployment body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedDeployment1Async(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Appsv1beta1Deployment> CreateNamespacedDeployment1Async(this IKubernetes operations, Appsv1beta1Deployment body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedDeployment1WithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedDeployment1(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedDeployment1Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedDeployment1Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedDeployment1WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Appsv1beta1Deployment ReadNamespacedDeployment1(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedDeployment1Async(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Appsv1beta1Deployment> ReadNamespacedDeployment1Async(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedDeployment1WithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Appsv1beta1Deployment ReplaceNamespacedDeployment1(this IKubernetes operations, Appsv1beta1Deployment body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedDeployment1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Appsv1beta1Deployment> ReplaceNamespacedDeployment1Async(this IKubernetes operations, Appsv1beta1Deployment body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedDeployment1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedDeployment1(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedDeployment1Async(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedDeployment1Async(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedDeployment1WithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Appsv1beta1Deployment PatchNamespacedDeployment1(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedDeployment1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Appsv1beta1Deployment> PatchNamespacedDeployment1Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedDeployment1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create rollback of a Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the DeploymentRollback
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Appsv1beta1DeploymentStatus CreateNamespacedDeploymentRollback(this IKubernetes operations, Appsv1beta1DeploymentRollback body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedDeploymentRollbackAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create rollback of a Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the DeploymentRollback
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Appsv1beta1DeploymentStatus> CreateNamespacedDeploymentRollbackAsync(this IKubernetes operations, Appsv1beta1DeploymentRollback body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedDeploymentRollbackWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read scale of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Appsv1beta1Scale ReadNamespacedDeploymentScale1(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedDeploymentScale1Async(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read scale of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Appsv1beta1Scale> ReadNamespacedDeploymentScale1Async(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedDeploymentScale1WithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace scale of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Appsv1beta1Scale ReplaceNamespacedDeploymentScale1(this IKubernetes operations, Appsv1beta1Scale body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedDeploymentScale1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace scale of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Appsv1beta1Scale> ReplaceNamespacedDeploymentScale1Async(this IKubernetes operations, Appsv1beta1Scale body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedDeploymentScale1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update scale of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Appsv1beta1Scale PatchNamespacedDeploymentScale1(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedDeploymentScale1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update scale of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Appsv1beta1Scale> PatchNamespacedDeploymentScale1Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedDeploymentScale1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Appsv1beta1Deployment ReadNamespacedDeploymentStatus1(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedDeploymentStatus1Async(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Appsv1beta1Deployment> ReadNamespacedDeploymentStatus1Async(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedDeploymentStatus1WithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Appsv1beta1Deployment ReplaceNamespacedDeploymentStatus1(this IKubernetes operations, Appsv1beta1Deployment body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedDeploymentStatus1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Appsv1beta1Deployment> ReplaceNamespacedDeploymentStatus1Async(this IKubernetes operations, Appsv1beta1Deployment body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedDeploymentStatus1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Appsv1beta1Deployment PatchNamespacedDeploymentStatus1(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedDeploymentStatus1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Appsv1beta1Deployment> PatchNamespacedDeploymentStatus1Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedDeploymentStatus1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1StatefulSetList ListNamespacedStatefulSet1(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedStatefulSet1Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1StatefulSetList> ListNamespacedStatefulSet1Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedStatefulSet1WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1StatefulSet CreateNamespacedStatefulSet1(this IKubernetes operations, V1beta1StatefulSet body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedStatefulSet1Async(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1StatefulSet> CreateNamespacedStatefulSet1Async(this IKubernetes operations, V1beta1StatefulSet body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedStatefulSet1WithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedStatefulSet1(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedStatefulSet1Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedStatefulSet1Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedStatefulSet1WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1StatefulSet ReadNamespacedStatefulSet1(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedStatefulSet1Async(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1StatefulSet> ReadNamespacedStatefulSet1Async(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedStatefulSet1WithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1StatefulSet ReplaceNamespacedStatefulSet1(this IKubernetes operations, V1beta1StatefulSet body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedStatefulSet1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1StatefulSet> ReplaceNamespacedStatefulSet1Async(this IKubernetes operations, V1beta1StatefulSet body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedStatefulSet1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedStatefulSet1(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedStatefulSet1Async(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedStatefulSet1Async(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedStatefulSet1WithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1StatefulSet PatchNamespacedStatefulSet1(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedStatefulSet1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1StatefulSet> PatchNamespacedStatefulSet1Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedStatefulSet1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read scale of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Appsv1beta1Scale ReadNamespacedStatefulSetScale1(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedStatefulSetScale1Async(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read scale of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Appsv1beta1Scale> ReadNamespacedStatefulSetScale1Async(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedStatefulSetScale1WithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace scale of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Appsv1beta1Scale ReplaceNamespacedStatefulSetScale1(this IKubernetes operations, Appsv1beta1Scale body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedStatefulSetScale1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace scale of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Appsv1beta1Scale> ReplaceNamespacedStatefulSetScale1Async(this IKubernetes operations, Appsv1beta1Scale body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedStatefulSetScale1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update scale of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Appsv1beta1Scale PatchNamespacedStatefulSetScale1(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedStatefulSetScale1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update scale of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Appsv1beta1Scale> PatchNamespacedStatefulSetScale1Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedStatefulSetScale1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1StatefulSet ReadNamespacedStatefulSetStatus1(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedStatefulSetStatus1Async(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1StatefulSet> ReadNamespacedStatefulSetStatus1Async(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedStatefulSetStatus1WithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1StatefulSet ReplaceNamespacedStatefulSetStatus1(this IKubernetes operations, V1beta1StatefulSet body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedStatefulSetStatus1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1StatefulSet> ReplaceNamespacedStatefulSetStatus1Async(this IKubernetes operations, V1beta1StatefulSet body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedStatefulSetStatus1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1StatefulSet PatchNamespacedStatefulSetStatus1(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedStatefulSetStatus1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1StatefulSet> PatchNamespacedStatefulSetStatus1Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedStatefulSetStatus1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1beta1StatefulSetList ListStatefulSetForAllNamespaces1(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListStatefulSetForAllNamespaces1Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1StatefulSetList> ListStatefulSetForAllNamespaces1Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListStatefulSetForAllNamespaces1WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIResourceList GetAPIResources8(this IKubernetes operations)
            {
                return operations.GetAPIResources8Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIResourceList> GetAPIResources8Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIResources8WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1beta2ControllerRevisionList ListControllerRevisionForAllNamespaces2(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListControllerRevisionForAllNamespaces2Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2ControllerRevisionList> ListControllerRevisionForAllNamespaces2Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListControllerRevisionForAllNamespaces2WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1beta2DaemonSetList ListDaemonSetForAllNamespaces1(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListDaemonSetForAllNamespaces1Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2DaemonSetList> ListDaemonSetForAllNamespaces1Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListDaemonSetForAllNamespaces1WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1beta2DeploymentList ListDeploymentForAllNamespaces2(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListDeploymentForAllNamespaces2Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2DeploymentList> ListDeploymentForAllNamespaces2Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListDeploymentForAllNamespaces2WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2ControllerRevisionList ListNamespacedControllerRevision2(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedControllerRevision2Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2ControllerRevisionList> ListNamespacedControllerRevision2Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedControllerRevision2WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2ControllerRevision CreateNamespacedControllerRevision2(this IKubernetes operations, V1beta2ControllerRevision body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedControllerRevision2Async(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2ControllerRevision> CreateNamespacedControllerRevision2Async(this IKubernetes operations, V1beta2ControllerRevision body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedControllerRevision2WithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedControllerRevision2(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedControllerRevision2Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedControllerRevision2Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedControllerRevision2WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ControllerRevision
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2ControllerRevision ReadNamespacedControllerRevision2(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedControllerRevision2Async(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ControllerRevision
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2ControllerRevision> ReadNamespacedControllerRevision2Async(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedControllerRevision2WithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ControllerRevision
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2ControllerRevision ReplaceNamespacedControllerRevision2(this IKubernetes operations, V1beta2ControllerRevision body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedControllerRevision2Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ControllerRevision
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2ControllerRevision> ReplaceNamespacedControllerRevision2Async(this IKubernetes operations, V1beta2ControllerRevision body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedControllerRevision2WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ControllerRevision
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedControllerRevision2(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedControllerRevision2Async(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ControllerRevision
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedControllerRevision2Async(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedControllerRevision2WithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ControllerRevision
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2ControllerRevision PatchNamespacedControllerRevision2(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedControllerRevision2Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified ControllerRevision
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ControllerRevision
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2ControllerRevision> PatchNamespacedControllerRevision2Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedControllerRevision2WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2DaemonSetList ListNamespacedDaemonSet1(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedDaemonSet1Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2DaemonSetList> ListNamespacedDaemonSet1Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedDaemonSet1WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2DaemonSet CreateNamespacedDaemonSet1(this IKubernetes operations, V1beta2DaemonSet body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedDaemonSet1Async(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2DaemonSet> CreateNamespacedDaemonSet1Async(this IKubernetes operations, V1beta2DaemonSet body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedDaemonSet1WithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedDaemonSet1(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedDaemonSet1Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedDaemonSet1Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedDaemonSet1WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2DaemonSet ReadNamespacedDaemonSet1(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedDaemonSet1Async(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2DaemonSet> ReadNamespacedDaemonSet1Async(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedDaemonSet1WithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2DaemonSet ReplaceNamespacedDaemonSet1(this IKubernetes operations, V1beta2DaemonSet body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedDaemonSet1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2DaemonSet> ReplaceNamespacedDaemonSet1Async(this IKubernetes operations, V1beta2DaemonSet body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedDaemonSet1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedDaemonSet1(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedDaemonSet1Async(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedDaemonSet1Async(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedDaemonSet1WithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2DaemonSet PatchNamespacedDaemonSet1(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedDaemonSet1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2DaemonSet> PatchNamespacedDaemonSet1Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedDaemonSet1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2DaemonSet ReadNamespacedDaemonSetStatus1(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedDaemonSetStatus1Async(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2DaemonSet> ReadNamespacedDaemonSetStatus1Async(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedDaemonSetStatus1WithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2DaemonSet ReplaceNamespacedDaemonSetStatus1(this IKubernetes operations, V1beta2DaemonSet body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedDaemonSetStatus1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2DaemonSet> ReplaceNamespacedDaemonSetStatus1Async(this IKubernetes operations, V1beta2DaemonSet body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedDaemonSetStatus1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2DaemonSet PatchNamespacedDaemonSetStatus1(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedDaemonSetStatus1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2DaemonSet> PatchNamespacedDaemonSetStatus1Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedDaemonSetStatus1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2DeploymentList ListNamespacedDeployment2(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedDeployment2Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2DeploymentList> ListNamespacedDeployment2Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedDeployment2WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2Deployment CreateNamespacedDeployment2(this IKubernetes operations, V1beta2Deployment body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedDeployment2Async(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2Deployment> CreateNamespacedDeployment2Async(this IKubernetes operations, V1beta2Deployment body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedDeployment2WithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedDeployment2(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedDeployment2Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedDeployment2Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedDeployment2WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2Deployment ReadNamespacedDeployment2(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedDeployment2Async(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2Deployment> ReadNamespacedDeployment2Async(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedDeployment2WithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2Deployment ReplaceNamespacedDeployment2(this IKubernetes operations, V1beta2Deployment body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedDeployment2Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2Deployment> ReplaceNamespacedDeployment2Async(this IKubernetes operations, V1beta2Deployment body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedDeployment2WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedDeployment2(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedDeployment2Async(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedDeployment2Async(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedDeployment2WithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2Deployment PatchNamespacedDeployment2(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedDeployment2Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2Deployment> PatchNamespacedDeployment2Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedDeployment2WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read scale of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2Scale ReadNamespacedDeploymentScale2(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedDeploymentScale2Async(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read scale of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2Scale> ReadNamespacedDeploymentScale2Async(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedDeploymentScale2WithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace scale of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2Scale ReplaceNamespacedDeploymentScale2(this IKubernetes operations, V1beta2Scale body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedDeploymentScale2Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace scale of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2Scale> ReplaceNamespacedDeploymentScale2Async(this IKubernetes operations, V1beta2Scale body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedDeploymentScale2WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update scale of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2Scale PatchNamespacedDeploymentScale2(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedDeploymentScale2Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update scale of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2Scale> PatchNamespacedDeploymentScale2Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedDeploymentScale2WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2Deployment ReadNamespacedDeploymentStatus2(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedDeploymentStatus2Async(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2Deployment> ReadNamespacedDeploymentStatus2Async(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedDeploymentStatus2WithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2Deployment ReplaceNamespacedDeploymentStatus2(this IKubernetes operations, V1beta2Deployment body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedDeploymentStatus2Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2Deployment> ReplaceNamespacedDeploymentStatus2Async(this IKubernetes operations, V1beta2Deployment body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedDeploymentStatus2WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2Deployment PatchNamespacedDeploymentStatus2(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedDeploymentStatus2Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2Deployment> PatchNamespacedDeploymentStatus2Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedDeploymentStatus2WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2ReplicaSetList ListNamespacedReplicaSet1(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedReplicaSet1Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2ReplicaSetList> ListNamespacedReplicaSet1Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedReplicaSet1WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2ReplicaSet CreateNamespacedReplicaSet1(this IKubernetes operations, V1beta2ReplicaSet body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedReplicaSet1Async(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2ReplicaSet> CreateNamespacedReplicaSet1Async(this IKubernetes operations, V1beta2ReplicaSet body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedReplicaSet1WithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedReplicaSet1(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedReplicaSet1Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedReplicaSet1Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedReplicaSet1WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2ReplicaSet ReadNamespacedReplicaSet1(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedReplicaSet1Async(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2ReplicaSet> ReadNamespacedReplicaSet1Async(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedReplicaSet1WithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2ReplicaSet ReplaceNamespacedReplicaSet1(this IKubernetes operations, V1beta2ReplicaSet body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedReplicaSet1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2ReplicaSet> ReplaceNamespacedReplicaSet1Async(this IKubernetes operations, V1beta2ReplicaSet body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedReplicaSet1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedReplicaSet1(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedReplicaSet1Async(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedReplicaSet1Async(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedReplicaSet1WithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2ReplicaSet PatchNamespacedReplicaSet1(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedReplicaSet1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2ReplicaSet> PatchNamespacedReplicaSet1Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedReplicaSet1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read scale of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2Scale ReadNamespacedReplicaSetScale1(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedReplicaSetScale1Async(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read scale of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2Scale> ReadNamespacedReplicaSetScale1Async(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedReplicaSetScale1WithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace scale of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2Scale ReplaceNamespacedReplicaSetScale1(this IKubernetes operations, V1beta2Scale body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedReplicaSetScale1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace scale of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2Scale> ReplaceNamespacedReplicaSetScale1Async(this IKubernetes operations, V1beta2Scale body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedReplicaSetScale1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update scale of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2Scale PatchNamespacedReplicaSetScale1(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedReplicaSetScale1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update scale of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2Scale> PatchNamespacedReplicaSetScale1Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedReplicaSetScale1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2ReplicaSet ReadNamespacedReplicaSetStatus1(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedReplicaSetStatus1Async(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2ReplicaSet> ReadNamespacedReplicaSetStatus1Async(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedReplicaSetStatus1WithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2ReplicaSet ReplaceNamespacedReplicaSetStatus1(this IKubernetes operations, V1beta2ReplicaSet body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedReplicaSetStatus1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2ReplicaSet> ReplaceNamespacedReplicaSetStatus1Async(this IKubernetes operations, V1beta2ReplicaSet body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedReplicaSetStatus1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2ReplicaSet PatchNamespacedReplicaSetStatus1(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedReplicaSetStatus1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2ReplicaSet> PatchNamespacedReplicaSetStatus1Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedReplicaSetStatus1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2StatefulSetList ListNamespacedStatefulSet2(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedStatefulSet2Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2StatefulSetList> ListNamespacedStatefulSet2Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedStatefulSet2WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2StatefulSet CreateNamespacedStatefulSet2(this IKubernetes operations, V1beta2StatefulSet body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedStatefulSet2Async(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2StatefulSet> CreateNamespacedStatefulSet2Async(this IKubernetes operations, V1beta2StatefulSet body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedStatefulSet2WithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedStatefulSet2(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedStatefulSet2Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedStatefulSet2Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedStatefulSet2WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2StatefulSet ReadNamespacedStatefulSet2(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedStatefulSet2Async(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2StatefulSet> ReadNamespacedStatefulSet2Async(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedStatefulSet2WithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2StatefulSet ReplaceNamespacedStatefulSet2(this IKubernetes operations, V1beta2StatefulSet body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedStatefulSet2Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2StatefulSet> ReplaceNamespacedStatefulSet2Async(this IKubernetes operations, V1beta2StatefulSet body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedStatefulSet2WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedStatefulSet2(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedStatefulSet2Async(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedStatefulSet2Async(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedStatefulSet2WithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2StatefulSet PatchNamespacedStatefulSet2(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedStatefulSet2Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2StatefulSet> PatchNamespacedStatefulSet2Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedStatefulSet2WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read scale of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2Scale ReadNamespacedStatefulSetScale2(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedStatefulSetScale2Async(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read scale of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2Scale> ReadNamespacedStatefulSetScale2Async(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedStatefulSetScale2WithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace scale of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2Scale ReplaceNamespacedStatefulSetScale2(this IKubernetes operations, V1beta2Scale body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedStatefulSetScale2Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace scale of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2Scale> ReplaceNamespacedStatefulSetScale2Async(this IKubernetes operations, V1beta2Scale body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedStatefulSetScale2WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update scale of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2Scale PatchNamespacedStatefulSetScale2(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedStatefulSetScale2Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update scale of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2Scale> PatchNamespacedStatefulSetScale2Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedStatefulSetScale2WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2StatefulSet ReadNamespacedStatefulSetStatus2(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedStatefulSetStatus2Async(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2StatefulSet> ReadNamespacedStatefulSetStatus2Async(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedStatefulSetStatus2WithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2StatefulSet ReplaceNamespacedStatefulSetStatus2(this IKubernetes operations, V1beta2StatefulSet body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedStatefulSetStatus2Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2StatefulSet> ReplaceNamespacedStatefulSetStatus2Async(this IKubernetes operations, V1beta2StatefulSet body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedStatefulSetStatus2WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta2StatefulSet PatchNamespacedStatefulSetStatus2(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedStatefulSetStatus2Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StatefulSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2StatefulSet> PatchNamespacedStatefulSetStatus2Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedStatefulSetStatus2WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1beta2ReplicaSetList ListReplicaSetForAllNamespaces1(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListReplicaSetForAllNamespaces1Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2ReplicaSetList> ListReplicaSetForAllNamespaces1Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListReplicaSetForAllNamespaces1WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1beta2StatefulSetList ListStatefulSetForAllNamespaces2(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListStatefulSetForAllNamespaces2Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind StatefulSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta2StatefulSetList> ListStatefulSetForAllNamespaces2Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListStatefulSetForAllNamespaces2WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIGroup GetAPIGroup4(this IKubernetes operations)
            {
                return operations.GetAPIGroup4Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIGroup> GetAPIGroup4Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIGroup4WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIResourceList GetAPIResources9(this IKubernetes operations)
            {
                return operations.GetAPIResources9Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIResourceList> GetAPIResources9Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIResources9WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a TokenReview
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1TokenReview CreateTokenReview(this IKubernetes operations, V1TokenReview body, string pretty = default(string))
            {
                return operations.CreateTokenReviewAsync(body, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a TokenReview
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1TokenReview> CreateTokenReviewAsync(this IKubernetes operations, V1TokenReview body, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateTokenReviewWithHttpMessagesAsync(body, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIResourceList GetAPIResources10(this IKubernetes operations)
            {
                return operations.GetAPIResources10Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIResourceList> GetAPIResources10Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIResources10WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a TokenReview
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1TokenReview CreateTokenReview1(this IKubernetes operations, V1beta1TokenReview body, string pretty = default(string))
            {
                return operations.CreateTokenReview1Async(body, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a TokenReview
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1TokenReview> CreateTokenReview1Async(this IKubernetes operations, V1beta1TokenReview body, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateTokenReview1WithHttpMessagesAsync(body, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIGroup GetAPIGroup5(this IKubernetes operations)
            {
                return operations.GetAPIGroup5Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIGroup> GetAPIGroup5Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIGroup5WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIResourceList GetAPIResources11(this IKubernetes operations)
            {
                return operations.GetAPIResources11Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIResourceList> GetAPIResources11Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIResources11WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a LocalSubjectAccessReview
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1LocalSubjectAccessReview CreateNamespacedLocalSubjectAccessReview(this IKubernetes operations, V1LocalSubjectAccessReview body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedLocalSubjectAccessReviewAsync(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a LocalSubjectAccessReview
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1LocalSubjectAccessReview> CreateNamespacedLocalSubjectAccessReviewAsync(this IKubernetes operations, V1LocalSubjectAccessReview body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedLocalSubjectAccessReviewWithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a SelfSubjectAccessReview
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1SelfSubjectAccessReview CreateSelfSubjectAccessReview(this IKubernetes operations, V1SelfSubjectAccessReview body, string pretty = default(string))
            {
                return operations.CreateSelfSubjectAccessReviewAsync(body, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a SelfSubjectAccessReview
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1SelfSubjectAccessReview> CreateSelfSubjectAccessReviewAsync(this IKubernetes operations, V1SelfSubjectAccessReview body, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateSelfSubjectAccessReviewWithHttpMessagesAsync(body, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a SelfSubjectRulesReview
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1SelfSubjectRulesReview CreateSelfSubjectRulesReview(this IKubernetes operations, V1SelfSubjectRulesReview body, string pretty = default(string))
            {
                return operations.CreateSelfSubjectRulesReviewAsync(body, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a SelfSubjectRulesReview
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1SelfSubjectRulesReview> CreateSelfSubjectRulesReviewAsync(this IKubernetes operations, V1SelfSubjectRulesReview body, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateSelfSubjectRulesReviewWithHttpMessagesAsync(body, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a SubjectAccessReview
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1SubjectAccessReview CreateSubjectAccessReview(this IKubernetes operations, V1SubjectAccessReview body, string pretty = default(string))
            {
                return operations.CreateSubjectAccessReviewAsync(body, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a SubjectAccessReview
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1SubjectAccessReview> CreateSubjectAccessReviewAsync(this IKubernetes operations, V1SubjectAccessReview body, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateSubjectAccessReviewWithHttpMessagesAsync(body, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIResourceList GetAPIResources12(this IKubernetes operations)
            {
                return operations.GetAPIResources12Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIResourceList> GetAPIResources12Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIResources12WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a LocalSubjectAccessReview
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1LocalSubjectAccessReview CreateNamespacedLocalSubjectAccessReview1(this IKubernetes operations, V1beta1LocalSubjectAccessReview body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedLocalSubjectAccessReview1Async(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a LocalSubjectAccessReview
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1LocalSubjectAccessReview> CreateNamespacedLocalSubjectAccessReview1Async(this IKubernetes operations, V1beta1LocalSubjectAccessReview body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedLocalSubjectAccessReview1WithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a SelfSubjectAccessReview
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1SelfSubjectAccessReview CreateSelfSubjectAccessReview1(this IKubernetes operations, V1beta1SelfSubjectAccessReview body, string pretty = default(string))
            {
                return operations.CreateSelfSubjectAccessReview1Async(body, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a SelfSubjectAccessReview
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1SelfSubjectAccessReview> CreateSelfSubjectAccessReview1Async(this IKubernetes operations, V1beta1SelfSubjectAccessReview body, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateSelfSubjectAccessReview1WithHttpMessagesAsync(body, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a SelfSubjectRulesReview
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1SelfSubjectRulesReview CreateSelfSubjectRulesReview1(this IKubernetes operations, V1beta1SelfSubjectRulesReview body, string pretty = default(string))
            {
                return operations.CreateSelfSubjectRulesReview1Async(body, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a SelfSubjectRulesReview
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1SelfSubjectRulesReview> CreateSelfSubjectRulesReview1Async(this IKubernetes operations, V1beta1SelfSubjectRulesReview body, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateSelfSubjectRulesReview1WithHttpMessagesAsync(body, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a SubjectAccessReview
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1SubjectAccessReview CreateSubjectAccessReview1(this IKubernetes operations, V1beta1SubjectAccessReview body, string pretty = default(string))
            {
                return operations.CreateSubjectAccessReview1Async(body, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a SubjectAccessReview
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1SubjectAccessReview> CreateSubjectAccessReview1Async(this IKubernetes operations, V1beta1SubjectAccessReview body, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateSubjectAccessReview1WithHttpMessagesAsync(body, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIGroup GetAPIGroup6(this IKubernetes operations)
            {
                return operations.GetAPIGroup6Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIGroup> GetAPIGroup6Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIGroup6WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIResourceList GetAPIResources13(this IKubernetes operations)
            {
                return operations.GetAPIResources13Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIResourceList> GetAPIResources13Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIResources13WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1HorizontalPodAutoscalerList ListHorizontalPodAutoscalerForAllNamespaces(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListHorizontalPodAutoscalerForAllNamespacesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1HorizontalPodAutoscalerList> ListHorizontalPodAutoscalerForAllNamespacesAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListHorizontalPodAutoscalerForAllNamespacesWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1HorizontalPodAutoscalerList ListNamespacedHorizontalPodAutoscaler(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedHorizontalPodAutoscalerAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1HorizontalPodAutoscalerList> ListNamespacedHorizontalPodAutoscalerAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedHorizontalPodAutoscalerWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1HorizontalPodAutoscaler CreateNamespacedHorizontalPodAutoscaler(this IKubernetes operations, V1HorizontalPodAutoscaler body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedHorizontalPodAutoscalerAsync(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1HorizontalPodAutoscaler> CreateNamespacedHorizontalPodAutoscalerAsync(this IKubernetes operations, V1HorizontalPodAutoscaler body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedHorizontalPodAutoscalerWithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedHorizontalPodAutoscaler(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedHorizontalPodAutoscalerAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedHorizontalPodAutoscalerAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedHorizontalPodAutoscalerWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1HorizontalPodAutoscaler ReadNamespacedHorizontalPodAutoscaler(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedHorizontalPodAutoscalerAsync(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1HorizontalPodAutoscaler> ReadNamespacedHorizontalPodAutoscalerAsync(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedHorizontalPodAutoscalerWithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1HorizontalPodAutoscaler ReplaceNamespacedHorizontalPodAutoscaler(this IKubernetes operations, V1HorizontalPodAutoscaler body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedHorizontalPodAutoscalerAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1HorizontalPodAutoscaler> ReplaceNamespacedHorizontalPodAutoscalerAsync(this IKubernetes operations, V1HorizontalPodAutoscaler body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedHorizontalPodAutoscalerWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedHorizontalPodAutoscaler(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedHorizontalPodAutoscalerAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedHorizontalPodAutoscalerAsync(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedHorizontalPodAutoscalerWithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1HorizontalPodAutoscaler PatchNamespacedHorizontalPodAutoscaler(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedHorizontalPodAutoscalerAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1HorizontalPodAutoscaler> PatchNamespacedHorizontalPodAutoscalerAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedHorizontalPodAutoscalerWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1HorizontalPodAutoscaler ReadNamespacedHorizontalPodAutoscalerStatus(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedHorizontalPodAutoscalerStatusAsync(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1HorizontalPodAutoscaler> ReadNamespacedHorizontalPodAutoscalerStatusAsync(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedHorizontalPodAutoscalerStatusWithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1HorizontalPodAutoscaler ReplaceNamespacedHorizontalPodAutoscalerStatus(this IKubernetes operations, V1HorizontalPodAutoscaler body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedHorizontalPodAutoscalerStatusAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1HorizontalPodAutoscaler> ReplaceNamespacedHorizontalPodAutoscalerStatusAsync(this IKubernetes operations, V1HorizontalPodAutoscaler body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedHorizontalPodAutoscalerStatusWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1HorizontalPodAutoscaler PatchNamespacedHorizontalPodAutoscalerStatus(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedHorizontalPodAutoscalerStatusAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1HorizontalPodAutoscaler> PatchNamespacedHorizontalPodAutoscalerStatusAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedHorizontalPodAutoscalerStatusWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIResourceList GetAPIResources14(this IKubernetes operations)
            {
                return operations.GetAPIResources14Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIResourceList> GetAPIResources14Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIResources14WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V2beta1HorizontalPodAutoscalerList ListHorizontalPodAutoscalerForAllNamespaces1(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListHorizontalPodAutoscalerForAllNamespaces1Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V2beta1HorizontalPodAutoscalerList> ListHorizontalPodAutoscalerForAllNamespaces1Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListHorizontalPodAutoscalerForAllNamespaces1WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V2beta1HorizontalPodAutoscalerList ListNamespacedHorizontalPodAutoscaler1(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedHorizontalPodAutoscaler1Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V2beta1HorizontalPodAutoscalerList> ListNamespacedHorizontalPodAutoscaler1Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedHorizontalPodAutoscaler1WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V2beta1HorizontalPodAutoscaler CreateNamespacedHorizontalPodAutoscaler1(this IKubernetes operations, V2beta1HorizontalPodAutoscaler body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedHorizontalPodAutoscaler1Async(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V2beta1HorizontalPodAutoscaler> CreateNamespacedHorizontalPodAutoscaler1Async(this IKubernetes operations, V2beta1HorizontalPodAutoscaler body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedHorizontalPodAutoscaler1WithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedHorizontalPodAutoscaler1(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedHorizontalPodAutoscaler1Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedHorizontalPodAutoscaler1Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedHorizontalPodAutoscaler1WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V2beta1HorizontalPodAutoscaler ReadNamespacedHorizontalPodAutoscaler1(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedHorizontalPodAutoscaler1Async(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V2beta1HorizontalPodAutoscaler> ReadNamespacedHorizontalPodAutoscaler1Async(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedHorizontalPodAutoscaler1WithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V2beta1HorizontalPodAutoscaler ReplaceNamespacedHorizontalPodAutoscaler1(this IKubernetes operations, V2beta1HorizontalPodAutoscaler body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedHorizontalPodAutoscaler1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V2beta1HorizontalPodAutoscaler> ReplaceNamespacedHorizontalPodAutoscaler1Async(this IKubernetes operations, V2beta1HorizontalPodAutoscaler body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedHorizontalPodAutoscaler1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedHorizontalPodAutoscaler1(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedHorizontalPodAutoscaler1Async(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedHorizontalPodAutoscaler1Async(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedHorizontalPodAutoscaler1WithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V2beta1HorizontalPodAutoscaler PatchNamespacedHorizontalPodAutoscaler1(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedHorizontalPodAutoscaler1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V2beta1HorizontalPodAutoscaler> PatchNamespacedHorizontalPodAutoscaler1Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedHorizontalPodAutoscaler1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V2beta1HorizontalPodAutoscaler ReadNamespacedHorizontalPodAutoscalerStatus1(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedHorizontalPodAutoscalerStatus1Async(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V2beta1HorizontalPodAutoscaler> ReadNamespacedHorizontalPodAutoscalerStatus1Async(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedHorizontalPodAutoscalerStatus1WithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V2beta1HorizontalPodAutoscaler ReplaceNamespacedHorizontalPodAutoscalerStatus1(this IKubernetes operations, V2beta1HorizontalPodAutoscaler body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedHorizontalPodAutoscalerStatus1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V2beta1HorizontalPodAutoscaler> ReplaceNamespacedHorizontalPodAutoscalerStatus1Async(this IKubernetes operations, V2beta1HorizontalPodAutoscaler body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedHorizontalPodAutoscalerStatus1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V2beta1HorizontalPodAutoscaler PatchNamespacedHorizontalPodAutoscalerStatus1(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedHorizontalPodAutoscalerStatus1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V2beta1HorizontalPodAutoscaler> PatchNamespacedHorizontalPodAutoscalerStatus1Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedHorizontalPodAutoscalerStatus1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIResourceList GetAPIResources15(this IKubernetes operations)
            {
                return operations.GetAPIResources15Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIResourceList> GetAPIResources15Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIResources15WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V2beta2HorizontalPodAutoscalerList ListHorizontalPodAutoscalerForAllNamespaces2(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListHorizontalPodAutoscalerForAllNamespaces2Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V2beta2HorizontalPodAutoscalerList> ListHorizontalPodAutoscalerForAllNamespaces2Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListHorizontalPodAutoscalerForAllNamespaces2WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V2beta2HorizontalPodAutoscalerList ListNamespacedHorizontalPodAutoscaler2(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedHorizontalPodAutoscaler2Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V2beta2HorizontalPodAutoscalerList> ListNamespacedHorizontalPodAutoscaler2Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedHorizontalPodAutoscaler2WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V2beta2HorizontalPodAutoscaler CreateNamespacedHorizontalPodAutoscaler2(this IKubernetes operations, V2beta2HorizontalPodAutoscaler body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedHorizontalPodAutoscaler2Async(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V2beta2HorizontalPodAutoscaler> CreateNamespacedHorizontalPodAutoscaler2Async(this IKubernetes operations, V2beta2HorizontalPodAutoscaler body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedHorizontalPodAutoscaler2WithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedHorizontalPodAutoscaler2(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedHorizontalPodAutoscaler2Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedHorizontalPodAutoscaler2Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedHorizontalPodAutoscaler2WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V2beta2HorizontalPodAutoscaler ReadNamespacedHorizontalPodAutoscaler2(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedHorizontalPodAutoscaler2Async(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V2beta2HorizontalPodAutoscaler> ReadNamespacedHorizontalPodAutoscaler2Async(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedHorizontalPodAutoscaler2WithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V2beta2HorizontalPodAutoscaler ReplaceNamespacedHorizontalPodAutoscaler2(this IKubernetes operations, V2beta2HorizontalPodAutoscaler body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedHorizontalPodAutoscaler2Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V2beta2HorizontalPodAutoscaler> ReplaceNamespacedHorizontalPodAutoscaler2Async(this IKubernetes operations, V2beta2HorizontalPodAutoscaler body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedHorizontalPodAutoscaler2WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedHorizontalPodAutoscaler2(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedHorizontalPodAutoscaler2Async(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedHorizontalPodAutoscaler2Async(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedHorizontalPodAutoscaler2WithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V2beta2HorizontalPodAutoscaler PatchNamespacedHorizontalPodAutoscaler2(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedHorizontalPodAutoscaler2Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V2beta2HorizontalPodAutoscaler> PatchNamespacedHorizontalPodAutoscaler2Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedHorizontalPodAutoscaler2WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V2beta2HorizontalPodAutoscaler ReadNamespacedHorizontalPodAutoscalerStatus2(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedHorizontalPodAutoscalerStatus2Async(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V2beta2HorizontalPodAutoscaler> ReadNamespacedHorizontalPodAutoscalerStatus2Async(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedHorizontalPodAutoscalerStatus2WithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V2beta2HorizontalPodAutoscaler ReplaceNamespacedHorizontalPodAutoscalerStatus2(this IKubernetes operations, V2beta2HorizontalPodAutoscaler body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedHorizontalPodAutoscalerStatus2Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V2beta2HorizontalPodAutoscaler> ReplaceNamespacedHorizontalPodAutoscalerStatus2Async(this IKubernetes operations, V2beta2HorizontalPodAutoscaler body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedHorizontalPodAutoscalerStatus2WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V2beta2HorizontalPodAutoscaler PatchNamespacedHorizontalPodAutoscalerStatus2(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedHorizontalPodAutoscalerStatus2Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified HorizontalPodAutoscaler
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the HorizontalPodAutoscaler
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V2beta2HorizontalPodAutoscaler> PatchNamespacedHorizontalPodAutoscalerStatus2Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedHorizontalPodAutoscalerStatus2WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIGroup GetAPIGroup7(this IKubernetes operations)
            {
                return operations.GetAPIGroup7Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIGroup> GetAPIGroup7Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIGroup7WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIResourceList GetAPIResources16(this IKubernetes operations)
            {
                return operations.GetAPIResources16Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIResourceList> GetAPIResources16Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIResources16WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind Job
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1JobList ListJobForAllNamespaces(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListJobForAllNamespacesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind Job
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1JobList> ListJobForAllNamespacesAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListJobForAllNamespacesWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind Job
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1JobList ListNamespacedJob(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedJobAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind Job
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1JobList> ListNamespacedJobAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedJobWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a Job
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Job CreateNamespacedJob(this IKubernetes operations, V1Job body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedJobAsync(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a Job
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Job> CreateNamespacedJobAsync(this IKubernetes operations, V1Job body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedJobWithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of Job
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedJob(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedJobAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of Job
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedJobAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedJobWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified Job
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Job
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Job ReadNamespacedJob(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedJobAsync(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified Job
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Job
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Job> ReadNamespacedJobAsync(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedJobWithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified Job
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Job
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Job ReplaceNamespacedJob(this IKubernetes operations, V1Job body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedJobAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified Job
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Job
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Job> ReplaceNamespacedJobAsync(this IKubernetes operations, V1Job body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedJobWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a Job
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Job
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedJob(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedJobAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a Job
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Job
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedJobAsync(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedJobWithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified Job
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Job
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Job PatchNamespacedJob(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedJobAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified Job
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Job
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Job> PatchNamespacedJobAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedJobWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified Job
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Job
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Job ReadNamespacedJobStatus(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedJobStatusAsync(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified Job
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Job
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Job> ReadNamespacedJobStatusAsync(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedJobStatusWithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the specified Job
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Job
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Job ReplaceNamespacedJobStatus(this IKubernetes operations, V1Job body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedJobStatusAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the specified Job
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Job
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Job> ReplaceNamespacedJobStatusAsync(this IKubernetes operations, V1Job body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedJobStatusWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified Job
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Job
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Job PatchNamespacedJobStatus(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedJobStatusAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified Job
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Job
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Job> PatchNamespacedJobStatusAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedJobStatusWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIResourceList GetAPIResources17(this IKubernetes operations)
            {
                return operations.GetAPIResources17Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIResourceList> GetAPIResources17Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIResources17WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1beta1CronJobList ListCronJobForAllNamespaces(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListCronJobForAllNamespacesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1CronJobList> ListCronJobForAllNamespacesAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListCronJobForAllNamespacesWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1CronJobList ListNamespacedCronJob(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedCronJobAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1CronJobList> ListNamespacedCronJobAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedCronJobWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1CronJob CreateNamespacedCronJob(this IKubernetes operations, V1beta1CronJob body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedCronJobAsync(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1CronJob> CreateNamespacedCronJobAsync(this IKubernetes operations, V1beta1CronJob body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedCronJobWithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedCronJob(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedCronJobAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedCronJobAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedCronJobWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the CronJob
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1CronJob ReadNamespacedCronJob(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedCronJobAsync(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the CronJob
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1CronJob> ReadNamespacedCronJobAsync(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedCronJobWithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CronJob
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1CronJob ReplaceNamespacedCronJob(this IKubernetes operations, V1beta1CronJob body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedCronJobAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CronJob
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1CronJob> ReplaceNamespacedCronJobAsync(this IKubernetes operations, V1beta1CronJob body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedCronJobWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CronJob
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedCronJob(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedCronJobAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CronJob
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedCronJobAsync(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedCronJobWithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CronJob
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1CronJob PatchNamespacedCronJob(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedCronJobAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CronJob
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1CronJob> PatchNamespacedCronJobAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedCronJobWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the CronJob
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1CronJob ReadNamespacedCronJobStatus(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedCronJobStatusAsync(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the CronJob
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1CronJob> ReadNamespacedCronJobStatusAsync(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedCronJobStatusWithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the specified CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CronJob
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1CronJob ReplaceNamespacedCronJobStatus(this IKubernetes operations, V1beta1CronJob body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedCronJobStatusAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the specified CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CronJob
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1CronJob> ReplaceNamespacedCronJobStatusAsync(this IKubernetes operations, V1beta1CronJob body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedCronJobStatusWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CronJob
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1CronJob PatchNamespacedCronJobStatus(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedCronJobStatusAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CronJob
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1CronJob> PatchNamespacedCronJobStatusAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedCronJobStatusWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIResourceList GetAPIResources18(this IKubernetes operations)
            {
                return operations.GetAPIResources18Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIResourceList> GetAPIResources18Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIResources18WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V2alpha1CronJobList ListCronJobForAllNamespaces1(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListCronJobForAllNamespaces1Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V2alpha1CronJobList> ListCronJobForAllNamespaces1Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListCronJobForAllNamespaces1WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V2alpha1CronJobList ListNamespacedCronJob1(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedCronJob1Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V2alpha1CronJobList> ListNamespacedCronJob1Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedCronJob1WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V2alpha1CronJob CreateNamespacedCronJob1(this IKubernetes operations, V2alpha1CronJob body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedCronJob1Async(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V2alpha1CronJob> CreateNamespacedCronJob1Async(this IKubernetes operations, V2alpha1CronJob body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedCronJob1WithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedCronJob1(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedCronJob1Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedCronJob1Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedCronJob1WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the CronJob
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V2alpha1CronJob ReadNamespacedCronJob1(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedCronJob1Async(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the CronJob
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V2alpha1CronJob> ReadNamespacedCronJob1Async(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedCronJob1WithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CronJob
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V2alpha1CronJob ReplaceNamespacedCronJob1(this IKubernetes operations, V2alpha1CronJob body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedCronJob1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CronJob
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V2alpha1CronJob> ReplaceNamespacedCronJob1Async(this IKubernetes operations, V2alpha1CronJob body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedCronJob1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CronJob
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedCronJob1(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedCronJob1Async(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CronJob
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedCronJob1Async(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedCronJob1WithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CronJob
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V2alpha1CronJob PatchNamespacedCronJob1(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedCronJob1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CronJob
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V2alpha1CronJob> PatchNamespacedCronJob1Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedCronJob1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the CronJob
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V2alpha1CronJob ReadNamespacedCronJobStatus1(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedCronJobStatus1Async(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the CronJob
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V2alpha1CronJob> ReadNamespacedCronJobStatus1Async(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedCronJobStatus1WithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the specified CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CronJob
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V2alpha1CronJob ReplaceNamespacedCronJobStatus1(this IKubernetes operations, V2alpha1CronJob body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedCronJobStatus1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the specified CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CronJob
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V2alpha1CronJob> ReplaceNamespacedCronJobStatus1Async(this IKubernetes operations, V2alpha1CronJob body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedCronJobStatus1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CronJob
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V2alpha1CronJob PatchNamespacedCronJobStatus1(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedCronJobStatus1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified CronJob
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CronJob
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V2alpha1CronJob> PatchNamespacedCronJobStatus1Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedCronJobStatus1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIGroup GetAPIGroup8(this IKubernetes operations)
            {
                return operations.GetAPIGroup8Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIGroup> GetAPIGroup8Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIGroup8WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIResourceList GetAPIResources19(this IKubernetes operations)
            {
                return operations.GetAPIResources19Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIResourceList> GetAPIResources19Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIResources19WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind CertificateSigningRequest
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1CertificateSigningRequestList ListCertificateSigningRequest(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListCertificateSigningRequestAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind CertificateSigningRequest
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1CertificateSigningRequestList> ListCertificateSigningRequestAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListCertificateSigningRequestWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a CertificateSigningRequest
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1CertificateSigningRequest CreateCertificateSigningRequest(this IKubernetes operations, V1beta1CertificateSigningRequest body, string pretty = default(string))
            {
                return operations.CreateCertificateSigningRequestAsync(body, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a CertificateSigningRequest
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1CertificateSigningRequest> CreateCertificateSigningRequestAsync(this IKubernetes operations, V1beta1CertificateSigningRequest body, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateCertificateSigningRequestWithHttpMessagesAsync(body, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of CertificateSigningRequest
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionCertificateSigningRequest(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionCertificateSigningRequestAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of CertificateSigningRequest
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionCertificateSigningRequestAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionCertificateSigningRequestWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified CertificateSigningRequest
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the CertificateSigningRequest
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1CertificateSigningRequest ReadCertificateSigningRequest(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadCertificateSigningRequestAsync(name, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified CertificateSigningRequest
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the CertificateSigningRequest
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1CertificateSigningRequest> ReadCertificateSigningRequestAsync(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadCertificateSigningRequestWithHttpMessagesAsync(name, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified CertificateSigningRequest
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CertificateSigningRequest
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1CertificateSigningRequest ReplaceCertificateSigningRequest(this IKubernetes operations, V1beta1CertificateSigningRequest body, string name, string pretty = default(string))
            {
                return operations.ReplaceCertificateSigningRequestAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified CertificateSigningRequest
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CertificateSigningRequest
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1CertificateSigningRequest> ReplaceCertificateSigningRequestAsync(this IKubernetes operations, V1beta1CertificateSigningRequest body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceCertificateSigningRequestWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a CertificateSigningRequest
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CertificateSigningRequest
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCertificateSigningRequest(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteCertificateSigningRequestAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a CertificateSigningRequest
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CertificateSigningRequest
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCertificateSigningRequestAsync(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCertificateSigningRequestWithHttpMessagesAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified CertificateSigningRequest
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CertificateSigningRequest
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1CertificateSigningRequest PatchCertificateSigningRequest(this IKubernetes operations, V1Patch body, string name, string pretty = default(string))
            {
                return operations.PatchCertificateSigningRequestAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified CertificateSigningRequest
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CertificateSigningRequest
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1CertificateSigningRequest> PatchCertificateSigningRequestAsync(this IKubernetes operations, V1Patch body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchCertificateSigningRequestWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace approval of the specified CertificateSigningRequest
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CertificateSigningRequest
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1CertificateSigningRequest ReplaceCertificateSigningRequestApproval(this IKubernetes operations, V1beta1CertificateSigningRequest body, string name, string pretty = default(string))
            {
                return operations.ReplaceCertificateSigningRequestApprovalAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace approval of the specified CertificateSigningRequest
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CertificateSigningRequest
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1CertificateSigningRequest> ReplaceCertificateSigningRequestApprovalAsync(this IKubernetes operations, V1beta1CertificateSigningRequest body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceCertificateSigningRequestApprovalWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified CertificateSigningRequest
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the CertificateSigningRequest
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1CertificateSigningRequest ReadCertificateSigningRequestStatus(this IKubernetes operations, string name, string pretty = default(string))
            {
                return operations.ReadCertificateSigningRequestStatusAsync(name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified CertificateSigningRequest
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the CertificateSigningRequest
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1CertificateSigningRequest> ReadCertificateSigningRequestStatusAsync(this IKubernetes operations, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadCertificateSigningRequestStatusWithHttpMessagesAsync(name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the specified CertificateSigningRequest
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CertificateSigningRequest
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1CertificateSigningRequest ReplaceCertificateSigningRequestStatus(this IKubernetes operations, V1beta1CertificateSigningRequest body, string name, string pretty = default(string))
            {
                return operations.ReplaceCertificateSigningRequestStatusAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the specified CertificateSigningRequest
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CertificateSigningRequest
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1CertificateSigningRequest> ReplaceCertificateSigningRequestStatusAsync(this IKubernetes operations, V1beta1CertificateSigningRequest body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceCertificateSigningRequestStatusWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified CertificateSigningRequest
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CertificateSigningRequest
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1CertificateSigningRequest PatchCertificateSigningRequestStatus(this IKubernetes operations, V1Patch body, string name, string pretty = default(string))
            {
                return operations.PatchCertificateSigningRequestStatusAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified CertificateSigningRequest
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the CertificateSigningRequest
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1CertificateSigningRequest> PatchCertificateSigningRequestStatusAsync(this IKubernetes operations, V1Patch body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchCertificateSigningRequestStatusWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIGroup GetAPIGroup9(this IKubernetes operations)
            {
                return operations.GetAPIGroup9Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIGroup> GetAPIGroup9Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIGroup9WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIResourceList GetAPIResources20(this IKubernetes operations)
            {
                return operations.GetAPIResources20Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIResourceList> GetAPIResources20Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIResources20WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind Lease
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1beta1LeaseList ListLeaseForAllNamespaces(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListLeaseForAllNamespacesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind Lease
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1LeaseList> ListLeaseForAllNamespacesAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListLeaseForAllNamespacesWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind Lease
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1LeaseList ListNamespacedLease(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedLeaseAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind Lease
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1LeaseList> ListNamespacedLeaseAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedLeaseWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a Lease
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1Lease CreateNamespacedLease(this IKubernetes operations, V1beta1Lease body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedLeaseAsync(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a Lease
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1Lease> CreateNamespacedLeaseAsync(this IKubernetes operations, V1beta1Lease body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedLeaseWithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of Lease
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedLease(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedLeaseAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of Lease
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedLeaseAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedLeaseWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified Lease
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Lease
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1Lease ReadNamespacedLease(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedLeaseAsync(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified Lease
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Lease
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1Lease> ReadNamespacedLeaseAsync(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedLeaseWithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified Lease
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Lease
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1Lease ReplaceNamespacedLease(this IKubernetes operations, V1beta1Lease body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedLeaseAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified Lease
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Lease
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1Lease> ReplaceNamespacedLeaseAsync(this IKubernetes operations, V1beta1Lease body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedLeaseWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a Lease
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Lease
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedLease(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedLeaseAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a Lease
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Lease
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedLeaseAsync(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedLeaseWithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified Lease
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Lease
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1Lease PatchNamespacedLease(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedLeaseAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified Lease
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Lease
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1Lease> PatchNamespacedLeaseAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedLeaseWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIGroup GetAPIGroup10(this IKubernetes operations)
            {
                return operations.GetAPIGroup10Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIGroup> GetAPIGroup10Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIGroup10WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIResourceList GetAPIResources21(this IKubernetes operations)
            {
                return operations.GetAPIResources21Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIResourceList> GetAPIResources21Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIResources21WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind Event
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1beta1EventList ListEventForAllNamespaces1(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListEventForAllNamespaces1Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind Event
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1EventList> ListEventForAllNamespaces1Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListEventForAllNamespaces1WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind Event
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1EventList ListNamespacedEvent1(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedEvent1Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind Event
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1EventList> ListNamespacedEvent1Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedEvent1WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create an Event
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1Event CreateNamespacedEvent1(this IKubernetes operations, V1beta1Event body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedEvent1Async(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create an Event
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1Event> CreateNamespacedEvent1Async(this IKubernetes operations, V1beta1Event body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedEvent1WithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of Event
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedEvent1(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedEvent1Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of Event
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedEvent1Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedEvent1WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified Event
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Event
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1Event ReadNamespacedEvent1(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedEvent1Async(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified Event
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Event
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1Event> ReadNamespacedEvent1Async(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedEvent1WithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified Event
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Event
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1Event ReplaceNamespacedEvent1(this IKubernetes operations, V1beta1Event body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedEvent1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified Event
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Event
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1Event> ReplaceNamespacedEvent1Async(this IKubernetes operations, V1beta1Event body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedEvent1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete an Event
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Event
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedEvent1(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedEvent1Async(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete an Event
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Event
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedEvent1Async(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedEvent1WithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified Event
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Event
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1Event PatchNamespacedEvent1(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedEvent1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified Event
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Event
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1Event> PatchNamespacedEvent1Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedEvent1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIGroup GetAPIGroup11(this IKubernetes operations)
            {
                return operations.GetAPIGroup11Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIGroup> GetAPIGroup11Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIGroup11WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIResourceList GetAPIResources22(this IKubernetes operations)
            {
                return operations.GetAPIResources22Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIResourceList> GetAPIResources22Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIResources22WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1beta1DaemonSetList ListDaemonSetForAllNamespaces2(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListDaemonSetForAllNamespaces2Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1DaemonSetList> ListDaemonSetForAllNamespaces2Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListDaemonSetForAllNamespaces2WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static Extensionsv1beta1DeploymentList ListDeploymentForAllNamespaces3(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListDeploymentForAllNamespaces3Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Extensionsv1beta1DeploymentList> ListDeploymentForAllNamespaces3Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListDeploymentForAllNamespaces3WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind Ingress
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1beta1IngressList ListIngressForAllNamespaces(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListIngressForAllNamespacesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind Ingress
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1IngressList> ListIngressForAllNamespacesAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListIngressForAllNamespacesWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1DaemonSetList ListNamespacedDaemonSet2(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedDaemonSet2Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1DaemonSetList> ListNamespacedDaemonSet2Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedDaemonSet2WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1DaemonSet CreateNamespacedDaemonSet2(this IKubernetes operations, V1beta1DaemonSet body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedDaemonSet2Async(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1DaemonSet> CreateNamespacedDaemonSet2Async(this IKubernetes operations, V1beta1DaemonSet body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedDaemonSet2WithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedDaemonSet2(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedDaemonSet2Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedDaemonSet2Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedDaemonSet2WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1DaemonSet ReadNamespacedDaemonSet2(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedDaemonSet2Async(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1DaemonSet> ReadNamespacedDaemonSet2Async(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedDaemonSet2WithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1DaemonSet ReplaceNamespacedDaemonSet2(this IKubernetes operations, V1beta1DaemonSet body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedDaemonSet2Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1DaemonSet> ReplaceNamespacedDaemonSet2Async(this IKubernetes operations, V1beta1DaemonSet body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedDaemonSet2WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedDaemonSet2(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedDaemonSet2Async(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedDaemonSet2Async(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedDaemonSet2WithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1DaemonSet PatchNamespacedDaemonSet2(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedDaemonSet2Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1DaemonSet> PatchNamespacedDaemonSet2Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedDaemonSet2WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1DaemonSet ReadNamespacedDaemonSetStatus2(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedDaemonSetStatus2Async(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1DaemonSet> ReadNamespacedDaemonSetStatus2Async(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedDaemonSetStatus2WithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1DaemonSet ReplaceNamespacedDaemonSetStatus2(this IKubernetes operations, V1beta1DaemonSet body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedDaemonSetStatus2Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1DaemonSet> ReplaceNamespacedDaemonSetStatus2Async(this IKubernetes operations, V1beta1DaemonSet body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedDaemonSetStatus2WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1DaemonSet PatchNamespacedDaemonSetStatus2(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedDaemonSetStatus2Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified DaemonSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the DaemonSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1DaemonSet> PatchNamespacedDaemonSetStatus2Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedDaemonSetStatus2WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Extensionsv1beta1DeploymentList ListNamespacedDeployment3(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedDeployment3Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Extensionsv1beta1DeploymentList> ListNamespacedDeployment3Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedDeployment3WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Extensionsv1beta1Deployment CreateNamespacedDeployment3(this IKubernetes operations, Extensionsv1beta1Deployment body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedDeployment3Async(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Extensionsv1beta1Deployment> CreateNamespacedDeployment3Async(this IKubernetes operations, Extensionsv1beta1Deployment body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedDeployment3WithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedDeployment3(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedDeployment3Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedDeployment3Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedDeployment3WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Extensionsv1beta1Deployment ReadNamespacedDeployment3(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedDeployment3Async(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Extensionsv1beta1Deployment> ReadNamespacedDeployment3Async(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedDeployment3WithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Extensionsv1beta1Deployment ReplaceNamespacedDeployment3(this IKubernetes operations, Extensionsv1beta1Deployment body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedDeployment3Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Extensionsv1beta1Deployment> ReplaceNamespacedDeployment3Async(this IKubernetes operations, Extensionsv1beta1Deployment body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedDeployment3WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedDeployment3(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedDeployment3Async(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedDeployment3Async(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedDeployment3WithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Extensionsv1beta1Deployment PatchNamespacedDeployment3(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedDeployment3Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Extensionsv1beta1Deployment> PatchNamespacedDeployment3Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedDeployment3WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create rollback of a Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the DeploymentRollback
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Extensionsv1beta1DeploymentStatus CreateNamespacedDeploymentRollback1(this IKubernetes operations, Extensionsv1beta1DeploymentRollback body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedDeploymentRollback1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create rollback of a Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the DeploymentRollback
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Extensionsv1beta1DeploymentStatus> CreateNamespacedDeploymentRollback1Async(this IKubernetes operations, Extensionsv1beta1DeploymentRollback body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedDeploymentRollback1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read scale of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Extensionsv1beta1Scale ReadNamespacedDeploymentScale3(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedDeploymentScale3Async(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read scale of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Extensionsv1beta1Scale> ReadNamespacedDeploymentScale3Async(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedDeploymentScale3WithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace scale of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Extensionsv1beta1Scale ReplaceNamespacedDeploymentScale3(this IKubernetes operations, Extensionsv1beta1Scale body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedDeploymentScale3Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace scale of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Extensionsv1beta1Scale> ReplaceNamespacedDeploymentScale3Async(this IKubernetes operations, Extensionsv1beta1Scale body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedDeploymentScale3WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update scale of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Extensionsv1beta1Scale PatchNamespacedDeploymentScale3(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedDeploymentScale3Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update scale of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Extensionsv1beta1Scale> PatchNamespacedDeploymentScale3Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedDeploymentScale3WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Extensionsv1beta1Deployment ReadNamespacedDeploymentStatus3(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedDeploymentStatus3Async(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Extensionsv1beta1Deployment> ReadNamespacedDeploymentStatus3Async(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedDeploymentStatus3WithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Extensionsv1beta1Deployment ReplaceNamespacedDeploymentStatus3(this IKubernetes operations, Extensionsv1beta1Deployment body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedDeploymentStatus3Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Extensionsv1beta1Deployment> ReplaceNamespacedDeploymentStatus3Async(this IKubernetes operations, Extensionsv1beta1Deployment body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedDeploymentStatus3WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Extensionsv1beta1Deployment PatchNamespacedDeploymentStatus3(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedDeploymentStatus3Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified Deployment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Deployment
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Extensionsv1beta1Deployment> PatchNamespacedDeploymentStatus3Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedDeploymentStatus3WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind Ingress
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1IngressList ListNamespacedIngress(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedIngressAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind Ingress
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1IngressList> ListNamespacedIngressAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedIngressWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create an Ingress
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1Ingress CreateNamespacedIngress(this IKubernetes operations, V1beta1Ingress body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedIngressAsync(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create an Ingress
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1Ingress> CreateNamespacedIngressAsync(this IKubernetes operations, V1beta1Ingress body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedIngressWithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of Ingress
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedIngress(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedIngressAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of Ingress
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedIngressAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedIngressWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified Ingress
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Ingress
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1Ingress ReadNamespacedIngress(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedIngressAsync(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified Ingress
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Ingress
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1Ingress> ReadNamespacedIngressAsync(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedIngressWithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified Ingress
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Ingress
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1Ingress ReplaceNamespacedIngress(this IKubernetes operations, V1beta1Ingress body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedIngressAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified Ingress
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Ingress
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1Ingress> ReplaceNamespacedIngressAsync(this IKubernetes operations, V1beta1Ingress body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedIngressWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete an Ingress
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Ingress
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedIngress(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedIngressAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete an Ingress
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Ingress
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedIngressAsync(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedIngressWithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified Ingress
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Ingress
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1Ingress PatchNamespacedIngress(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedIngressAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified Ingress
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Ingress
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1Ingress> PatchNamespacedIngressAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedIngressWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified Ingress
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Ingress
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1Ingress ReadNamespacedIngressStatus(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedIngressStatusAsync(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified Ingress
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Ingress
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1Ingress> ReadNamespacedIngressStatusAsync(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedIngressStatusWithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the specified Ingress
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Ingress
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1Ingress ReplaceNamespacedIngressStatus(this IKubernetes operations, V1beta1Ingress body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedIngressStatusAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the specified Ingress
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Ingress
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1Ingress> ReplaceNamespacedIngressStatusAsync(this IKubernetes operations, V1beta1Ingress body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedIngressStatusWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified Ingress
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Ingress
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1Ingress PatchNamespacedIngressStatus(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedIngressStatusAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified Ingress
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Ingress
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1Ingress> PatchNamespacedIngressStatusAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedIngressStatusWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind NetworkPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1NetworkPolicyList ListNamespacedNetworkPolicy(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedNetworkPolicyAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind NetworkPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1NetworkPolicyList> ListNamespacedNetworkPolicyAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedNetworkPolicyWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a NetworkPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1NetworkPolicy CreateNamespacedNetworkPolicy(this IKubernetes operations, V1beta1NetworkPolicy body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedNetworkPolicyAsync(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a NetworkPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1NetworkPolicy> CreateNamespacedNetworkPolicyAsync(this IKubernetes operations, V1beta1NetworkPolicy body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedNetworkPolicyWithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of NetworkPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedNetworkPolicy(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedNetworkPolicyAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of NetworkPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedNetworkPolicyAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedNetworkPolicyWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified NetworkPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the NetworkPolicy
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1NetworkPolicy ReadNamespacedNetworkPolicy(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedNetworkPolicyAsync(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified NetworkPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the NetworkPolicy
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1NetworkPolicy> ReadNamespacedNetworkPolicyAsync(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedNetworkPolicyWithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified NetworkPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the NetworkPolicy
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1NetworkPolicy ReplaceNamespacedNetworkPolicy(this IKubernetes operations, V1beta1NetworkPolicy body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedNetworkPolicyAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified NetworkPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the NetworkPolicy
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1NetworkPolicy> ReplaceNamespacedNetworkPolicyAsync(this IKubernetes operations, V1beta1NetworkPolicy body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedNetworkPolicyWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a NetworkPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the NetworkPolicy
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedNetworkPolicy(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedNetworkPolicyAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a NetworkPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the NetworkPolicy
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedNetworkPolicyAsync(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedNetworkPolicyWithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified NetworkPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the NetworkPolicy
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1NetworkPolicy PatchNamespacedNetworkPolicy(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedNetworkPolicyAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified NetworkPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the NetworkPolicy
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1NetworkPolicy> PatchNamespacedNetworkPolicyAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedNetworkPolicyWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1ReplicaSetList ListNamespacedReplicaSet2(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedReplicaSet2Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1ReplicaSetList> ListNamespacedReplicaSet2Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedReplicaSet2WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1ReplicaSet CreateNamespacedReplicaSet2(this IKubernetes operations, V1beta1ReplicaSet body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedReplicaSet2Async(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1ReplicaSet> CreateNamespacedReplicaSet2Async(this IKubernetes operations, V1beta1ReplicaSet body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedReplicaSet2WithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedReplicaSet2(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedReplicaSet2Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedReplicaSet2Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedReplicaSet2WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1ReplicaSet ReadNamespacedReplicaSet2(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedReplicaSet2Async(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1ReplicaSet> ReadNamespacedReplicaSet2Async(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedReplicaSet2WithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1ReplicaSet ReplaceNamespacedReplicaSet2(this IKubernetes operations, V1beta1ReplicaSet body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedReplicaSet2Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1ReplicaSet> ReplaceNamespacedReplicaSet2Async(this IKubernetes operations, V1beta1ReplicaSet body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedReplicaSet2WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedReplicaSet2(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedReplicaSet2Async(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedReplicaSet2Async(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedReplicaSet2WithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1ReplicaSet PatchNamespacedReplicaSet2(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedReplicaSet2Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1ReplicaSet> PatchNamespacedReplicaSet2Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedReplicaSet2WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read scale of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Extensionsv1beta1Scale ReadNamespacedReplicaSetScale2(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedReplicaSetScale2Async(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read scale of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Extensionsv1beta1Scale> ReadNamespacedReplicaSetScale2Async(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedReplicaSetScale2WithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace scale of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Extensionsv1beta1Scale ReplaceNamespacedReplicaSetScale2(this IKubernetes operations, Extensionsv1beta1Scale body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedReplicaSetScale2Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace scale of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Extensionsv1beta1Scale> ReplaceNamespacedReplicaSetScale2Async(this IKubernetes operations, Extensionsv1beta1Scale body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedReplicaSetScale2WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update scale of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Extensionsv1beta1Scale PatchNamespacedReplicaSetScale2(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedReplicaSetScale2Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update scale of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Extensionsv1beta1Scale> PatchNamespacedReplicaSetScale2Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedReplicaSetScale2WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1ReplicaSet ReadNamespacedReplicaSetStatus2(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedReplicaSetStatus2Async(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1ReplicaSet> ReadNamespacedReplicaSetStatus2Async(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedReplicaSetStatus2WithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1ReplicaSet ReplaceNamespacedReplicaSetStatus2(this IKubernetes operations, V1beta1ReplicaSet body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedReplicaSetStatus2Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1ReplicaSet> ReplaceNamespacedReplicaSetStatus2Async(this IKubernetes operations, V1beta1ReplicaSet body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedReplicaSetStatus2WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1ReplicaSet PatchNamespacedReplicaSetStatus2(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedReplicaSetStatus2Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ReplicaSet
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1ReplicaSet> PatchNamespacedReplicaSetStatus2Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedReplicaSetStatus2WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read scale of the specified ReplicationControllerDummy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Extensionsv1beta1Scale ReadNamespacedReplicationControllerDummyScale(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedReplicationControllerDummyScaleAsync(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read scale of the specified ReplicationControllerDummy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Extensionsv1beta1Scale> ReadNamespacedReplicationControllerDummyScaleAsync(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedReplicationControllerDummyScaleWithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace scale of the specified ReplicationControllerDummy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Extensionsv1beta1Scale ReplaceNamespacedReplicationControllerDummyScale(this IKubernetes operations, Extensionsv1beta1Scale body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedReplicationControllerDummyScaleAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace scale of the specified ReplicationControllerDummy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Extensionsv1beta1Scale> ReplaceNamespacedReplicationControllerDummyScaleAsync(this IKubernetes operations, Extensionsv1beta1Scale body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedReplicationControllerDummyScaleWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update scale of the specified ReplicationControllerDummy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Extensionsv1beta1Scale PatchNamespacedReplicationControllerDummyScale(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedReplicationControllerDummyScaleAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update scale of the specified ReplicationControllerDummy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Scale
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Extensionsv1beta1Scale> PatchNamespacedReplicationControllerDummyScaleAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedReplicationControllerDummyScaleWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind NetworkPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1beta1NetworkPolicyList ListNetworkPolicyForAllNamespaces(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListNetworkPolicyForAllNamespacesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind NetworkPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1NetworkPolicyList> ListNetworkPolicyForAllNamespacesAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNetworkPolicyForAllNamespacesWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind PodSecurityPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Extensionsv1beta1PodSecurityPolicyList ListPodSecurityPolicy(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListPodSecurityPolicyAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind PodSecurityPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Extensionsv1beta1PodSecurityPolicyList> ListPodSecurityPolicyAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListPodSecurityPolicyWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a PodSecurityPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Extensionsv1beta1PodSecurityPolicy CreatePodSecurityPolicy(this IKubernetes operations, Extensionsv1beta1PodSecurityPolicy body, string pretty = default(string))
            {
                return operations.CreatePodSecurityPolicyAsync(body, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a PodSecurityPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Extensionsv1beta1PodSecurityPolicy> CreatePodSecurityPolicyAsync(this IKubernetes operations, Extensionsv1beta1PodSecurityPolicy body, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreatePodSecurityPolicyWithHttpMessagesAsync(body, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of PodSecurityPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionPodSecurityPolicy(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionPodSecurityPolicyAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of PodSecurityPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionPodSecurityPolicyAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionPodSecurityPolicyWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified PodSecurityPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodSecurityPolicy
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Extensionsv1beta1PodSecurityPolicy ReadPodSecurityPolicy(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadPodSecurityPolicyAsync(name, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified PodSecurityPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodSecurityPolicy
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Extensionsv1beta1PodSecurityPolicy> ReadPodSecurityPolicyAsync(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadPodSecurityPolicyWithHttpMessagesAsync(name, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified PodSecurityPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PodSecurityPolicy
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Extensionsv1beta1PodSecurityPolicy ReplacePodSecurityPolicy(this IKubernetes operations, Extensionsv1beta1PodSecurityPolicy body, string name, string pretty = default(string))
            {
                return operations.ReplacePodSecurityPolicyAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified PodSecurityPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PodSecurityPolicy
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Extensionsv1beta1PodSecurityPolicy> ReplacePodSecurityPolicyAsync(this IKubernetes operations, Extensionsv1beta1PodSecurityPolicy body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplacePodSecurityPolicyWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a PodSecurityPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PodSecurityPolicy
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeletePodSecurityPolicy(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeletePodSecurityPolicyAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a PodSecurityPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PodSecurityPolicy
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeletePodSecurityPolicyAsync(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeletePodSecurityPolicyWithHttpMessagesAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified PodSecurityPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PodSecurityPolicy
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Extensionsv1beta1PodSecurityPolicy PatchPodSecurityPolicy(this IKubernetes operations, V1Patch body, string name, string pretty = default(string))
            {
                return operations.PatchPodSecurityPolicyAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified PodSecurityPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PodSecurityPolicy
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Extensionsv1beta1PodSecurityPolicy> PatchPodSecurityPolicyAsync(this IKubernetes operations, V1Patch body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchPodSecurityPolicyWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1beta1ReplicaSetList ListReplicaSetForAllNamespaces2(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListReplicaSetForAllNamespaces2Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind ReplicaSet
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1ReplicaSetList> ListReplicaSetForAllNamespaces2Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListReplicaSetForAllNamespaces2WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIGroup GetAPIGroup12(this IKubernetes operations)
            {
                return operations.GetAPIGroup12Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIGroup> GetAPIGroup12Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIGroup12WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIResourceList GetAPIResources23(this IKubernetes operations)
            {
                return operations.GetAPIResources23Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIResourceList> GetAPIResources23Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIResources23WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind NetworkPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1NetworkPolicyList ListNamespacedNetworkPolicy1(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedNetworkPolicy1Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind NetworkPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1NetworkPolicyList> ListNamespacedNetworkPolicy1Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedNetworkPolicy1WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a NetworkPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1NetworkPolicy CreateNamespacedNetworkPolicy1(this IKubernetes operations, V1NetworkPolicy body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedNetworkPolicy1Async(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a NetworkPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1NetworkPolicy> CreateNamespacedNetworkPolicy1Async(this IKubernetes operations, V1NetworkPolicy body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedNetworkPolicy1WithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of NetworkPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedNetworkPolicy1(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedNetworkPolicy1Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of NetworkPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedNetworkPolicy1Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedNetworkPolicy1WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified NetworkPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the NetworkPolicy
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1NetworkPolicy ReadNamespacedNetworkPolicy1(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedNetworkPolicy1Async(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified NetworkPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the NetworkPolicy
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1NetworkPolicy> ReadNamespacedNetworkPolicy1Async(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedNetworkPolicy1WithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified NetworkPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the NetworkPolicy
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1NetworkPolicy ReplaceNamespacedNetworkPolicy1(this IKubernetes operations, V1NetworkPolicy body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedNetworkPolicy1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified NetworkPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the NetworkPolicy
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1NetworkPolicy> ReplaceNamespacedNetworkPolicy1Async(this IKubernetes operations, V1NetworkPolicy body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedNetworkPolicy1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a NetworkPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the NetworkPolicy
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedNetworkPolicy1(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedNetworkPolicy1Async(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a NetworkPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the NetworkPolicy
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedNetworkPolicy1Async(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedNetworkPolicy1WithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified NetworkPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the NetworkPolicy
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1NetworkPolicy PatchNamespacedNetworkPolicy1(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedNetworkPolicy1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified NetworkPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the NetworkPolicy
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1NetworkPolicy> PatchNamespacedNetworkPolicy1Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedNetworkPolicy1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind NetworkPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1NetworkPolicyList ListNetworkPolicyForAllNamespaces1(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListNetworkPolicyForAllNamespaces1Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind NetworkPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1NetworkPolicyList> ListNetworkPolicyForAllNamespaces1Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNetworkPolicyForAllNamespaces1WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIGroup GetAPIGroup13(this IKubernetes operations)
            {
                return operations.GetAPIGroup13Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIGroup> GetAPIGroup13Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIGroup13WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIResourceList GetAPIResources24(this IKubernetes operations)
            {
                return operations.GetAPIResources24Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIResourceList> GetAPIResources24Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIResources24WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind PodDisruptionBudget
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1PodDisruptionBudgetList ListNamespacedPodDisruptionBudget(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedPodDisruptionBudgetAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind PodDisruptionBudget
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1PodDisruptionBudgetList> ListNamespacedPodDisruptionBudgetAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedPodDisruptionBudgetWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a PodDisruptionBudget
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1PodDisruptionBudget CreateNamespacedPodDisruptionBudget(this IKubernetes operations, V1beta1PodDisruptionBudget body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedPodDisruptionBudgetAsync(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a PodDisruptionBudget
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1PodDisruptionBudget> CreateNamespacedPodDisruptionBudgetAsync(this IKubernetes operations, V1beta1PodDisruptionBudget body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedPodDisruptionBudgetWithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of PodDisruptionBudget
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedPodDisruptionBudget(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedPodDisruptionBudgetAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of PodDisruptionBudget
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedPodDisruptionBudgetAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedPodDisruptionBudgetWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified PodDisruptionBudget
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodDisruptionBudget
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1PodDisruptionBudget ReadNamespacedPodDisruptionBudget(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedPodDisruptionBudgetAsync(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified PodDisruptionBudget
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodDisruptionBudget
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1PodDisruptionBudget> ReadNamespacedPodDisruptionBudgetAsync(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedPodDisruptionBudgetWithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified PodDisruptionBudget
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PodDisruptionBudget
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1PodDisruptionBudget ReplaceNamespacedPodDisruptionBudget(this IKubernetes operations, V1beta1PodDisruptionBudget body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedPodDisruptionBudgetAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified PodDisruptionBudget
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PodDisruptionBudget
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1PodDisruptionBudget> ReplaceNamespacedPodDisruptionBudgetAsync(this IKubernetes operations, V1beta1PodDisruptionBudget body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedPodDisruptionBudgetWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a PodDisruptionBudget
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PodDisruptionBudget
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedPodDisruptionBudget(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedPodDisruptionBudgetAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a PodDisruptionBudget
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PodDisruptionBudget
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedPodDisruptionBudgetAsync(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedPodDisruptionBudgetWithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified PodDisruptionBudget
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PodDisruptionBudget
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1PodDisruptionBudget PatchNamespacedPodDisruptionBudget(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedPodDisruptionBudgetAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified PodDisruptionBudget
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PodDisruptionBudget
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1PodDisruptionBudget> PatchNamespacedPodDisruptionBudgetAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedPodDisruptionBudgetWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified PodDisruptionBudget
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodDisruptionBudget
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1PodDisruptionBudget ReadNamespacedPodDisruptionBudgetStatus(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedPodDisruptionBudgetStatusAsync(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified PodDisruptionBudget
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodDisruptionBudget
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1PodDisruptionBudget> ReadNamespacedPodDisruptionBudgetStatusAsync(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedPodDisruptionBudgetStatusWithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the specified PodDisruptionBudget
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PodDisruptionBudget
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1PodDisruptionBudget ReplaceNamespacedPodDisruptionBudgetStatus(this IKubernetes operations, V1beta1PodDisruptionBudget body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedPodDisruptionBudgetStatusAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the specified PodDisruptionBudget
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PodDisruptionBudget
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1PodDisruptionBudget> ReplaceNamespacedPodDisruptionBudgetStatusAsync(this IKubernetes operations, V1beta1PodDisruptionBudget body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedPodDisruptionBudgetStatusWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified PodDisruptionBudget
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PodDisruptionBudget
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1PodDisruptionBudget PatchNamespacedPodDisruptionBudgetStatus(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedPodDisruptionBudgetStatusAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified PodDisruptionBudget
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PodDisruptionBudget
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1PodDisruptionBudget> PatchNamespacedPodDisruptionBudgetStatusAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedPodDisruptionBudgetStatusWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind PodDisruptionBudget
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1beta1PodDisruptionBudgetList ListPodDisruptionBudgetForAllNamespaces(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListPodDisruptionBudgetForAllNamespacesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind PodDisruptionBudget
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1PodDisruptionBudgetList> ListPodDisruptionBudgetForAllNamespacesAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListPodDisruptionBudgetForAllNamespacesWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind PodSecurityPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Policyv1beta1PodSecurityPolicyList ListPodSecurityPolicy1(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListPodSecurityPolicy1Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind PodSecurityPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Policyv1beta1PodSecurityPolicyList> ListPodSecurityPolicy1Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListPodSecurityPolicy1WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a PodSecurityPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Policyv1beta1PodSecurityPolicy CreatePodSecurityPolicy1(this IKubernetes operations, Policyv1beta1PodSecurityPolicy body, string pretty = default(string))
            {
                return operations.CreatePodSecurityPolicy1Async(body, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a PodSecurityPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Policyv1beta1PodSecurityPolicy> CreatePodSecurityPolicy1Async(this IKubernetes operations, Policyv1beta1PodSecurityPolicy body, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreatePodSecurityPolicy1WithHttpMessagesAsync(body, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of PodSecurityPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionPodSecurityPolicy1(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionPodSecurityPolicy1Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of PodSecurityPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionPodSecurityPolicy1Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionPodSecurityPolicy1WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified PodSecurityPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodSecurityPolicy
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Policyv1beta1PodSecurityPolicy ReadPodSecurityPolicy1(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadPodSecurityPolicy1Async(name, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified PodSecurityPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodSecurityPolicy
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Policyv1beta1PodSecurityPolicy> ReadPodSecurityPolicy1Async(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadPodSecurityPolicy1WithHttpMessagesAsync(name, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified PodSecurityPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PodSecurityPolicy
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Policyv1beta1PodSecurityPolicy ReplacePodSecurityPolicy1(this IKubernetes operations, Policyv1beta1PodSecurityPolicy body, string name, string pretty = default(string))
            {
                return operations.ReplacePodSecurityPolicy1Async(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified PodSecurityPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PodSecurityPolicy
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Policyv1beta1PodSecurityPolicy> ReplacePodSecurityPolicy1Async(this IKubernetes operations, Policyv1beta1PodSecurityPolicy body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplacePodSecurityPolicy1WithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a PodSecurityPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PodSecurityPolicy
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeletePodSecurityPolicy1(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeletePodSecurityPolicy1Async(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a PodSecurityPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PodSecurityPolicy
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeletePodSecurityPolicy1Async(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeletePodSecurityPolicy1WithHttpMessagesAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified PodSecurityPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PodSecurityPolicy
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static Policyv1beta1PodSecurityPolicy PatchPodSecurityPolicy1(this IKubernetes operations, V1Patch body, string name, string pretty = default(string))
            {
                return operations.PatchPodSecurityPolicy1Async(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified PodSecurityPolicy
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PodSecurityPolicy
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Policyv1beta1PodSecurityPolicy> PatchPodSecurityPolicy1Async(this IKubernetes operations, V1Patch body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchPodSecurityPolicy1WithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIGroup GetAPIGroup14(this IKubernetes operations)
            {
                return operations.GetAPIGroup14Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIGroup> GetAPIGroup14Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIGroup14WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIResourceList GetAPIResources25(this IKubernetes operations)
            {
                return operations.GetAPIResources25Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIResourceList> GetAPIResources25Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIResources25WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ClusterRoleBindingList ListClusterRoleBinding(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListClusterRoleBindingAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ClusterRoleBindingList> ListClusterRoleBindingAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListClusterRoleBindingWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ClusterRoleBinding CreateClusterRoleBinding(this IKubernetes operations, V1ClusterRoleBinding body, string pretty = default(string))
            {
                return operations.CreateClusterRoleBindingAsync(body, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ClusterRoleBinding> CreateClusterRoleBindingAsync(this IKubernetes operations, V1ClusterRoleBinding body, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateClusterRoleBindingWithHttpMessagesAsync(body, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionClusterRoleBinding(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionClusterRoleBindingAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionClusterRoleBindingAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionClusterRoleBindingWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRoleBinding
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ClusterRoleBinding ReadClusterRoleBinding(this IKubernetes operations, string name, string pretty = default(string))
            {
                return operations.ReadClusterRoleBindingAsync(name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRoleBinding
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ClusterRoleBinding> ReadClusterRoleBindingAsync(this IKubernetes operations, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadClusterRoleBindingWithHttpMessagesAsync(name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRoleBinding
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ClusterRoleBinding ReplaceClusterRoleBinding(this IKubernetes operations, V1ClusterRoleBinding body, string name, string pretty = default(string))
            {
                return operations.ReplaceClusterRoleBindingAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRoleBinding
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ClusterRoleBinding> ReplaceClusterRoleBindingAsync(this IKubernetes operations, V1ClusterRoleBinding body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceClusterRoleBindingWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRoleBinding
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteClusterRoleBinding(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteClusterRoleBindingAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRoleBinding
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteClusterRoleBindingAsync(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteClusterRoleBindingWithHttpMessagesAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRoleBinding
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ClusterRoleBinding PatchClusterRoleBinding(this IKubernetes operations, V1Patch body, string name, string pretty = default(string))
            {
                return operations.PatchClusterRoleBindingAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRoleBinding
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ClusterRoleBinding> PatchClusterRoleBindingAsync(this IKubernetes operations, V1Patch body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchClusterRoleBindingWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ClusterRoleList ListClusterRole(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListClusterRoleAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ClusterRoleList> ListClusterRoleAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListClusterRoleWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ClusterRole CreateClusterRole(this IKubernetes operations, V1ClusterRole body, string pretty = default(string))
            {
                return operations.CreateClusterRoleAsync(body, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ClusterRole> CreateClusterRoleAsync(this IKubernetes operations, V1ClusterRole body, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateClusterRoleWithHttpMessagesAsync(body, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionClusterRole(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionClusterRoleAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionClusterRoleAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionClusterRoleWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRole
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ClusterRole ReadClusterRole(this IKubernetes operations, string name, string pretty = default(string))
            {
                return operations.ReadClusterRoleAsync(name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRole
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ClusterRole> ReadClusterRoleAsync(this IKubernetes operations, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadClusterRoleWithHttpMessagesAsync(name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRole
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ClusterRole ReplaceClusterRole(this IKubernetes operations, V1ClusterRole body, string name, string pretty = default(string))
            {
                return operations.ReplaceClusterRoleAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRole
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ClusterRole> ReplaceClusterRoleAsync(this IKubernetes operations, V1ClusterRole body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceClusterRoleWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRole
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteClusterRole(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteClusterRoleAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRole
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteClusterRoleAsync(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteClusterRoleWithHttpMessagesAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRole
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1ClusterRole PatchClusterRole(this IKubernetes operations, V1Patch body, string name, string pretty = default(string))
            {
                return operations.PatchClusterRoleAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRole
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1ClusterRole> PatchClusterRoleAsync(this IKubernetes operations, V1Patch body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchClusterRoleWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1RoleBindingList ListNamespacedRoleBinding(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedRoleBindingAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1RoleBindingList> ListNamespacedRoleBindingAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedRoleBindingWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1RoleBinding CreateNamespacedRoleBinding(this IKubernetes operations, V1RoleBinding body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedRoleBindingAsync(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1RoleBinding> CreateNamespacedRoleBindingAsync(this IKubernetes operations, V1RoleBinding body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedRoleBindingWithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedRoleBinding(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedRoleBindingAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedRoleBindingAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedRoleBindingWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the RoleBinding
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1RoleBinding ReadNamespacedRoleBinding(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedRoleBindingAsync(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the RoleBinding
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1RoleBinding> ReadNamespacedRoleBindingAsync(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedRoleBindingWithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the RoleBinding
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1RoleBinding ReplaceNamespacedRoleBinding(this IKubernetes operations, V1RoleBinding body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedRoleBindingAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the RoleBinding
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1RoleBinding> ReplaceNamespacedRoleBindingAsync(this IKubernetes operations, V1RoleBinding body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedRoleBindingWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the RoleBinding
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedRoleBinding(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedRoleBindingAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the RoleBinding
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedRoleBindingAsync(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedRoleBindingWithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the RoleBinding
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1RoleBinding PatchNamespacedRoleBinding(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedRoleBindingAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the RoleBinding
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1RoleBinding> PatchNamespacedRoleBindingAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedRoleBindingWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1RoleList ListNamespacedRole(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedRoleAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1RoleList> ListNamespacedRoleAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedRoleWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Role CreateNamespacedRole(this IKubernetes operations, V1Role body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedRoleAsync(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Role> CreateNamespacedRoleAsync(this IKubernetes operations, V1Role body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedRoleWithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedRole(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedRoleAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedRoleAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedRoleWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Role
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Role ReadNamespacedRole(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedRoleAsync(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Role
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Role> ReadNamespacedRoleAsync(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedRoleWithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Role
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Role ReplaceNamespacedRole(this IKubernetes operations, V1Role body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedRoleAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Role
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Role> ReplaceNamespacedRoleAsync(this IKubernetes operations, V1Role body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedRoleWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Role
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedRole(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedRoleAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Role
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedRoleAsync(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedRoleWithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Role
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Role PatchNamespacedRole(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedRoleAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Role
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Role> PatchNamespacedRoleAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedRoleWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1RoleBindingList ListRoleBindingForAllNamespaces(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListRoleBindingForAllNamespacesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1RoleBindingList> ListRoleBindingForAllNamespacesAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListRoleBindingForAllNamespacesWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1RoleList ListRoleForAllNamespaces(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListRoleForAllNamespacesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1RoleList> ListRoleForAllNamespacesAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListRoleForAllNamespacesWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIResourceList GetAPIResources26(this IKubernetes operations)
            {
                return operations.GetAPIResources26Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIResourceList> GetAPIResources26Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIResources26WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1ClusterRoleBindingList ListClusterRoleBinding1(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListClusterRoleBinding1Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1ClusterRoleBindingList> ListClusterRoleBinding1Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListClusterRoleBinding1WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1ClusterRoleBinding CreateClusterRoleBinding1(this IKubernetes operations, V1alpha1ClusterRoleBinding body, string pretty = default(string))
            {
                return operations.CreateClusterRoleBinding1Async(body, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1ClusterRoleBinding> CreateClusterRoleBinding1Async(this IKubernetes operations, V1alpha1ClusterRoleBinding body, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateClusterRoleBinding1WithHttpMessagesAsync(body, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionClusterRoleBinding1(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionClusterRoleBinding1Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionClusterRoleBinding1Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionClusterRoleBinding1WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRoleBinding
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1ClusterRoleBinding ReadClusterRoleBinding1(this IKubernetes operations, string name, string pretty = default(string))
            {
                return operations.ReadClusterRoleBinding1Async(name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRoleBinding
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1ClusterRoleBinding> ReadClusterRoleBinding1Async(this IKubernetes operations, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadClusterRoleBinding1WithHttpMessagesAsync(name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRoleBinding
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1ClusterRoleBinding ReplaceClusterRoleBinding1(this IKubernetes operations, V1alpha1ClusterRoleBinding body, string name, string pretty = default(string))
            {
                return operations.ReplaceClusterRoleBinding1Async(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRoleBinding
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1ClusterRoleBinding> ReplaceClusterRoleBinding1Async(this IKubernetes operations, V1alpha1ClusterRoleBinding body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceClusterRoleBinding1WithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRoleBinding
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteClusterRoleBinding1(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteClusterRoleBinding1Async(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRoleBinding
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteClusterRoleBinding1Async(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteClusterRoleBinding1WithHttpMessagesAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRoleBinding
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1ClusterRoleBinding PatchClusterRoleBinding1(this IKubernetes operations, V1Patch body, string name, string pretty = default(string))
            {
                return operations.PatchClusterRoleBinding1Async(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRoleBinding
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1ClusterRoleBinding> PatchClusterRoleBinding1Async(this IKubernetes operations, V1Patch body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchClusterRoleBinding1WithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1ClusterRoleList ListClusterRole1(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListClusterRole1Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1ClusterRoleList> ListClusterRole1Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListClusterRole1WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1ClusterRole CreateClusterRole1(this IKubernetes operations, V1alpha1ClusterRole body, string pretty = default(string))
            {
                return operations.CreateClusterRole1Async(body, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1ClusterRole> CreateClusterRole1Async(this IKubernetes operations, V1alpha1ClusterRole body, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateClusterRole1WithHttpMessagesAsync(body, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionClusterRole1(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionClusterRole1Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionClusterRole1Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionClusterRole1WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRole
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1ClusterRole ReadClusterRole1(this IKubernetes operations, string name, string pretty = default(string))
            {
                return operations.ReadClusterRole1Async(name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRole
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1ClusterRole> ReadClusterRole1Async(this IKubernetes operations, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadClusterRole1WithHttpMessagesAsync(name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRole
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1ClusterRole ReplaceClusterRole1(this IKubernetes operations, V1alpha1ClusterRole body, string name, string pretty = default(string))
            {
                return operations.ReplaceClusterRole1Async(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRole
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1ClusterRole> ReplaceClusterRole1Async(this IKubernetes operations, V1alpha1ClusterRole body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceClusterRole1WithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRole
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteClusterRole1(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteClusterRole1Async(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRole
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteClusterRole1Async(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteClusterRole1WithHttpMessagesAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRole
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1ClusterRole PatchClusterRole1(this IKubernetes operations, V1Patch body, string name, string pretty = default(string))
            {
                return operations.PatchClusterRole1Async(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRole
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1ClusterRole> PatchClusterRole1Async(this IKubernetes operations, V1Patch body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchClusterRole1WithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1RoleBindingList ListNamespacedRoleBinding1(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedRoleBinding1Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1RoleBindingList> ListNamespacedRoleBinding1Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedRoleBinding1WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1RoleBinding CreateNamespacedRoleBinding1(this IKubernetes operations, V1alpha1RoleBinding body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedRoleBinding1Async(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1RoleBinding> CreateNamespacedRoleBinding1Async(this IKubernetes operations, V1alpha1RoleBinding body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedRoleBinding1WithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedRoleBinding1(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedRoleBinding1Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedRoleBinding1Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedRoleBinding1WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the RoleBinding
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1RoleBinding ReadNamespacedRoleBinding1(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedRoleBinding1Async(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the RoleBinding
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1RoleBinding> ReadNamespacedRoleBinding1Async(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedRoleBinding1WithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the RoleBinding
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1RoleBinding ReplaceNamespacedRoleBinding1(this IKubernetes operations, V1alpha1RoleBinding body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedRoleBinding1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the RoleBinding
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1RoleBinding> ReplaceNamespacedRoleBinding1Async(this IKubernetes operations, V1alpha1RoleBinding body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedRoleBinding1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the RoleBinding
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedRoleBinding1(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedRoleBinding1Async(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the RoleBinding
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedRoleBinding1Async(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedRoleBinding1WithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the RoleBinding
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1RoleBinding PatchNamespacedRoleBinding1(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedRoleBinding1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the RoleBinding
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1RoleBinding> PatchNamespacedRoleBinding1Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedRoleBinding1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1RoleList ListNamespacedRole1(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedRole1Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1RoleList> ListNamespacedRole1Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedRole1WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1Role CreateNamespacedRole1(this IKubernetes operations, V1alpha1Role body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedRole1Async(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1Role> CreateNamespacedRole1Async(this IKubernetes operations, V1alpha1Role body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedRole1WithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedRole1(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedRole1Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedRole1Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedRole1WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Role
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1Role ReadNamespacedRole1(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedRole1Async(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Role
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1Role> ReadNamespacedRole1Async(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedRole1WithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Role
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1Role ReplaceNamespacedRole1(this IKubernetes operations, V1alpha1Role body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedRole1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Role
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1Role> ReplaceNamespacedRole1Async(this IKubernetes operations, V1alpha1Role body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedRole1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Role
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedRole1(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedRole1Async(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Role
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedRole1Async(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedRole1WithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Role
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1Role PatchNamespacedRole1(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedRole1Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Role
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1Role> PatchNamespacedRole1Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedRole1WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1alpha1RoleBindingList ListRoleBindingForAllNamespaces1(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListRoleBindingForAllNamespaces1Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1RoleBindingList> ListRoleBindingForAllNamespaces1Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListRoleBindingForAllNamespaces1WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1alpha1RoleList ListRoleForAllNamespaces1(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListRoleForAllNamespaces1Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1RoleList> ListRoleForAllNamespaces1Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListRoleForAllNamespaces1WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIResourceList GetAPIResources27(this IKubernetes operations)
            {
                return operations.GetAPIResources27Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIResourceList> GetAPIResources27Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIResources27WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1ClusterRoleBindingList ListClusterRoleBinding2(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListClusterRoleBinding2Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1ClusterRoleBindingList> ListClusterRoleBinding2Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListClusterRoleBinding2WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1ClusterRoleBinding CreateClusterRoleBinding2(this IKubernetes operations, V1beta1ClusterRoleBinding body, string pretty = default(string))
            {
                return operations.CreateClusterRoleBinding2Async(body, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1ClusterRoleBinding> CreateClusterRoleBinding2Async(this IKubernetes operations, V1beta1ClusterRoleBinding body, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateClusterRoleBinding2WithHttpMessagesAsync(body, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionClusterRoleBinding2(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionClusterRoleBinding2Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionClusterRoleBinding2Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionClusterRoleBinding2WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRoleBinding
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1ClusterRoleBinding ReadClusterRoleBinding2(this IKubernetes operations, string name, string pretty = default(string))
            {
                return operations.ReadClusterRoleBinding2Async(name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRoleBinding
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1ClusterRoleBinding> ReadClusterRoleBinding2Async(this IKubernetes operations, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadClusterRoleBinding2WithHttpMessagesAsync(name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRoleBinding
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1ClusterRoleBinding ReplaceClusterRoleBinding2(this IKubernetes operations, V1beta1ClusterRoleBinding body, string name, string pretty = default(string))
            {
                return operations.ReplaceClusterRoleBinding2Async(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRoleBinding
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1ClusterRoleBinding> ReplaceClusterRoleBinding2Async(this IKubernetes operations, V1beta1ClusterRoleBinding body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceClusterRoleBinding2WithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRoleBinding
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteClusterRoleBinding2(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteClusterRoleBinding2Async(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRoleBinding
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteClusterRoleBinding2Async(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteClusterRoleBinding2WithHttpMessagesAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRoleBinding
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1ClusterRoleBinding PatchClusterRoleBinding2(this IKubernetes operations, V1Patch body, string name, string pretty = default(string))
            {
                return operations.PatchClusterRoleBinding2Async(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified ClusterRoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRoleBinding
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1ClusterRoleBinding> PatchClusterRoleBinding2Async(this IKubernetes operations, V1Patch body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchClusterRoleBinding2WithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1ClusterRoleList ListClusterRole2(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListClusterRole2Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1ClusterRoleList> ListClusterRole2Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListClusterRole2WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1ClusterRole CreateClusterRole2(this IKubernetes operations, V1beta1ClusterRole body, string pretty = default(string))
            {
                return operations.CreateClusterRole2Async(body, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1ClusterRole> CreateClusterRole2Async(this IKubernetes operations, V1beta1ClusterRole body, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateClusterRole2WithHttpMessagesAsync(body, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionClusterRole2(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionClusterRole2Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionClusterRole2Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionClusterRole2WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRole
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1ClusterRole ReadClusterRole2(this IKubernetes operations, string name, string pretty = default(string))
            {
                return operations.ReadClusterRole2Async(name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRole
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1ClusterRole> ReadClusterRole2Async(this IKubernetes operations, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadClusterRole2WithHttpMessagesAsync(name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRole
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1ClusterRole ReplaceClusterRole2(this IKubernetes operations, V1beta1ClusterRole body, string name, string pretty = default(string))
            {
                return operations.ReplaceClusterRole2Async(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRole
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1ClusterRole> ReplaceClusterRole2Async(this IKubernetes operations, V1beta1ClusterRole body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceClusterRole2WithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRole
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteClusterRole2(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteClusterRole2Async(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRole
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteClusterRole2Async(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteClusterRole2WithHttpMessagesAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRole
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1ClusterRole PatchClusterRole2(this IKubernetes operations, V1Patch body, string name, string pretty = default(string))
            {
                return operations.PatchClusterRole2Async(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified ClusterRole
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the ClusterRole
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1ClusterRole> PatchClusterRole2Async(this IKubernetes operations, V1Patch body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchClusterRole2WithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1RoleBindingList ListNamespacedRoleBinding2(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedRoleBinding2Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1RoleBindingList> ListNamespacedRoleBinding2Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedRoleBinding2WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1RoleBinding CreateNamespacedRoleBinding2(this IKubernetes operations, V1beta1RoleBinding body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedRoleBinding2Async(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1RoleBinding> CreateNamespacedRoleBinding2Async(this IKubernetes operations, V1beta1RoleBinding body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedRoleBinding2WithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedRoleBinding2(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedRoleBinding2Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedRoleBinding2Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedRoleBinding2WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the RoleBinding
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1RoleBinding ReadNamespacedRoleBinding2(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedRoleBinding2Async(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the RoleBinding
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1RoleBinding> ReadNamespacedRoleBinding2Async(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedRoleBinding2WithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the RoleBinding
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1RoleBinding ReplaceNamespacedRoleBinding2(this IKubernetes operations, V1beta1RoleBinding body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedRoleBinding2Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the RoleBinding
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1RoleBinding> ReplaceNamespacedRoleBinding2Async(this IKubernetes operations, V1beta1RoleBinding body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedRoleBinding2WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the RoleBinding
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedRoleBinding2(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedRoleBinding2Async(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the RoleBinding
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedRoleBinding2Async(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedRoleBinding2WithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the RoleBinding
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1RoleBinding PatchNamespacedRoleBinding2(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedRoleBinding2Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the RoleBinding
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1RoleBinding> PatchNamespacedRoleBinding2Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedRoleBinding2WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1RoleList ListNamespacedRole2(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedRole2Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1RoleList> ListNamespacedRole2Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedRole2WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1Role CreateNamespacedRole2(this IKubernetes operations, V1beta1Role body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedRole2Async(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1Role> CreateNamespacedRole2Async(this IKubernetes operations, V1beta1Role body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedRole2WithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedRole2(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedRole2Async(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedRole2Async(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedRole2WithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Role
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1Role ReadNamespacedRole2(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReadNamespacedRole2Async(name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the Role
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1Role> ReadNamespacedRole2Async(this IKubernetes operations, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedRole2WithHttpMessagesAsync(name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Role
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1Role ReplaceNamespacedRole2(this IKubernetes operations, V1beta1Role body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedRole2Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Role
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1Role> ReplaceNamespacedRole2Async(this IKubernetes operations, V1beta1Role body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedRole2WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Role
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedRole2(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedRole2Async(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Role
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedRole2Async(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedRole2WithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Role
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1Role PatchNamespacedRole2(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedRole2Async(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the Role
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1Role> PatchNamespacedRole2Async(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedRole2WithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1beta1RoleBindingList ListRoleBindingForAllNamespaces2(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListRoleBindingForAllNamespaces2Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind RoleBinding
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1RoleBindingList> ListRoleBindingForAllNamespaces2Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListRoleBindingForAllNamespaces2WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1beta1RoleList ListRoleForAllNamespaces2(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListRoleForAllNamespaces2Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind Role
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1RoleList> ListRoleForAllNamespaces2Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListRoleForAllNamespaces2WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIGroup GetAPIGroup15(this IKubernetes operations)
            {
                return operations.GetAPIGroup15Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIGroup> GetAPIGroup15Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIGroup15WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIResourceList GetAPIResources28(this IKubernetes operations)
            {
                return operations.GetAPIResources28Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIResourceList> GetAPIResources28Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIResources28WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind PriorityClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1PriorityClassList ListPriorityClass(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListPriorityClassAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind PriorityClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1PriorityClassList> ListPriorityClassAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListPriorityClassWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a PriorityClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1PriorityClass CreatePriorityClass(this IKubernetes operations, V1alpha1PriorityClass body, string pretty = default(string))
            {
                return operations.CreatePriorityClassAsync(body, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a PriorityClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1PriorityClass> CreatePriorityClassAsync(this IKubernetes operations, V1alpha1PriorityClass body, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreatePriorityClassWithHttpMessagesAsync(body, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of PriorityClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionPriorityClass(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionPriorityClassAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of PriorityClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionPriorityClassAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionPriorityClassWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified PriorityClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PriorityClass
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1PriorityClass ReadPriorityClass(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadPriorityClassAsync(name, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified PriorityClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PriorityClass
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1PriorityClass> ReadPriorityClassAsync(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadPriorityClassWithHttpMessagesAsync(name, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified PriorityClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PriorityClass
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1PriorityClass ReplacePriorityClass(this IKubernetes operations, V1alpha1PriorityClass body, string name, string pretty = default(string))
            {
                return operations.ReplacePriorityClassAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified PriorityClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PriorityClass
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1PriorityClass> ReplacePriorityClassAsync(this IKubernetes operations, V1alpha1PriorityClass body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplacePriorityClassWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a PriorityClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PriorityClass
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeletePriorityClass(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeletePriorityClassAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a PriorityClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PriorityClass
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeletePriorityClassAsync(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeletePriorityClassWithHttpMessagesAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified PriorityClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PriorityClass
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1PriorityClass PatchPriorityClass(this IKubernetes operations, V1Patch body, string name, string pretty = default(string))
            {
                return operations.PatchPriorityClassAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified PriorityClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PriorityClass
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1PriorityClass> PatchPriorityClassAsync(this IKubernetes operations, V1Patch body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchPriorityClassWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIResourceList GetAPIResources29(this IKubernetes operations)
            {
                return operations.GetAPIResources29Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIResourceList> GetAPIResources29Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIResources29WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind PriorityClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1PriorityClassList ListPriorityClass1(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListPriorityClass1Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind PriorityClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1PriorityClassList> ListPriorityClass1Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListPriorityClass1WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a PriorityClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1PriorityClass CreatePriorityClass1(this IKubernetes operations, V1beta1PriorityClass body, string pretty = default(string))
            {
                return operations.CreatePriorityClass1Async(body, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a PriorityClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1PriorityClass> CreatePriorityClass1Async(this IKubernetes operations, V1beta1PriorityClass body, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreatePriorityClass1WithHttpMessagesAsync(body, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of PriorityClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionPriorityClass1(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionPriorityClass1Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of PriorityClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionPriorityClass1Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionPriorityClass1WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified PriorityClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PriorityClass
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1PriorityClass ReadPriorityClass1(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadPriorityClass1Async(name, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified PriorityClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PriorityClass
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1PriorityClass> ReadPriorityClass1Async(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadPriorityClass1WithHttpMessagesAsync(name, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified PriorityClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PriorityClass
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1PriorityClass ReplacePriorityClass1(this IKubernetes operations, V1beta1PriorityClass body, string name, string pretty = default(string))
            {
                return operations.ReplacePriorityClass1Async(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified PriorityClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PriorityClass
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1PriorityClass> ReplacePriorityClass1Async(this IKubernetes operations, V1beta1PriorityClass body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplacePriorityClass1WithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a PriorityClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PriorityClass
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeletePriorityClass1(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeletePriorityClass1Async(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a PriorityClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PriorityClass
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeletePriorityClass1Async(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeletePriorityClass1WithHttpMessagesAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified PriorityClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PriorityClass
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1PriorityClass PatchPriorityClass1(this IKubernetes operations, V1Patch body, string name, string pretty = default(string))
            {
                return operations.PatchPriorityClass1Async(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified PriorityClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PriorityClass
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1PriorityClass> PatchPriorityClass1Async(this IKubernetes operations, V1Patch body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchPriorityClass1WithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIGroup GetAPIGroup16(this IKubernetes operations)
            {
                return operations.GetAPIGroup16Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIGroup> GetAPIGroup16Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIGroup16WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIResourceList GetAPIResources30(this IKubernetes operations)
            {
                return operations.GetAPIResources30Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIResourceList> GetAPIResources30Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIResources30WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind PodPreset
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1PodPresetList ListNamespacedPodPreset(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedPodPresetAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind PodPreset
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1PodPresetList> ListNamespacedPodPresetAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedPodPresetWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a PodPreset
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1PodPreset CreateNamespacedPodPreset(this IKubernetes operations, V1alpha1PodPreset body, string namespaceParameter, string pretty = default(string))
            {
                return operations.CreateNamespacedPodPresetAsync(body, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a PodPreset
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1PodPreset> CreateNamespacedPodPresetAsync(this IKubernetes operations, V1alpha1PodPreset body, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedPodPresetWithHttpMessagesAsync(body, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of PodPreset
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionNamespacedPodPreset(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionNamespacedPodPresetAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of PodPreset
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionNamespacedPodPresetAsync(this IKubernetes operations, string namespaceParameter, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionNamespacedPodPresetWithHttpMessagesAsync(namespaceParameter, continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified PodPreset
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodPreset
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1PodPreset ReadNamespacedPodPreset(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadNamespacedPodPresetAsync(name, namespaceParameter, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified PodPreset
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the PodPreset
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1PodPreset> ReadNamespacedPodPresetAsync(this IKubernetes operations, string name, string namespaceParameter, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadNamespacedPodPresetWithHttpMessagesAsync(name, namespaceParameter, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified PodPreset
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PodPreset
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1PodPreset ReplaceNamespacedPodPreset(this IKubernetes operations, V1alpha1PodPreset body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.ReplaceNamespacedPodPresetAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified PodPreset
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PodPreset
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1PodPreset> ReplaceNamespacedPodPresetAsync(this IKubernetes operations, V1alpha1PodPreset body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedPodPresetWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a PodPreset
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PodPreset
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteNamespacedPodPreset(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteNamespacedPodPresetAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a PodPreset
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PodPreset
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteNamespacedPodPresetAsync(this IKubernetes operations, V1DeleteOptions body, string name, string namespaceParameter, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedPodPresetWithHttpMessagesAsync(body, name, namespaceParameter, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified PodPreset
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PodPreset
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1PodPreset PatchNamespacedPodPreset(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string))
            {
                return operations.PatchNamespacedPodPresetAsync(body, name, namespaceParameter, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified PodPreset
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the PodPreset
            /// </param>
            /// <param name='namespaceParameter'>
            /// object name and auth scope, such as for teams and projects
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1PodPreset> PatchNamespacedPodPresetAsync(this IKubernetes operations, V1Patch body, string name, string namespaceParameter, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedPodPresetWithHttpMessagesAsync(body, name, namespaceParameter, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind PodPreset
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            public static V1alpha1PodPresetList ListPodPresetForAllNamespaces(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
            {
                return operations.ListPodPresetForAllNamespacesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind PodPreset
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1PodPresetList> ListPodPresetForAllNamespacesAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string pretty = default(string), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListPodPresetForAllNamespacesWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIGroup GetAPIGroup17(this IKubernetes operations)
            {
                return operations.GetAPIGroup17Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get information of a group
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIGroup> GetAPIGroup17Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIGroup17WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIResourceList GetAPIResources31(this IKubernetes operations)
            {
                return operations.GetAPIResources31Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIResourceList> GetAPIResources31Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIResources31WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind StorageClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1StorageClassList ListStorageClass(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListStorageClassAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind StorageClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1StorageClassList> ListStorageClassAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListStorageClassWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a StorageClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1StorageClass CreateStorageClass(this IKubernetes operations, V1StorageClass body, string pretty = default(string))
            {
                return operations.CreateStorageClassAsync(body, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a StorageClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1StorageClass> CreateStorageClassAsync(this IKubernetes operations, V1StorageClass body, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateStorageClassWithHttpMessagesAsync(body, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of StorageClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionStorageClass(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionStorageClassAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of StorageClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionStorageClassAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionStorageClassWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified StorageClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the StorageClass
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1StorageClass ReadStorageClass(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadStorageClassAsync(name, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified StorageClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the StorageClass
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1StorageClass> ReadStorageClassAsync(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadStorageClassWithHttpMessagesAsync(name, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified StorageClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StorageClass
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1StorageClass ReplaceStorageClass(this IKubernetes operations, V1StorageClass body, string name, string pretty = default(string))
            {
                return operations.ReplaceStorageClassAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified StorageClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StorageClass
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1StorageClass> ReplaceStorageClassAsync(this IKubernetes operations, V1StorageClass body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceStorageClassWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a StorageClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StorageClass
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteStorageClass(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteStorageClassAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a StorageClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StorageClass
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteStorageClassAsync(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteStorageClassWithHttpMessagesAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified StorageClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StorageClass
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1StorageClass PatchStorageClass(this IKubernetes operations, V1Patch body, string name, string pretty = default(string))
            {
                return operations.PatchStorageClassAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified StorageClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StorageClass
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1StorageClass> PatchStorageClassAsync(this IKubernetes operations, V1Patch body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchStorageClassWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIResourceList GetAPIResources32(this IKubernetes operations)
            {
                return operations.GetAPIResources32Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIResourceList> GetAPIResources32Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIResources32WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind VolumeAttachment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1VolumeAttachmentList ListVolumeAttachment(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListVolumeAttachmentAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind VolumeAttachment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1VolumeAttachmentList> ListVolumeAttachmentAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListVolumeAttachmentWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a VolumeAttachment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1VolumeAttachment CreateVolumeAttachment(this IKubernetes operations, V1alpha1VolumeAttachment body, string pretty = default(string))
            {
                return operations.CreateVolumeAttachmentAsync(body, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a VolumeAttachment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1VolumeAttachment> CreateVolumeAttachmentAsync(this IKubernetes operations, V1alpha1VolumeAttachment body, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateVolumeAttachmentWithHttpMessagesAsync(body, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of VolumeAttachment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionVolumeAttachment(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionVolumeAttachmentAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of VolumeAttachment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionVolumeAttachmentAsync(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionVolumeAttachmentWithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified VolumeAttachment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the VolumeAttachment
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1VolumeAttachment ReadVolumeAttachment(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadVolumeAttachmentAsync(name, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified VolumeAttachment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the VolumeAttachment
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1VolumeAttachment> ReadVolumeAttachmentAsync(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadVolumeAttachmentWithHttpMessagesAsync(name, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified VolumeAttachment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the VolumeAttachment
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1VolumeAttachment ReplaceVolumeAttachment(this IKubernetes operations, V1alpha1VolumeAttachment body, string name, string pretty = default(string))
            {
                return operations.ReplaceVolumeAttachmentAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified VolumeAttachment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the VolumeAttachment
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1VolumeAttachment> ReplaceVolumeAttachmentAsync(this IKubernetes operations, V1alpha1VolumeAttachment body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceVolumeAttachmentWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a VolumeAttachment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the VolumeAttachment
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteVolumeAttachment(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteVolumeAttachmentAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a VolumeAttachment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the VolumeAttachment
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteVolumeAttachmentAsync(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteVolumeAttachmentWithHttpMessagesAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified VolumeAttachment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the VolumeAttachment
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1alpha1VolumeAttachment PatchVolumeAttachment(this IKubernetes operations, V1Patch body, string name, string pretty = default(string))
            {
                return operations.PatchVolumeAttachmentAsync(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified VolumeAttachment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the VolumeAttachment
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1alpha1VolumeAttachment> PatchVolumeAttachmentAsync(this IKubernetes operations, V1Patch body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchVolumeAttachmentWithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static V1APIResourceList GetAPIResources33(this IKubernetes operations)
            {
                return operations.GetAPIResources33Async().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get available resources
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1APIResourceList> GetAPIResources33Async(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetAPIResources33WithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind StorageClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1StorageClassList ListStorageClass1(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListStorageClass1Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind StorageClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1StorageClassList> ListStorageClass1Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListStorageClass1WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a StorageClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1StorageClass CreateStorageClass1(this IKubernetes operations, V1beta1StorageClass body, string pretty = default(string))
            {
                return operations.CreateStorageClass1Async(body, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a StorageClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1StorageClass> CreateStorageClass1Async(this IKubernetes operations, V1beta1StorageClass body, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateStorageClass1WithHttpMessagesAsync(body, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of StorageClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionStorageClass1(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionStorageClass1Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of StorageClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionStorageClass1Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionStorageClass1WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified StorageClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the StorageClass
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1StorageClass ReadStorageClass1(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadStorageClass1Async(name, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified StorageClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the StorageClass
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1StorageClass> ReadStorageClass1Async(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadStorageClass1WithHttpMessagesAsync(name, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified StorageClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StorageClass
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1StorageClass ReplaceStorageClass1(this IKubernetes operations, V1beta1StorageClass body, string name, string pretty = default(string))
            {
                return operations.ReplaceStorageClass1Async(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified StorageClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StorageClass
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1StorageClass> ReplaceStorageClass1Async(this IKubernetes operations, V1beta1StorageClass body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceStorageClass1WithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a StorageClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StorageClass
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteStorageClass1(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteStorageClass1Async(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a StorageClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StorageClass
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteStorageClass1Async(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteStorageClass1WithHttpMessagesAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified StorageClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StorageClass
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1StorageClass PatchStorageClass1(this IKubernetes operations, V1Patch body, string name, string pretty = default(string))
            {
                return operations.PatchStorageClass1Async(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified StorageClass
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the StorageClass
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1StorageClass> PatchStorageClass1Async(this IKubernetes operations, V1Patch body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchStorageClass1WithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch objects of kind VolumeAttachment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1VolumeAttachmentList ListVolumeAttachment1(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListVolumeAttachment1Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch objects of kind VolumeAttachment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1VolumeAttachmentList> ListVolumeAttachment1Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListVolumeAttachment1WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// create a VolumeAttachment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1VolumeAttachment CreateVolumeAttachment1(this IKubernetes operations, V1beta1VolumeAttachment body, string pretty = default(string))
            {
                return operations.CreateVolumeAttachment1Async(body, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// create a VolumeAttachment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1VolumeAttachment> CreateVolumeAttachment1Async(this IKubernetes operations, V1beta1VolumeAttachment body, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateVolumeAttachment1WithHttpMessagesAsync(body, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete collection of VolumeAttachment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteCollectionVolumeAttachment1(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.DeleteCollectionVolumeAttachment1Async(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete collection of VolumeAttachment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='continueParameter'>
            /// The continue option should be set when retrieving more results from the
            /// server. Since this value is server defined, clients may only use the
            /// continue value from a previous query result with identical query parameters
            /// (except for the value of continue) and the server may reject a continue
            /// value it does not recognize. If the specified continue value is no longer
            /// valid whether due to expiration (generally five to fifteen minutes) or a
            /// configuration change on the server, the server will respond with a 410
            /// ResourceExpired error together with a continue token. If the client needs a
            /// consistent list, it must restart their list without the continue field.
            /// Otherwise, the client may send another list request with the token received
            /// with the 410 error, the server will respond with a list starting from the
            /// next key, but from the latest snapshot, which is inconsistent from the
            /// previous list results - objects that are created, modified, or deleted
            /// after the first list request will be included in the response, as long as
            /// their keys are after the "next key".
            ///
            /// This field is not supported when watch is true. Clients may start a watch
            /// from the last resourceVersion value returned by the server and not miss any
            /// modifications.
            /// </param>
            /// <param name='fieldSelector'>
            /// A selector to restrict the list of returned objects by their fields.
            /// Defaults to everything.
            /// </param>
            /// <param name='includeUninitialized'>
            /// If true, partially initialized resources are included in the response.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='limit'>
            /// limit is a maximum number of responses to return for a list call. If more
            /// items exist, the server will set the `continue` field on the list metadata
            /// to a value that can be used with the same initial query to retrieve the
            /// next set of results. Setting a limit may return fewer than the requested
            /// amount of items (up to zero items) in the event all requested objects are
            /// filtered out and clients should only use the presence of the continue field
            /// to determine whether more results are available. Servers may choose not to
            /// support the limit argument and will return all of the available results. If
            /// limit is specified and the continue field is empty, clients may assume that
            /// no more results are available. This field is not supported if watch is
            /// true.
            ///
            /// The server guarantees that the objects returned when using continue will be
            /// identical to issuing a single list call without a limit - that is, no
            /// objects created, modified, or deleted after the first request is issued
            /// will be included in any subsequent continued requests. This is sometimes
            /// referred to as a consistent snapshot, and ensures that a client that is
            /// using limit to receive smaller chunks of a very large result can ensure
            /// they see all possible objects. If objects are updated during a chunked list
            /// the version of the object that was present at the time the first list
            /// result was calculated is returned.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='timeoutSeconds'>
            /// Timeout for the list/watch call. This limits the duration of the call,
            /// regardless of any activity or inactivity.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications. Specify resourceVersion.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteCollectionVolumeAttachment1Async(this IKubernetes operations, string continueParameter = default(string), string fieldSelector = default(string), bool? includeUninitialized = default(bool?), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteCollectionVolumeAttachment1WithHttpMessagesAsync(continueParameter, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read the specified VolumeAttachment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the VolumeAttachment
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1VolumeAttachment ReadVolumeAttachment1(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string))
            {
                return operations.ReadVolumeAttachment1Async(name, exact, export, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read the specified VolumeAttachment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='name'>
            /// name of the VolumeAttachment
            /// </param>
            /// <param name='exact'>
            /// Should the export be exact.  Exact export maintains cluster-specific fields
            /// like 'Namespace'.
            /// </param>
            /// <param name='export'>
            /// Should this value be exported.  Export strips fields that a user can not
            /// specify.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1VolumeAttachment> ReadVolumeAttachment1Async(this IKubernetes operations, string name, bool? exact = default(bool?), bool? export = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReadVolumeAttachment1WithHttpMessagesAsync(name, exact, export, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified VolumeAttachment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the VolumeAttachment
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1VolumeAttachment ReplaceVolumeAttachment1(this IKubernetes operations, V1beta1VolumeAttachment body, string name, string pretty = default(string))
            {
                return operations.ReplaceVolumeAttachment1Async(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified VolumeAttachment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the VolumeAttachment
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1VolumeAttachment> ReplaceVolumeAttachment1Async(this IKubernetes operations, V1beta1VolumeAttachment body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceVolumeAttachment1WithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// delete a VolumeAttachment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the VolumeAttachment
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1Status DeleteVolumeAttachment1(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string))
            {
                return operations.DeleteVolumeAttachment1Async(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// delete a VolumeAttachment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the VolumeAttachment
            /// </param>
            /// <param name='dryRun'>
            /// When present, indicates that modifications should not be persisted. An
            /// invalid or unrecognized dryRun directive will result in an error response
            /// and no further processing of the request. Valid values are: - All: all dry
            /// run stages will be processed
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy. Acceptable values are: 'Orphan' - orphan
            /// the dependents; 'Background' - allow the garbage collector to delete the
            /// dependents in the background; 'Foreground' - a cascading policy that
            /// deletes all dependents in the foreground.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1Status> DeleteVolumeAttachment1Async(this IKubernetes operations, V1DeleteOptions body, string name, string dryRun = default(string), int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteVolumeAttachment1WithHttpMessagesAsync(body, name, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update the specified VolumeAttachment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the VolumeAttachment
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static V1beta1VolumeAttachment PatchVolumeAttachment1(this IKubernetes operations, V1Patch body, string name, string pretty = default(string))
            {
                return operations.PatchVolumeAttachment1Async(body, name, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update the specified VolumeAttachment
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='name'>
            /// name of the VolumeAttachment
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<V1beta1VolumeAttachment> PatchVolumeAttachment1Async(this IKubernetes operations, V1Patch body, string name, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchVolumeAttachment1WithHttpMessagesAsync(body, name, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static void LogFileListHandler(this IKubernetes operations)
            {
                operations.LogFileListHandlerAsync().GetAwaiter().GetResult();
            }

            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task LogFileListHandlerAsync(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                (await operations.LogFileListHandlerWithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false)).Dispose();
            }

            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='logpath'>
            /// path to the log
            /// </param>
            public static void LogFileHandler(this IKubernetes operations, string logpath)
            {
                operations.LogFileHandlerAsync(logpath).GetAwaiter().GetResult();
            }

            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='logpath'>
            /// path to the log
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task LogFileHandlerAsync(this IKubernetes operations, string logpath, CancellationToken cancellationToken = default(CancellationToken))
            {
                (await operations.LogFileHandlerWithHttpMessagesAsync(logpath, null, cancellationToken).ConfigureAwait(false)).Dispose();
            }

            /// <summary>
            /// get the code version
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            public static VersionInfo GetCode(this IKubernetes operations)
            {
                return operations.GetCodeAsync().GetAwaiter().GetResult();
            }

            /// <summary>
            /// get the code version
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<VersionInfo> GetCodeAsync(this IKubernetes operations, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetCodeWithHttpMessagesAsync(null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// Creates a namespace scoped Custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// The JSON schema of the Resource to create.
            /// </param>
            /// <param name='group'>
            /// The custom resource's group name
            /// </param>
            /// <param name='version'>
            /// The custom resource's version
            /// </param>
            /// <param name='namespaceParameter'>
            /// The custom resource's namespace
            /// </param>
            /// <param name='plural'>
            /// The custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static object CreateNamespacedCustomObject(this IKubernetes operations, object body, string group, string version, string namespaceParameter, string plural, string pretty = default(string))
            {
                return operations.CreateNamespacedCustomObjectAsync(body, group, version, namespaceParameter, plural, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// Creates a namespace scoped Custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// The JSON schema of the Resource to create.
            /// </param>
            /// <param name='group'>
            /// The custom resource's group name
            /// </param>
            /// <param name='version'>
            /// The custom resource's version
            /// </param>
            /// <param name='namespaceParameter'>
            /// The custom resource's namespace
            /// </param>
            /// <param name='plural'>
            /// The custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<object> CreateNamespacedCustomObjectAsync(this IKubernetes operations, object body, string group, string version, string namespaceParameter, string plural, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateNamespacedCustomObjectWithHttpMessagesAsync(body, group, version, namespaceParameter, plural, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch namespace scoped custom objects
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='group'>
            /// The custom resource's group name
            /// </param>
            /// <param name='version'>
            /// The custom resource's version
            /// </param>
            /// <param name='namespaceParameter'>
            /// The custom resource's namespace
            /// </param>
            /// <param name='plural'>
            /// The custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static object ListNamespacedCustomObject(this IKubernetes operations, string group, string version, string namespaceParameter, string plural, string labelSelector = default(string), string resourceVersion = default(string), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListNamespacedCustomObjectAsync(group, version, namespaceParameter, plural, labelSelector, resourceVersion, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch namespace scoped custom objects
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='group'>
            /// The custom resource's group name
            /// </param>
            /// <param name='version'>
            /// The custom resource's version
            /// </param>
            /// <param name='namespaceParameter'>
            /// The custom resource's namespace
            /// </param>
            /// <param name='plural'>
            /// The custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<object> ListNamespacedCustomObjectAsync(this IKubernetes operations, string group, string version, string namespaceParameter, string plural, string labelSelector = default(string), string resourceVersion = default(string), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListNamespacedCustomObjectWithHttpMessagesAsync(group, version, namespaceParameter, plural, labelSelector, resourceVersion, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// Creates a cluster scoped Custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// The JSON schema of the Resource to create.
            /// </param>
            /// <param name='group'>
            /// The custom resource's group name
            /// </param>
            /// <param name='version'>
            /// The custom resource's version
            /// </param>
            /// <param name='plural'>
            /// The custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static object CreateClusterCustomObject(this IKubernetes operations, object body, string group, string version, string plural, string pretty = default(string))
            {
                return operations.CreateClusterCustomObjectAsync(body, group, version, plural, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// Creates a cluster scoped Custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// The JSON schema of the Resource to create.
            /// </param>
            /// <param name='group'>
            /// The custom resource's group name
            /// </param>
            /// <param name='version'>
            /// The custom resource's version
            /// </param>
            /// <param name='plural'>
            /// The custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<object> CreateClusterCustomObjectAsync(this IKubernetes operations, object body, string group, string version, string plural, string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.CreateClusterCustomObjectWithHttpMessagesAsync(body, group, version, plural, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// list or watch cluster scoped custom objects
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='group'>
            /// The custom resource's group name
            /// </param>
            /// <param name='version'>
            /// The custom resource's version
            /// </param>
            /// <param name='plural'>
            /// The custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            public static object ListClusterCustomObject(this IKubernetes operations, string group, string version, string plural, string labelSelector = default(string), string resourceVersion = default(string), bool? watch = default(bool?), string pretty = default(string))
            {
                return operations.ListClusterCustomObjectAsync(group, version, plural, labelSelector, resourceVersion, watch, pretty).GetAwaiter().GetResult();
            }

            /// <summary>
            /// list or watch cluster scoped custom objects
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='group'>
            /// The custom resource's group name
            /// </param>
            /// <param name='version'>
            /// The custom resource's version
            /// </param>
            /// <param name='plural'>
            /// The custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='labelSelector'>
            /// A selector to restrict the list of returned objects by their labels.
            /// Defaults to everything.
            /// </param>
            /// <param name='resourceVersion'>
            /// When specified with a watch call, shows changes that occur after that
            /// particular version of a resource. Defaults to changes from the beginning of
            /// history. When specified for list: - if unset, then the result is returned
            /// from remote storage based on quorum-read flag; - if it's 0, then we simply
            /// return what we currently have in cache, no guarantee; - if set to non zero,
            /// then the result is at least as fresh as given rv.
            /// </param>
            /// <param name='watch'>
            /// Watch for changes to the described resources and return them as a stream of
            /// add, update, and remove notifications.
            /// </param>
            /// <param name='pretty'>
            /// If 'true', then the output is pretty printed.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<object> ListClusterCustomObjectAsync(this IKubernetes operations, string group, string version, string plural, string labelSelector = default(string), string resourceVersion = default(string), bool? watch = default(bool?), string pretty = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ListClusterCustomObjectWithHttpMessagesAsync(group, version, plural, labelSelector, resourceVersion, watch, pretty, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the cluster scoped specified custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='plural'>
            /// the custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            public static object ReplaceClusterCustomObjectStatus(this IKubernetes operations, object body, string group, string version, string plural, string name)
            {
                return operations.ReplaceClusterCustomObjectStatusAsync(body, group, version, plural, name).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the cluster scoped specified custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='plural'>
            /// the custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<object> ReplaceClusterCustomObjectStatusAsync(this IKubernetes operations, object body, string group, string version, string plural, string name, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceClusterCustomObjectStatusWithHttpMessagesAsync(body, group, version, plural, name, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified cluster scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='plural'>
            /// the custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            public static object PatchClusterCustomObjectStatus(this IKubernetes operations, object body, string group, string version, string plural, string name)
            {
                return operations.PatchClusterCustomObjectStatusAsync(body, group, version, plural, name).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified cluster scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='plural'>
            /// the custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<object> PatchClusterCustomObjectStatusAsync(this IKubernetes operations, object body, string group, string version, string plural, string name, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchClusterCustomObjectStatusWithHttpMessagesAsync(body, group, version, plural, name, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified cluster scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='plural'>
            /// the custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            public static object GetClusterCustomObjectStatus(this IKubernetes operations, string group, string version, string plural, string name)
            {
                return operations.GetClusterCustomObjectStatusAsync(group, version, plural, name).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified cluster scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='plural'>
            /// the custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<object> GetClusterCustomObjectStatusAsync(this IKubernetes operations, string group, string version, string plural, string name, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetClusterCustomObjectStatusWithHttpMessagesAsync(group, version, plural, name, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified namespace scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// The JSON schema of the Resource to replace.
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='namespaceParameter'>
            /// The custom resource's namespace
            /// </param>
            /// <param name='plural'>
            /// the custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            public static object ReplaceNamespacedCustomObject(this IKubernetes operations, object body, string group, string version, string namespaceParameter, string plural, string name)
            {
                return operations.ReplaceNamespacedCustomObjectAsync(body, group, version, namespaceParameter, plural, name).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified namespace scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// The JSON schema of the Resource to replace.
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='namespaceParameter'>
            /// The custom resource's namespace
            /// </param>
            /// <param name='plural'>
            /// the custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<object> ReplaceNamespacedCustomObjectAsync(this IKubernetes operations, object body, string group, string version, string namespaceParameter, string plural, string name, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedCustomObjectWithHttpMessagesAsync(body, group, version, namespaceParameter, plural, name, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// patch the specified namespace scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// The JSON schema of the Resource to patch.
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='namespaceParameter'>
            /// The custom resource's namespace
            /// </param>
            /// <param name='plural'>
            /// the custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            public static object PatchNamespacedCustomObject(this IKubernetes operations, object body, string group, string version, string namespaceParameter, string plural, string name)
            {
                return operations.PatchNamespacedCustomObjectAsync(body, group, version, namespaceParameter, plural, name).GetAwaiter().GetResult();
            }

            /// <summary>
            /// patch the specified namespace scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// The JSON schema of the Resource to patch.
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='namespaceParameter'>
            /// The custom resource's namespace
            /// </param>
            /// <param name='plural'>
            /// the custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<object> PatchNamespacedCustomObjectAsync(this IKubernetes operations, object body, string group, string version, string namespaceParameter, string plural, string name, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedCustomObjectWithHttpMessagesAsync(body, group, version, namespaceParameter, plural, name, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// Deletes the specified namespace scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='namespaceParameter'>
            /// The custom resource's namespace
            /// </param>
            /// <param name='plural'>
            /// the custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy.
            /// </param>
            public static object DeleteNamespacedCustomObject(this IKubernetes operations, V1DeleteOptions body, string group, string version, string namespaceParameter, string plural, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string))
            {
                return operations.DeleteNamespacedCustomObjectAsync(body, group, version, namespaceParameter, plural, name, gracePeriodSeconds, orphanDependents, propagationPolicy).GetAwaiter().GetResult();
            }

            /// <summary>
            /// Deletes the specified namespace scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='namespaceParameter'>
            /// The custom resource's namespace
            /// </param>
            /// <param name='plural'>
            /// the custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<object> DeleteNamespacedCustomObjectAsync(this IKubernetes operations, V1DeleteOptions body, string group, string version, string namespaceParameter, string plural, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteNamespacedCustomObjectWithHttpMessagesAsync(body, group, version, namespaceParameter, plural, name, gracePeriodSeconds, orphanDependents, propagationPolicy, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// Returns a namespace scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='namespaceParameter'>
            /// The custom resource's namespace
            /// </param>
            /// <param name='plural'>
            /// the custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            public static object GetNamespacedCustomObject(this IKubernetes operations, string group, string version, string namespaceParameter, string plural, string name)
            {
                return operations.GetNamespacedCustomObjectAsync(group, version, namespaceParameter, plural, name).GetAwaiter().GetResult();
            }

            /// <summary>
            /// Returns a namespace scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='namespaceParameter'>
            /// The custom resource's namespace
            /// </param>
            /// <param name='plural'>
            /// the custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<object> GetNamespacedCustomObjectAsync(this IKubernetes operations, string group, string version, string namespaceParameter, string plural, string name, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetNamespacedCustomObjectWithHttpMessagesAsync(group, version, namespaceParameter, plural, name, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace scale of the specified namespace scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='namespaceParameter'>
            /// The custom resource's namespace
            /// </param>
            /// <param name='plural'>
            /// the custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            public static object ReplaceNamespacedCustomObjectScale(this IKubernetes operations, object body, string group, string version, string namespaceParameter, string plural, string name)
            {
                return operations.ReplaceNamespacedCustomObjectScaleAsync(body, group, version, namespaceParameter, plural, name).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace scale of the specified namespace scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='namespaceParameter'>
            /// The custom resource's namespace
            /// </param>
            /// <param name='plural'>
            /// the custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<object> ReplaceNamespacedCustomObjectScaleAsync(this IKubernetes operations, object body, string group, string version, string namespaceParameter, string plural, string name, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedCustomObjectScaleWithHttpMessagesAsync(body, group, version, namespaceParameter, plural, name, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update scale of the specified namespace scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='namespaceParameter'>
            /// The custom resource's namespace
            /// </param>
            /// <param name='plural'>
            /// the custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            public static object PatchNamespacedCustomObjectScale(this IKubernetes operations, object body, string group, string version, string namespaceParameter, string plural, string name)
            {
                return operations.PatchNamespacedCustomObjectScaleAsync(body, group, version, namespaceParameter, plural, name).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update scale of the specified namespace scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='namespaceParameter'>
            /// The custom resource's namespace
            /// </param>
            /// <param name='plural'>
            /// the custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<object> PatchNamespacedCustomObjectScaleAsync(this IKubernetes operations, object body, string group, string version, string namespaceParameter, string plural, string name, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedCustomObjectScaleWithHttpMessagesAsync(body, group, version, namespaceParameter, plural, name, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read scale of the specified namespace scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='namespaceParameter'>
            /// The custom resource's namespace
            /// </param>
            /// <param name='plural'>
            /// the custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            public static object GetNamespacedCustomObjectScale(this IKubernetes operations, string group, string version, string namespaceParameter, string plural, string name)
            {
                return operations.GetNamespacedCustomObjectScaleAsync(group, version, namespaceParameter, plural, name).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read scale of the specified namespace scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='namespaceParameter'>
            /// The custom resource's namespace
            /// </param>
            /// <param name='plural'>
            /// the custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<object> GetNamespacedCustomObjectScaleAsync(this IKubernetes operations, string group, string version, string namespaceParameter, string plural, string name, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetNamespacedCustomObjectScaleWithHttpMessagesAsync(group, version, namespaceParameter, plural, name, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace scale of the specified cluster scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='plural'>
            /// the custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            public static object ReplaceClusterCustomObjectScale(this IKubernetes operations, object body, string group, string version, string plural, string name)
            {
                return operations.ReplaceClusterCustomObjectScaleAsync(body, group, version, plural, name).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace scale of the specified cluster scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='plural'>
            /// the custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<object> ReplaceClusterCustomObjectScaleAsync(this IKubernetes operations, object body, string group, string version, string plural, string name, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceClusterCustomObjectScaleWithHttpMessagesAsync(body, group, version, plural, name, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update scale of the specified cluster scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='plural'>
            /// the custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            public static object PatchClusterCustomObjectScale(this IKubernetes operations, object body, string group, string version, string plural, string name)
            {
                return operations.PatchClusterCustomObjectScaleAsync(body, group, version, plural, name).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update scale of the specified cluster scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='plural'>
            /// the custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<object> PatchClusterCustomObjectScaleAsync(this IKubernetes operations, object body, string group, string version, string plural, string name, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchClusterCustomObjectScaleWithHttpMessagesAsync(body, group, version, plural, name, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read scale of the specified custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='plural'>
            /// the custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            public static object GetClusterCustomObjectScale(this IKubernetes operations, string group, string version, string plural, string name)
            {
                return operations.GetClusterCustomObjectScaleAsync(group, version, plural, name).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read scale of the specified custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='plural'>
            /// the custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<object> GetClusterCustomObjectScaleAsync(this IKubernetes operations, string group, string version, string plural, string name, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetClusterCustomObjectScaleWithHttpMessagesAsync(group, version, plural, name, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace the specified cluster scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// The JSON schema of the Resource to replace.
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='plural'>
            /// the custom object's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            public static object ReplaceClusterCustomObject(this IKubernetes operations, object body, string group, string version, string plural, string name)
            {
                return operations.ReplaceClusterCustomObjectAsync(body, group, version, plural, name).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace the specified cluster scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// The JSON schema of the Resource to replace.
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='plural'>
            /// the custom object's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<object> ReplaceClusterCustomObjectAsync(this IKubernetes operations, object body, string group, string version, string plural, string name, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceClusterCustomObjectWithHttpMessagesAsync(body, group, version, plural, name, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// patch the specified cluster scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// The JSON schema of the Resource to patch.
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='plural'>
            /// the custom object's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            public static object PatchClusterCustomObject(this IKubernetes operations, object body, string group, string version, string plural, string name)
            {
                return operations.PatchClusterCustomObjectAsync(body, group, version, plural, name).GetAwaiter().GetResult();
            }

            /// <summary>
            /// patch the specified cluster scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// The JSON schema of the Resource to patch.
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='plural'>
            /// the custom object's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<object> PatchClusterCustomObjectAsync(this IKubernetes operations, object body, string group, string version, string plural, string name, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchClusterCustomObjectWithHttpMessagesAsync(body, group, version, plural, name, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// Deletes the specified cluster scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='plural'>
            /// the custom object's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy.
            /// </param>
            public static object DeleteClusterCustomObject(this IKubernetes operations, V1DeleteOptions body, string group, string version, string plural, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string))
            {
                return operations.DeleteClusterCustomObjectAsync(body, group, version, plural, name, gracePeriodSeconds, orphanDependents, propagationPolicy).GetAwaiter().GetResult();
            }

            /// <summary>
            /// Deletes the specified cluster scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='plural'>
            /// the custom object's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            /// <param name='gracePeriodSeconds'>
            /// The duration in seconds before the object should be deleted. Value must be
            /// non-negative integer. The value zero indicates delete immediately. If this
            /// value is nil, the default grace period for the specified type will be used.
            /// Defaults to a per object value if not specified. zero means delete
            /// immediately.
            /// </param>
            /// <param name='orphanDependents'>
            /// Deprecated: please use the PropagationPolicy, this field will be deprecated
            /// in 1.7. Should the dependent objects be orphaned. If true/false, the
            /// "orphan" finalizer will be added to/removed from the object's finalizers
            /// list. Either this field or PropagationPolicy may be set, but not both.
            /// </param>
            /// <param name='propagationPolicy'>
            /// Whether and how garbage collection will be performed. Either this field or
            /// OrphanDependents may be set, but not both. The default policy is decided by
            /// the existing finalizer set in the metadata.finalizers and the
            /// resource-specific default policy.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<object> DeleteClusterCustomObjectAsync(this IKubernetes operations, V1DeleteOptions body, string group, string version, string plural, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.DeleteClusterCustomObjectWithHttpMessagesAsync(body, group, version, plural, name, gracePeriodSeconds, orphanDependents, propagationPolicy, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// Returns a cluster scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='plural'>
            /// the custom object's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            public static object GetClusterCustomObject(this IKubernetes operations, string group, string version, string plural, string name)
            {
                return operations.GetClusterCustomObjectAsync(group, version, plural, name).GetAwaiter().GetResult();
            }

            /// <summary>
            /// Returns a cluster scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='plural'>
            /// the custom object's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<object> GetClusterCustomObjectAsync(this IKubernetes operations, string group, string version, string plural, string name, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetClusterCustomObjectWithHttpMessagesAsync(group, version, plural, name, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// replace status of the specified namespace scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='namespaceParameter'>
            /// The custom resource's namespace
            /// </param>
            /// <param name='plural'>
            /// the custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            public static object ReplaceNamespacedCustomObjectStatus(this IKubernetes operations, object body, string group, string version, string namespaceParameter, string plural, string name)
            {
                return operations.ReplaceNamespacedCustomObjectStatusAsync(body, group, version, namespaceParameter, plural, name).GetAwaiter().GetResult();
            }

            /// <summary>
            /// replace status of the specified namespace scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='namespaceParameter'>
            /// The custom resource's namespace
            /// </param>
            /// <param name='plural'>
            /// the custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<object> ReplaceNamespacedCustomObjectStatusAsync(this IKubernetes operations, object body, string group, string version, string namespaceParameter, string plural, string name, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ReplaceNamespacedCustomObjectStatusWithHttpMessagesAsync(body, group, version, namespaceParameter, plural, name, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// partially update status of the specified namespace scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='namespaceParameter'>
            /// The custom resource's namespace
            /// </param>
            /// <param name='plural'>
            /// the custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            public static object PatchNamespacedCustomObjectStatus(this IKubernetes operations, object body, string group, string version, string namespaceParameter, string plural, string name)
            {
                return operations.PatchNamespacedCustomObjectStatusAsync(body, group, version, namespaceParameter, plural, name).GetAwaiter().GetResult();
            }

            /// <summary>
            /// partially update status of the specified namespace scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='body'>
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='namespaceParameter'>
            /// The custom resource's namespace
            /// </param>
            /// <param name='plural'>
            /// the custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<object> PatchNamespacedCustomObjectStatusAsync(this IKubernetes operations, object body, string group, string version, string namespaceParameter, string plural, string name, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.PatchNamespacedCustomObjectStatusWithHttpMessagesAsync(body, group, version, namespaceParameter, plural, name, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// read status of the specified namespace scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='namespaceParameter'>
            /// The custom resource's namespace
            /// </param>
            /// <param name='plural'>
            /// the custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            public static object GetNamespacedCustomObjectStatus(this IKubernetes operations, string group, string version, string namespaceParameter, string plural, string name)
            {
                return operations.GetNamespacedCustomObjectStatusAsync(group, version, namespaceParameter, plural, name).GetAwaiter().GetResult();
            }

            /// <summary>
            /// read status of the specified namespace scoped custom object
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='group'>
            /// the custom resource's group
            /// </param>
            /// <param name='version'>
            /// the custom resource's version
            /// </param>
            /// <param name='namespaceParameter'>
            /// The custom resource's namespace
            /// </param>
            /// <param name='plural'>
            /// the custom resource's plural name. For TPRs this would be lowercase plural
            /// kind.
            /// </param>
            /// <param name='name'>
            /// the custom object's name
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<object> GetNamespacedCustomObjectStatusAsync(this IKubernetes operations, string group, string version, string namespaceParameter, string plural, string name, CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.GetNamespacedCustomObjectStatusWithHttpMessagesAsync(group, version, namespaceParameter, plural, name, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

    }
}
