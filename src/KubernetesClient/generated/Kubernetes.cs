// <auto-generated>
// Code generated by https://github.com/kubernetes-client/csharp/tree/master/gen/KubernetesGenerator
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace k8s
{
    using Microsoft.Rest;
    using Models;
    using System.Collections.Generic;
    using System.IO;
    using System.Net;
    using System.Net.Http;
    using System.Threading;
    using System.Threading.Tasks;

    public partial class Kubernetes : ServiceClient<Kubernetes>, IKubernetes
    {
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<string>> GetServiceAccountIssuerOpenIDConfigurationWithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $".well-known/openid-configuration/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<string>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIVersions>> GetAPIVersionsWithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"api/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIVersions>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIGroupList>> GetAPIVersions1WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIGroupList>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIResourceList>> GetAPIResourcesWithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIResourceList>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources1WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/admissionregistration.k8s.io/v1/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIResourceList>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources2WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apiextensions.k8s.io/v1/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIResourceList>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources3WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apiregistration.k8s.io/v1/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIResourceList>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources4WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIResourceList>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources5WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/authentication.k8s.io/v1/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIResourceList>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources6WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/authorization.k8s.io/v1/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIResourceList>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources7WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v1/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIResourceList>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources8WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIResourceList>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources9WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2beta1/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIResourceList>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources10WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2beta2/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIResourceList>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources11WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIResourceList>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources12WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1beta1/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIResourceList>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources13WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/certificates.k8s.io/v1/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIResourceList>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources14WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/coordination.k8s.io/v1/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIResourceList>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources15WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/discovery.k8s.io/v1/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIResourceList>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources16WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/discovery.k8s.io/v1beta1/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIResourceList>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources17WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/events.k8s.io/v1/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIResourceList>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources18WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/events.k8s.io/v1beta1/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIResourceList>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources19WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta1/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIResourceList>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources20WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta2/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIResourceList>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources21WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/internal.apiserver.k8s.io/v1alpha1/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIResourceList>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources22WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/networking.k8s.io/v1/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIResourceList>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources23WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/node.k8s.io/v1/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIResourceList>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources24WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/node.k8s.io/v1alpha1/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIResourceList>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources25WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/node.k8s.io/v1beta1/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIResourceList>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources26WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/policy/v1/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIResourceList>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources27WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/policy/v1beta1/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIResourceList>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources28WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/rbac.authorization.k8s.io/v1/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIResourceList>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources29WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/scheduling.k8s.io/v1/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIResourceList>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources30WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIResourceList>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources31WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1alpha1/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIResourceList>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIResourceList>> GetAPIResources32WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1beta1/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIResourceList>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ComponentStatusList>> ListComponentStatusWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/componentstatuses").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ComponentStatusList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ComponentStatus>> ReadComponentStatusWithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/componentstatuses/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ComponentStatus>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ConfigMapList>> ListConfigMapForAllNamespacesWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/configmaps").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ConfigMapList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1EndpointsList>> ListEndpointsForAllNamespacesWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/endpoints").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1EndpointsList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Corev1EventList>> ListEventForAllNamespacesWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/events").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<Corev1EventList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Eventsv1EventList>> ListEventForAllNamespaces1WithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/events.k8s.io/v1/events").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<Eventsv1EventList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1EventList>> ListEventForAllNamespaces2WithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/events.k8s.io/v1beta1/events").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1EventList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1LimitRangeList>> ListLimitRangeForAllNamespacesWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/limitranges").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1LimitRangeList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1NamespaceList>> ListNamespaceWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1NamespaceList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Namespace>> CreateNamespaceWithHttpMessagesAsync(
            V1Namespace body,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Namespace>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Binding>> CreateNamespacedBindingWithHttpMessagesAsync(
            V1Binding body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/bindings").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Binding>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedConfigMapWithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/configmaps").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ConfigMapList>> ListNamespacedConfigMapWithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/configmaps").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ConfigMapList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ConfigMap>> CreateNamespacedConfigMapWithHttpMessagesAsync(
            V1ConfigMap body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/configmaps").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ConfigMap>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteNamespacedConfigMapWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/configmaps/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ConfigMap>> ReadNamespacedConfigMapWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/configmaps/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ConfigMap>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ConfigMap>> PatchNamespacedConfigMapWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/configmaps/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ConfigMap>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ConfigMap>> ReplaceNamespacedConfigMapWithHttpMessagesAsync(
            V1ConfigMap body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/configmaps/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ConfigMap>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedEndpointsWithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/endpoints").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1EndpointsList>> ListNamespacedEndpointsWithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/endpoints").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1EndpointsList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Endpoints>> CreateNamespacedEndpointsWithHttpMessagesAsync(
            V1Endpoints body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/endpoints").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Endpoints>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteNamespacedEndpointsWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/endpoints/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Endpoints>> ReadNamespacedEndpointsWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/endpoints/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Endpoints>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Endpoints>> PatchNamespacedEndpointsWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/endpoints/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Endpoints>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Endpoints>> ReplaceNamespacedEndpointsWithHttpMessagesAsync(
            V1Endpoints body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/endpoints/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Endpoints>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedEventWithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/events").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedEvent1WithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/events.k8s.io/v1/namespaces/{namespaceParameter}/events").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedEvent2WithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/events.k8s.io/v1beta1/namespaces/{namespaceParameter}/events").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Corev1EventList>> ListNamespacedEventWithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/events").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<Corev1EventList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Eventsv1EventList>> ListNamespacedEvent1WithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/events.k8s.io/v1/namespaces/{namespaceParameter}/events").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<Eventsv1EventList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1EventList>> ListNamespacedEvent2WithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/events.k8s.io/v1beta1/namespaces/{namespaceParameter}/events").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1EventList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Corev1Event>> CreateNamespacedEventWithHttpMessagesAsync(
            Corev1Event body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/events").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<Corev1Event>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Eventsv1Event>> CreateNamespacedEvent1WithHttpMessagesAsync(
            Eventsv1Event body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/events.k8s.io/v1/namespaces/{namespaceParameter}/events").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<Eventsv1Event>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1Event>> CreateNamespacedEvent2WithHttpMessagesAsync(
            V1beta1Event body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/events.k8s.io/v1beta1/namespaces/{namespaceParameter}/events").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1Event>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteNamespacedEventWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/events/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteNamespacedEvent1WithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/events.k8s.io/v1/namespaces/{namespaceParameter}/events/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteNamespacedEvent2WithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/events.k8s.io/v1beta1/namespaces/{namespaceParameter}/events/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Corev1Event>> ReadNamespacedEventWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/events/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<Corev1Event>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Eventsv1Event>> ReadNamespacedEvent1WithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/events.k8s.io/v1/namespaces/{namespaceParameter}/events/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<Eventsv1Event>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1Event>> ReadNamespacedEvent2WithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/events.k8s.io/v1beta1/namespaces/{namespaceParameter}/events/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1Event>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Corev1Event>> PatchNamespacedEventWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/events/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<Corev1Event>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Eventsv1Event>> PatchNamespacedEvent1WithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/events.k8s.io/v1/namespaces/{namespaceParameter}/events/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<Eventsv1Event>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1Event>> PatchNamespacedEvent2WithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/events.k8s.io/v1beta1/namespaces/{namespaceParameter}/events/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1Event>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Corev1Event>> ReplaceNamespacedEventWithHttpMessagesAsync(
            Corev1Event body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/events/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<Corev1Event>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Eventsv1Event>> ReplaceNamespacedEvent1WithHttpMessagesAsync(
            Eventsv1Event body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/events.k8s.io/v1/namespaces/{namespaceParameter}/events/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<Eventsv1Event>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1Event>> ReplaceNamespacedEvent2WithHttpMessagesAsync(
            V1beta1Event body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/events.k8s.io/v1beta1/namespaces/{namespaceParameter}/events/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1Event>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedLimitRangeWithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/limitranges").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1LimitRangeList>> ListNamespacedLimitRangeWithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/limitranges").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1LimitRangeList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1LimitRange>> CreateNamespacedLimitRangeWithHttpMessagesAsync(
            V1LimitRange body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/limitranges").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1LimitRange>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteNamespacedLimitRangeWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/limitranges/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1LimitRange>> ReadNamespacedLimitRangeWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/limitranges/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1LimitRange>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1LimitRange>> PatchNamespacedLimitRangeWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/limitranges/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1LimitRange>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1LimitRange>> ReplaceNamespacedLimitRangeWithHttpMessagesAsync(
            V1LimitRange body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/limitranges/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1LimitRange>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedPersistentVolumeClaimWithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/persistentvolumeclaims").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PersistentVolumeClaimList>> ListNamespacedPersistentVolumeClaimWithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/persistentvolumeclaims").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PersistentVolumeClaimList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PersistentVolumeClaim>> CreateNamespacedPersistentVolumeClaimWithHttpMessagesAsync(
            V1PersistentVolumeClaim body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/persistentvolumeclaims").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PersistentVolumeClaim>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PersistentVolumeClaim>> DeleteNamespacedPersistentVolumeClaimWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/persistentvolumeclaims/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PersistentVolumeClaim>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PersistentVolumeClaim>> ReadNamespacedPersistentVolumeClaimWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/persistentvolumeclaims/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PersistentVolumeClaim>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PersistentVolumeClaim>> PatchNamespacedPersistentVolumeClaimWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/persistentvolumeclaims/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PersistentVolumeClaim>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PersistentVolumeClaim>> ReplaceNamespacedPersistentVolumeClaimWithHttpMessagesAsync(
            V1PersistentVolumeClaim body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/persistentvolumeclaims/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PersistentVolumeClaim>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PersistentVolumeClaim>> ReadNamespacedPersistentVolumeClaimStatusWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/persistentvolumeclaims/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PersistentVolumeClaim>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PersistentVolumeClaim>> PatchNamespacedPersistentVolumeClaimStatusWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/persistentvolumeclaims/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PersistentVolumeClaim>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PersistentVolumeClaim>> ReplaceNamespacedPersistentVolumeClaimStatusWithHttpMessagesAsync(
            V1PersistentVolumeClaim body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/persistentvolumeclaims/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PersistentVolumeClaim>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedPodWithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/pods").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PodList>> ListNamespacedPodWithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/pods").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PodList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Pod>> CreateNamespacedPodWithHttpMessagesAsync(
            V1Pod body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/pods").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Pod>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Pod>> DeleteNamespacedPodWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/pods/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Pod>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Pod>> ReadNamespacedPodWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/pods/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Pod>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Pod>> PatchNamespacedPodWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/pods/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Pod>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Pod>> ReplaceNamespacedPodWithHttpMessagesAsync(
            V1Pod body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/pods/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Pod>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectGetNamespacedPodAttachWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            string container = null,
            bool? stderr = null,
            bool? stdin = null,
            bool? stdout = null,
            bool? tty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/pods/{name}/attach").ToString();
            var q = new QueryBuilder();
            q.Append("container", container);
            q.Append("stderr", stderr);
            q.Append("stdin", stdin);
            q.Append("stdout", stdout);
            q.Append("tty", tty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectPostNamespacedPodAttachWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            string container = null,
            bool? stderr = null,
            bool? stdin = null,
            bool? stdout = null,
            bool? tty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/pods/{name}/attach").ToString();
            var q = new QueryBuilder();
            q.Append("container", container);
            q.Append("stderr", stderr);
            q.Append("stdin", stdin);
            q.Append("stdout", stdout);
            q.Append("tty", tty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Binding>> CreateNamespacedPodBindingWithHttpMessagesAsync(
            V1Binding body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/pods/{name}/binding").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Binding>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Pod>> ReadNamespacedPodEphemeralcontainersWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/pods/{name}/ephemeralcontainers").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Pod>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Pod>> PatchNamespacedPodEphemeralcontainersWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/pods/{name}/ephemeralcontainers").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Pod>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Pod>> ReplaceNamespacedPodEphemeralcontainersWithHttpMessagesAsync(
            V1Pod body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/pods/{name}/ephemeralcontainers").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Pod>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Eviction>> CreateNamespacedPodEvictionWithHttpMessagesAsync(
            V1Eviction body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/pods/{name}/eviction").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Eviction>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectGetNamespacedPodExecWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            string command = null,
            string container = null,
            bool? stderr = null,
            bool? stdin = null,
            bool? stdout = null,
            bool? tty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/pods/{name}/exec").ToString();
            var q = new QueryBuilder();
            q.Append("command", command);
            q.Append("container", container);
            q.Append("stderr", stderr);
            q.Append("stdin", stdin);
            q.Append("stdout", stdout);
            q.Append("tty", tty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectPostNamespacedPodExecWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            string command = null,
            string container = null,
            bool? stderr = null,
            bool? stdin = null,
            bool? stdout = null,
            bool? tty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/pods/{name}/exec").ToString();
            var q = new QueryBuilder();
            q.Append("command", command);
            q.Append("container", container);
            q.Append("stderr", stderr);
            q.Append("stdin", stdin);
            q.Append("stdout", stdout);
            q.Append("tty", tty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ReadNamespacedPodLogWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            string container = null,
            bool? follow = null,
            bool? insecureSkipTLSVerifyBackend = null,
            int? limitBytes = null,
            bool? pretty = null,
            bool? previous = null,
            int? sinceSeconds = null,
            int? tailLines = null,
            bool? timestamps = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/pods/{name}/log").ToString();
            var q = new QueryBuilder();
            q.Append("container", container);
            q.Append("follow", follow);
            q.Append("insecureSkipTLSVerifyBackend", insecureSkipTLSVerifyBackend);
            q.Append("limitBytes", limitBytes);
            q.Append("pretty", pretty);
            q.Append("previous", previous);
            q.Append("sinceSeconds", sinceSeconds);
            q.Append("tailLines", tailLines);
            q.Append("timestamps", timestamps);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectGetNamespacedPodPortforwardWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            int? ports = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/pods/{name}/portforward").ToString();
            var q = new QueryBuilder();
            q.Append("ports", ports);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectPostNamespacedPodPortforwardWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            int? ports = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/pods/{name}/portforward").ToString();
            var q = new QueryBuilder();
            q.Append("ports", ports);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectDeleteNamespacedPodProxyWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            string path = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/pods/{name}/proxy").ToString();
            var q = new QueryBuilder();
            q.Append("path", path);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectGetNamespacedPodProxyWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            string path = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/pods/{name}/proxy").ToString();
            var q = new QueryBuilder();
            q.Append("path", path);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectHeadNamespacedPodProxyWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            string path = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/pods/{name}/proxy").ToString();
            var q = new QueryBuilder();
            q.Append("path", path);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Head, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectPatchNamespacedPodProxyWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            string path = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/pods/{name}/proxy").ToString();
            var q = new QueryBuilder();
            q.Append("path", path);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectPostNamespacedPodProxyWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            string path = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/pods/{name}/proxy").ToString();
            var q = new QueryBuilder();
            q.Append("path", path);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectPutNamespacedPodProxyWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            string path = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/pods/{name}/proxy").ToString();
            var q = new QueryBuilder();
            q.Append("path", path);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectDeleteNamespacedPodProxyWithPathWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            string path,
            string path1 = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }
            if (path == null)
            {
                throw new ArgumentNullException("path");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/pods/{name}/proxy/{path}").ToString();
            var q = new QueryBuilder();
            q.Append("path1", path1);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectGetNamespacedPodProxyWithPathWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            string path,
            string path1 = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }
            if (path == null)
            {
                throw new ArgumentNullException("path");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/pods/{name}/proxy/{path}").ToString();
            var q = new QueryBuilder();
            q.Append("path1", path1);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectHeadNamespacedPodProxyWithPathWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            string path,
            string path1 = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }
            if (path == null)
            {
                throw new ArgumentNullException("path");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/pods/{name}/proxy/{path}").ToString();
            var q = new QueryBuilder();
            q.Append("path1", path1);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Head, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectPatchNamespacedPodProxyWithPathWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            string path,
            string path1 = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }
            if (path == null)
            {
                throw new ArgumentNullException("path");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/pods/{name}/proxy/{path}").ToString();
            var q = new QueryBuilder();
            q.Append("path1", path1);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectPostNamespacedPodProxyWithPathWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            string path,
            string path1 = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }
            if (path == null)
            {
                throw new ArgumentNullException("path");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/pods/{name}/proxy/{path}").ToString();
            var q = new QueryBuilder();
            q.Append("path1", path1);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectPutNamespacedPodProxyWithPathWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            string path,
            string path1 = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }
            if (path == null)
            {
                throw new ArgumentNullException("path");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/pods/{name}/proxy/{path}").ToString();
            var q = new QueryBuilder();
            q.Append("path1", path1);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Pod>> ReadNamespacedPodStatusWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/pods/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Pod>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Pod>> PatchNamespacedPodStatusWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/pods/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Pod>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Pod>> ReplaceNamespacedPodStatusWithHttpMessagesAsync(
            V1Pod body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/pods/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Pod>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedPodTemplateWithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/podtemplates").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PodTemplateList>> ListNamespacedPodTemplateWithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/podtemplates").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PodTemplateList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PodTemplate>> CreateNamespacedPodTemplateWithHttpMessagesAsync(
            V1PodTemplate body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/podtemplates").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PodTemplate>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PodTemplate>> DeleteNamespacedPodTemplateWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/podtemplates/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PodTemplate>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PodTemplate>> ReadNamespacedPodTemplateWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/podtemplates/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PodTemplate>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PodTemplate>> PatchNamespacedPodTemplateWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/podtemplates/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PodTemplate>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PodTemplate>> ReplaceNamespacedPodTemplateWithHttpMessagesAsync(
            V1PodTemplate body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/podtemplates/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PodTemplate>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedReplicationControllerWithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/replicationcontrollers").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ReplicationControllerList>> ListNamespacedReplicationControllerWithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/replicationcontrollers").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ReplicationControllerList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ReplicationController>> CreateNamespacedReplicationControllerWithHttpMessagesAsync(
            V1ReplicationController body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/replicationcontrollers").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ReplicationController>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteNamespacedReplicationControllerWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/replicationcontrollers/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ReplicationController>> ReadNamespacedReplicationControllerWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/replicationcontrollers/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ReplicationController>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ReplicationController>> PatchNamespacedReplicationControllerWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/replicationcontrollers/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ReplicationController>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ReplicationController>> ReplaceNamespacedReplicationControllerWithHttpMessagesAsync(
            V1ReplicationController body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/replicationcontrollers/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ReplicationController>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Scale>> ReadNamespacedReplicationControllerScaleWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/replicationcontrollers/{name}/scale").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Scale>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Scale>> PatchNamespacedReplicationControllerScaleWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/replicationcontrollers/{name}/scale").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Scale>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Scale>> ReplaceNamespacedReplicationControllerScaleWithHttpMessagesAsync(
            V1Scale body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/replicationcontrollers/{name}/scale").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Scale>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ReplicationController>> ReadNamespacedReplicationControllerStatusWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/replicationcontrollers/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ReplicationController>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ReplicationController>> PatchNamespacedReplicationControllerStatusWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/replicationcontrollers/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ReplicationController>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ReplicationController>> ReplaceNamespacedReplicationControllerStatusWithHttpMessagesAsync(
            V1ReplicationController body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/replicationcontrollers/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ReplicationController>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedResourceQuotaWithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/resourcequotas").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ResourceQuotaList>> ListNamespacedResourceQuotaWithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/resourcequotas").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ResourceQuotaList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ResourceQuota>> CreateNamespacedResourceQuotaWithHttpMessagesAsync(
            V1ResourceQuota body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/resourcequotas").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ResourceQuota>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ResourceQuota>> DeleteNamespacedResourceQuotaWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/resourcequotas/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ResourceQuota>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ResourceQuota>> ReadNamespacedResourceQuotaWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/resourcequotas/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ResourceQuota>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ResourceQuota>> PatchNamespacedResourceQuotaWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/resourcequotas/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ResourceQuota>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ResourceQuota>> ReplaceNamespacedResourceQuotaWithHttpMessagesAsync(
            V1ResourceQuota body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/resourcequotas/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ResourceQuota>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ResourceQuota>> ReadNamespacedResourceQuotaStatusWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/resourcequotas/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ResourceQuota>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ResourceQuota>> PatchNamespacedResourceQuotaStatusWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/resourcequotas/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ResourceQuota>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ResourceQuota>> ReplaceNamespacedResourceQuotaStatusWithHttpMessagesAsync(
            V1ResourceQuota body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/resourcequotas/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ResourceQuota>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedSecretWithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/secrets").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1SecretList>> ListNamespacedSecretWithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/secrets").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1SecretList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Secret>> CreateNamespacedSecretWithHttpMessagesAsync(
            V1Secret body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/secrets").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Secret>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteNamespacedSecretWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/secrets/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Secret>> ReadNamespacedSecretWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/secrets/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Secret>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Secret>> PatchNamespacedSecretWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/secrets/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Secret>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Secret>> ReplaceNamespacedSecretWithHttpMessagesAsync(
            V1Secret body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/secrets/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Secret>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedServiceAccountWithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/serviceaccounts").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ServiceAccountList>> ListNamespacedServiceAccountWithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/serviceaccounts").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ServiceAccountList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ServiceAccount>> CreateNamespacedServiceAccountWithHttpMessagesAsync(
            V1ServiceAccount body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/serviceaccounts").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ServiceAccount>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ServiceAccount>> DeleteNamespacedServiceAccountWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/serviceaccounts/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ServiceAccount>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ServiceAccount>> ReadNamespacedServiceAccountWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/serviceaccounts/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ServiceAccount>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ServiceAccount>> PatchNamespacedServiceAccountWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/serviceaccounts/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ServiceAccount>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ServiceAccount>> ReplaceNamespacedServiceAccountWithHttpMessagesAsync(
            V1ServiceAccount body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/serviceaccounts/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ServiceAccount>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Authenticationv1TokenRequest>> CreateNamespacedServiceAccountTokenWithHttpMessagesAsync(
            Authenticationv1TokenRequest body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/serviceaccounts/{name}/token").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<Authenticationv1TokenRequest>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedServiceWithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/services").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ServiceList>> ListNamespacedServiceWithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/services").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ServiceList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Service>> CreateNamespacedServiceWithHttpMessagesAsync(
            V1Service body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/services").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Service>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Service>> DeleteNamespacedServiceWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/services/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Service>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Service>> ReadNamespacedServiceWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/services/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Service>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Service>> PatchNamespacedServiceWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/services/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Service>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Service>> ReplaceNamespacedServiceWithHttpMessagesAsync(
            V1Service body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/services/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Service>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectDeleteNamespacedServiceProxyWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            string path = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/services/{name}/proxy").ToString();
            var q = new QueryBuilder();
            q.Append("path", path);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectGetNamespacedServiceProxyWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            string path = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/services/{name}/proxy").ToString();
            var q = new QueryBuilder();
            q.Append("path", path);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectHeadNamespacedServiceProxyWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            string path = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/services/{name}/proxy").ToString();
            var q = new QueryBuilder();
            q.Append("path", path);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Head, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectPatchNamespacedServiceProxyWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            string path = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/services/{name}/proxy").ToString();
            var q = new QueryBuilder();
            q.Append("path", path);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectPostNamespacedServiceProxyWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            string path = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/services/{name}/proxy").ToString();
            var q = new QueryBuilder();
            q.Append("path", path);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectPutNamespacedServiceProxyWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            string path = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/services/{name}/proxy").ToString();
            var q = new QueryBuilder();
            q.Append("path", path);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectDeleteNamespacedServiceProxyWithPathWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            string path,
            string path1 = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }
            if (path == null)
            {
                throw new ArgumentNullException("path");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/services/{name}/proxy/{path}").ToString();
            var q = new QueryBuilder();
            q.Append("path1", path1);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectGetNamespacedServiceProxyWithPathWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            string path,
            string path1 = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }
            if (path == null)
            {
                throw new ArgumentNullException("path");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/services/{name}/proxy/{path}").ToString();
            var q = new QueryBuilder();
            q.Append("path1", path1);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectHeadNamespacedServiceProxyWithPathWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            string path,
            string path1 = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }
            if (path == null)
            {
                throw new ArgumentNullException("path");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/services/{name}/proxy/{path}").ToString();
            var q = new QueryBuilder();
            q.Append("path1", path1);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Head, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectPatchNamespacedServiceProxyWithPathWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            string path,
            string path1 = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }
            if (path == null)
            {
                throw new ArgumentNullException("path");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/services/{name}/proxy/{path}").ToString();
            var q = new QueryBuilder();
            q.Append("path1", path1);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectPostNamespacedServiceProxyWithPathWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            string path,
            string path1 = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }
            if (path == null)
            {
                throw new ArgumentNullException("path");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/services/{name}/proxy/{path}").ToString();
            var q = new QueryBuilder();
            q.Append("path1", path1);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectPutNamespacedServiceProxyWithPathWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            string path,
            string path1 = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }
            if (path == null)
            {
                throw new ArgumentNullException("path");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/services/{name}/proxy/{path}").ToString();
            var q = new QueryBuilder();
            q.Append("path1", path1);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Service>> ReadNamespacedServiceStatusWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/services/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Service>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Service>> PatchNamespacedServiceStatusWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/services/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Service>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Service>> ReplaceNamespacedServiceStatusWithHttpMessagesAsync(
            V1Service body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{namespaceParameter}/services/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Service>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteNamespaceWithHttpMessagesAsync(
            string name,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Namespace>> ReadNamespaceWithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Namespace>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Namespace>> PatchNamespaceWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Namespace>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Namespace>> ReplaceNamespaceWithHttpMessagesAsync(
            V1Namespace body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Namespace>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Namespace>> ReplaceNamespaceFinalizeWithHttpMessagesAsync(
            V1Namespace body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{name}/finalize").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Namespace>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Namespace>> ReadNamespaceStatusWithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Namespace>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Namespace>> PatchNamespaceStatusWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Namespace>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Namespace>> ReplaceNamespaceStatusWithHttpMessagesAsync(
            V1Namespace body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/namespaces/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Namespace>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNodeWithHttpMessagesAsync(
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/nodes").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1NodeList>> ListNodeWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/nodes").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1NodeList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Node>> CreateNodeWithHttpMessagesAsync(
            V1Node body,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/nodes").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Node>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteNodeWithHttpMessagesAsync(
            string name,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/nodes/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Node>> ReadNodeWithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/nodes/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Node>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Node>> PatchNodeWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/nodes/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Node>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Node>> ReplaceNodeWithHttpMessagesAsync(
            V1Node body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/nodes/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Node>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectDeleteNodeProxyWithHttpMessagesAsync(
            string name,
            string path = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/nodes/{name}/proxy").ToString();
            var q = new QueryBuilder();
            q.Append("path", path);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectGetNodeProxyWithHttpMessagesAsync(
            string name,
            string path = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/nodes/{name}/proxy").ToString();
            var q = new QueryBuilder();
            q.Append("path", path);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectHeadNodeProxyWithHttpMessagesAsync(
            string name,
            string path = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/nodes/{name}/proxy").ToString();
            var q = new QueryBuilder();
            q.Append("path", path);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Head, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectPatchNodeProxyWithHttpMessagesAsync(
            string name,
            string path = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/nodes/{name}/proxy").ToString();
            var q = new QueryBuilder();
            q.Append("path", path);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectPostNodeProxyWithHttpMessagesAsync(
            string name,
            string path = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/nodes/{name}/proxy").ToString();
            var q = new QueryBuilder();
            q.Append("path", path);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectPutNodeProxyWithHttpMessagesAsync(
            string name,
            string path = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/nodes/{name}/proxy").ToString();
            var q = new QueryBuilder();
            q.Append("path", path);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectDeleteNodeProxyWithPathWithHttpMessagesAsync(
            string name,
            string path,
            string path1 = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (path == null)
            {
                throw new ArgumentNullException("path");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/nodes/{name}/proxy/{path}").ToString();
            var q = new QueryBuilder();
            q.Append("path1", path1);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectGetNodeProxyWithPathWithHttpMessagesAsync(
            string name,
            string path,
            string path1 = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (path == null)
            {
                throw new ArgumentNullException("path");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/nodes/{name}/proxy/{path}").ToString();
            var q = new QueryBuilder();
            q.Append("path1", path1);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectHeadNodeProxyWithPathWithHttpMessagesAsync(
            string name,
            string path,
            string path1 = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (path == null)
            {
                throw new ArgumentNullException("path");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/nodes/{name}/proxy/{path}").ToString();
            var q = new QueryBuilder();
            q.Append("path1", path1);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Head, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectPatchNodeProxyWithPathWithHttpMessagesAsync(
            string name,
            string path,
            string path1 = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (path == null)
            {
                throw new ArgumentNullException("path");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/nodes/{name}/proxy/{path}").ToString();
            var q = new QueryBuilder();
            q.Append("path1", path1);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectPostNodeProxyWithPathWithHttpMessagesAsync(
            string name,
            string path,
            string path1 = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (path == null)
            {
                throw new ArgumentNullException("path");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/nodes/{name}/proxy/{path}").ToString();
            var q = new QueryBuilder();
            q.Append("path1", path1);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<Stream>> ConnectPutNodeProxyWithPathWithHttpMessagesAsync(
            string name,
            string path,
            string path1 = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (path == null)
            {
                throw new ArgumentNullException("path");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/nodes/{name}/proxy/{path}").ToString();
            var q = new QueryBuilder();
            q.Append("path1", path1);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = new HttpOperationResponse<Stream>() {
                                Request = httpRequest,
                                Response = httpResponse,
                                Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Node>> ReadNodeStatusWithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/nodes/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Node>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Node>> PatchNodeStatusWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/nodes/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Node>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Node>> ReplaceNodeStatusWithHttpMessagesAsync(
            V1Node body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/nodes/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Node>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PersistentVolumeClaimList>> ListPersistentVolumeClaimForAllNamespacesWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/persistentvolumeclaims").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PersistentVolumeClaimList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionPersistentVolumeWithHttpMessagesAsync(
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/persistentvolumes").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PersistentVolumeList>> ListPersistentVolumeWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/persistentvolumes").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PersistentVolumeList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PersistentVolume>> CreatePersistentVolumeWithHttpMessagesAsync(
            V1PersistentVolume body,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/persistentvolumes").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PersistentVolume>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PersistentVolume>> DeletePersistentVolumeWithHttpMessagesAsync(
            string name,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/persistentvolumes/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PersistentVolume>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PersistentVolume>> ReadPersistentVolumeWithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/persistentvolumes/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PersistentVolume>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PersistentVolume>> PatchPersistentVolumeWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/persistentvolumes/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PersistentVolume>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PersistentVolume>> ReplacePersistentVolumeWithHttpMessagesAsync(
            V1PersistentVolume body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/persistentvolumes/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PersistentVolume>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PersistentVolume>> ReadPersistentVolumeStatusWithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/persistentvolumes/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PersistentVolume>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PersistentVolume>> PatchPersistentVolumeStatusWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/persistentvolumes/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PersistentVolume>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PersistentVolume>> ReplacePersistentVolumeStatusWithHttpMessagesAsync(
            V1PersistentVolume body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/persistentvolumes/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PersistentVolume>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PodList>> ListPodForAllNamespacesWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/pods").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PodList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PodTemplateList>> ListPodTemplateForAllNamespacesWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/podtemplates").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PodTemplateList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ReplicationControllerList>> ListReplicationControllerForAllNamespacesWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/replicationcontrollers").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ReplicationControllerList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ResourceQuotaList>> ListResourceQuotaForAllNamespacesWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/resourcequotas").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ResourceQuotaList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1SecretList>> ListSecretForAllNamespacesWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/secrets").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1SecretList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ServiceAccountList>> ListServiceAccountForAllNamespacesWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/serviceaccounts").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ServiceAccountList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ServiceList>> ListServiceForAllNamespacesWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"api/v1/services").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ServiceList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIGroup>> GetAPIGroupWithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/admissionregistration.k8s.io/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIGroup>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIGroup>> GetAPIGroup1WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apiextensions.k8s.io/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIGroup>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIGroup>> GetAPIGroup2WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apiregistration.k8s.io/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIGroup>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIGroup>> GetAPIGroup3WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIGroup>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIGroup>> GetAPIGroup4WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/authentication.k8s.io/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIGroup>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIGroup>> GetAPIGroup5WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/authorization.k8s.io/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIGroup>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIGroup>> GetAPIGroup6WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIGroup>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIGroup>> GetAPIGroup7WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIGroup>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIGroup>> GetAPIGroup8WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/certificates.k8s.io/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIGroup>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIGroup>> GetAPIGroup9WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/coordination.k8s.io/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIGroup>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIGroup>> GetAPIGroup10WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/discovery.k8s.io/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIGroup>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIGroup>> GetAPIGroup11WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/events.k8s.io/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIGroup>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIGroup>> GetAPIGroup12WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIGroup>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIGroup>> GetAPIGroup13WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/internal.apiserver.k8s.io/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIGroup>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIGroup>> GetAPIGroup14WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/networking.k8s.io/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIGroup>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIGroup>> GetAPIGroup15WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/node.k8s.io/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIGroup>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIGroup>> GetAPIGroup16WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/policy/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIGroup>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIGroup>> GetAPIGroup17WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/rbac.authorization.k8s.io/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIGroup>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIGroup>> GetAPIGroup18WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/scheduling.k8s.io/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIGroup>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIGroup>> GetAPIGroup19WithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIGroup>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionMutatingWebhookConfigurationWithHttpMessagesAsync(
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1MutatingWebhookConfigurationList>> ListMutatingWebhookConfigurationWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1MutatingWebhookConfigurationList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1MutatingWebhookConfiguration>> CreateMutatingWebhookConfigurationWithHttpMessagesAsync(
            V1MutatingWebhookConfiguration body,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1MutatingWebhookConfiguration>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteMutatingWebhookConfigurationWithHttpMessagesAsync(
            string name,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1MutatingWebhookConfiguration>> ReadMutatingWebhookConfigurationWithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1MutatingWebhookConfiguration>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1MutatingWebhookConfiguration>> PatchMutatingWebhookConfigurationWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1MutatingWebhookConfiguration>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1MutatingWebhookConfiguration>> ReplaceMutatingWebhookConfigurationWithHttpMessagesAsync(
            V1MutatingWebhookConfiguration body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1MutatingWebhookConfiguration>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionValidatingWebhookConfigurationWithHttpMessagesAsync(
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ValidatingWebhookConfigurationList>> ListValidatingWebhookConfigurationWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ValidatingWebhookConfigurationList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ValidatingWebhookConfiguration>> CreateValidatingWebhookConfigurationWithHttpMessagesAsync(
            V1ValidatingWebhookConfiguration body,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ValidatingWebhookConfiguration>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteValidatingWebhookConfigurationWithHttpMessagesAsync(
            string name,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ValidatingWebhookConfiguration>> ReadValidatingWebhookConfigurationWithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ValidatingWebhookConfiguration>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ValidatingWebhookConfiguration>> PatchValidatingWebhookConfigurationWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ValidatingWebhookConfiguration>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ValidatingWebhookConfiguration>> ReplaceValidatingWebhookConfigurationWithHttpMessagesAsync(
            V1ValidatingWebhookConfiguration body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ValidatingWebhookConfiguration>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionCustomResourceDefinitionWithHttpMessagesAsync(
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apiextensions.k8s.io/v1/customresourcedefinitions").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CustomResourceDefinitionList>> ListCustomResourceDefinitionWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apiextensions.k8s.io/v1/customresourcedefinitions").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CustomResourceDefinitionList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CustomResourceDefinition>> CreateCustomResourceDefinitionWithHttpMessagesAsync(
            V1CustomResourceDefinition body,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apiextensions.k8s.io/v1/customresourcedefinitions").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CustomResourceDefinition>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCustomResourceDefinitionWithHttpMessagesAsync(
            string name,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CustomResourceDefinition>> ReadCustomResourceDefinitionWithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CustomResourceDefinition>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CustomResourceDefinition>> PatchCustomResourceDefinitionWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CustomResourceDefinition>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CustomResourceDefinition>> ReplaceCustomResourceDefinitionWithHttpMessagesAsync(
            V1CustomResourceDefinition body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CustomResourceDefinition>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CustomResourceDefinition>> ReadCustomResourceDefinitionStatusWithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CustomResourceDefinition>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CustomResourceDefinition>> PatchCustomResourceDefinitionStatusWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CustomResourceDefinition>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CustomResourceDefinition>> ReplaceCustomResourceDefinitionStatusWithHttpMessagesAsync(
            V1CustomResourceDefinition body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CustomResourceDefinition>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionAPIServiceWithHttpMessagesAsync(
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apiregistration.k8s.io/v1/apiservices").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIServiceList>> ListAPIServiceWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apiregistration.k8s.io/v1/apiservices").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIServiceList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIService>> CreateAPIServiceWithHttpMessagesAsync(
            V1APIService body,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apiregistration.k8s.io/v1/apiservices").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIService>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteAPIServiceWithHttpMessagesAsync(
            string name,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apiregistration.k8s.io/v1/apiservices/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIService>> ReadAPIServiceWithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apiregistration.k8s.io/v1/apiservices/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIService>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIService>> PatchAPIServiceWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apiregistration.k8s.io/v1/apiservices/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIService>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIService>> ReplaceAPIServiceWithHttpMessagesAsync(
            V1APIService body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apiregistration.k8s.io/v1/apiservices/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIService>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIService>> ReadAPIServiceStatusWithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apiregistration.k8s.io/v1/apiservices/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIService>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIService>> PatchAPIServiceStatusWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apiregistration.k8s.io/v1/apiservices/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIService>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1APIService>> ReplaceAPIServiceStatusWithHttpMessagesAsync(
            V1APIService body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apiregistration.k8s.io/v1/apiservices/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1APIService>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ControllerRevisionList>> ListControllerRevisionForAllNamespacesWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/controllerrevisions").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ControllerRevisionList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1DaemonSetList>> ListDaemonSetForAllNamespacesWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/daemonsets").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1DaemonSetList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1DeploymentList>> ListDeploymentForAllNamespacesWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/deployments").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1DeploymentList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedControllerRevisionWithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/controllerrevisions").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ControllerRevisionList>> ListNamespacedControllerRevisionWithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/controllerrevisions").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ControllerRevisionList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ControllerRevision>> CreateNamespacedControllerRevisionWithHttpMessagesAsync(
            V1ControllerRevision body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/controllerrevisions").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ControllerRevision>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteNamespacedControllerRevisionWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/controllerrevisions/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ControllerRevision>> ReadNamespacedControllerRevisionWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/controllerrevisions/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ControllerRevision>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ControllerRevision>> PatchNamespacedControllerRevisionWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/controllerrevisions/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ControllerRevision>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ControllerRevision>> ReplaceNamespacedControllerRevisionWithHttpMessagesAsync(
            V1ControllerRevision body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/controllerrevisions/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ControllerRevision>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedDaemonSetWithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/daemonsets").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1DaemonSetList>> ListNamespacedDaemonSetWithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/daemonsets").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1DaemonSetList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1DaemonSet>> CreateNamespacedDaemonSetWithHttpMessagesAsync(
            V1DaemonSet body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/daemonsets").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1DaemonSet>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteNamespacedDaemonSetWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/daemonsets/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1DaemonSet>> ReadNamespacedDaemonSetWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/daemonsets/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1DaemonSet>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1DaemonSet>> PatchNamespacedDaemonSetWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/daemonsets/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1DaemonSet>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1DaemonSet>> ReplaceNamespacedDaemonSetWithHttpMessagesAsync(
            V1DaemonSet body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/daemonsets/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1DaemonSet>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1DaemonSet>> ReadNamespacedDaemonSetStatusWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/daemonsets/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1DaemonSet>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1DaemonSet>> PatchNamespacedDaemonSetStatusWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/daemonsets/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1DaemonSet>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1DaemonSet>> ReplaceNamespacedDaemonSetStatusWithHttpMessagesAsync(
            V1DaemonSet body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/daemonsets/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1DaemonSet>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedDeploymentWithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/deployments").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1DeploymentList>> ListNamespacedDeploymentWithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/deployments").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1DeploymentList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Deployment>> CreateNamespacedDeploymentWithHttpMessagesAsync(
            V1Deployment body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/deployments").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Deployment>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteNamespacedDeploymentWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/deployments/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Deployment>> ReadNamespacedDeploymentWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/deployments/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Deployment>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Deployment>> PatchNamespacedDeploymentWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/deployments/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Deployment>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Deployment>> ReplaceNamespacedDeploymentWithHttpMessagesAsync(
            V1Deployment body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/deployments/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Deployment>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Scale>> ReadNamespacedDeploymentScaleWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/deployments/{name}/scale").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Scale>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Scale>> PatchNamespacedDeploymentScaleWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/deployments/{name}/scale").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Scale>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Scale>> ReplaceNamespacedDeploymentScaleWithHttpMessagesAsync(
            V1Scale body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/deployments/{name}/scale").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Scale>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Deployment>> ReadNamespacedDeploymentStatusWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/deployments/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Deployment>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Deployment>> PatchNamespacedDeploymentStatusWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/deployments/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Deployment>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Deployment>> ReplaceNamespacedDeploymentStatusWithHttpMessagesAsync(
            V1Deployment body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/deployments/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Deployment>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedReplicaSetWithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/replicasets").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ReplicaSetList>> ListNamespacedReplicaSetWithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/replicasets").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ReplicaSetList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ReplicaSet>> CreateNamespacedReplicaSetWithHttpMessagesAsync(
            V1ReplicaSet body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/replicasets").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ReplicaSet>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteNamespacedReplicaSetWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/replicasets/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ReplicaSet>> ReadNamespacedReplicaSetWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/replicasets/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ReplicaSet>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ReplicaSet>> PatchNamespacedReplicaSetWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/replicasets/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ReplicaSet>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ReplicaSet>> ReplaceNamespacedReplicaSetWithHttpMessagesAsync(
            V1ReplicaSet body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/replicasets/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ReplicaSet>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Scale>> ReadNamespacedReplicaSetScaleWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/replicasets/{name}/scale").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Scale>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Scale>> PatchNamespacedReplicaSetScaleWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/replicasets/{name}/scale").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Scale>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Scale>> ReplaceNamespacedReplicaSetScaleWithHttpMessagesAsync(
            V1Scale body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/replicasets/{name}/scale").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Scale>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ReplicaSet>> ReadNamespacedReplicaSetStatusWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/replicasets/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ReplicaSet>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ReplicaSet>> PatchNamespacedReplicaSetStatusWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/replicasets/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ReplicaSet>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ReplicaSet>> ReplaceNamespacedReplicaSetStatusWithHttpMessagesAsync(
            V1ReplicaSet body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/replicasets/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ReplicaSet>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedStatefulSetWithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/statefulsets").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1StatefulSetList>> ListNamespacedStatefulSetWithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/statefulsets").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1StatefulSetList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1StatefulSet>> CreateNamespacedStatefulSetWithHttpMessagesAsync(
            V1StatefulSet body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/statefulsets").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1StatefulSet>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteNamespacedStatefulSetWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/statefulsets/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1StatefulSet>> ReadNamespacedStatefulSetWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/statefulsets/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1StatefulSet>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1StatefulSet>> PatchNamespacedStatefulSetWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/statefulsets/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1StatefulSet>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1StatefulSet>> ReplaceNamespacedStatefulSetWithHttpMessagesAsync(
            V1StatefulSet body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/statefulsets/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1StatefulSet>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Scale>> ReadNamespacedStatefulSetScaleWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/statefulsets/{name}/scale").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Scale>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Scale>> PatchNamespacedStatefulSetScaleWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/statefulsets/{name}/scale").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Scale>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Scale>> ReplaceNamespacedStatefulSetScaleWithHttpMessagesAsync(
            V1Scale body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/statefulsets/{name}/scale").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Scale>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1StatefulSet>> ReadNamespacedStatefulSetStatusWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/statefulsets/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1StatefulSet>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1StatefulSet>> PatchNamespacedStatefulSetStatusWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/statefulsets/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1StatefulSet>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1StatefulSet>> ReplaceNamespacedStatefulSetStatusWithHttpMessagesAsync(
            V1StatefulSet body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/namespaces/{namespaceParameter}/statefulsets/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1StatefulSet>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ReplicaSetList>> ListReplicaSetForAllNamespacesWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/replicasets").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ReplicaSetList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1StatefulSetList>> ListStatefulSetForAllNamespacesWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/apps/v1/statefulsets").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1StatefulSetList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1TokenReview>> CreateTokenReviewWithHttpMessagesAsync(
            V1TokenReview body,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/authentication.k8s.io/v1/tokenreviews").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1TokenReview>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1LocalSubjectAccessReview>> CreateNamespacedLocalSubjectAccessReviewWithHttpMessagesAsync(
            V1LocalSubjectAccessReview body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/authorization.k8s.io/v1/namespaces/{namespaceParameter}/localsubjectaccessreviews").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1LocalSubjectAccessReview>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1SelfSubjectAccessReview>> CreateSelfSubjectAccessReviewWithHttpMessagesAsync(
            V1SelfSubjectAccessReview body,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/authorization.k8s.io/v1/selfsubjectaccessreviews").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1SelfSubjectAccessReview>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1SelfSubjectRulesReview>> CreateSelfSubjectRulesReviewWithHttpMessagesAsync(
            V1SelfSubjectRulesReview body,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/authorization.k8s.io/v1/selfsubjectrulesreviews").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1SelfSubjectRulesReview>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1SubjectAccessReview>> CreateSubjectAccessReviewWithHttpMessagesAsync(
            V1SubjectAccessReview body,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/authorization.k8s.io/v1/subjectaccessreviews").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1SubjectAccessReview>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1HorizontalPodAutoscalerList>> ListHorizontalPodAutoscalerForAllNamespacesWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v1/horizontalpodautoscalers").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1HorizontalPodAutoscalerList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V2HorizontalPodAutoscalerList>> ListHorizontalPodAutoscalerForAllNamespaces1WithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2/horizontalpodautoscalers").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V2HorizontalPodAutoscalerList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V2beta1HorizontalPodAutoscalerList>> ListHorizontalPodAutoscalerForAllNamespaces2WithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2beta1/horizontalpodautoscalers").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V2beta1HorizontalPodAutoscalerList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V2beta2HorizontalPodAutoscalerList>> ListHorizontalPodAutoscalerForAllNamespaces3WithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2beta2/horizontalpodautoscalers").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V2beta2HorizontalPodAutoscalerList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedHorizontalPodAutoscalerWithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v1/namespaces/{namespaceParameter}/horizontalpodautoscalers").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedHorizontalPodAutoscaler1WithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2/namespaces/{namespaceParameter}/horizontalpodautoscalers").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedHorizontalPodAutoscaler2WithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2beta1/namespaces/{namespaceParameter}/horizontalpodautoscalers").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedHorizontalPodAutoscaler3WithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2beta2/namespaces/{namespaceParameter}/horizontalpodautoscalers").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1HorizontalPodAutoscalerList>> ListNamespacedHorizontalPodAutoscalerWithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v1/namespaces/{namespaceParameter}/horizontalpodautoscalers").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1HorizontalPodAutoscalerList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V2HorizontalPodAutoscalerList>> ListNamespacedHorizontalPodAutoscaler1WithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2/namespaces/{namespaceParameter}/horizontalpodautoscalers").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V2HorizontalPodAutoscalerList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V2beta1HorizontalPodAutoscalerList>> ListNamespacedHorizontalPodAutoscaler2WithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2beta1/namespaces/{namespaceParameter}/horizontalpodautoscalers").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V2beta1HorizontalPodAutoscalerList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V2beta2HorizontalPodAutoscalerList>> ListNamespacedHorizontalPodAutoscaler3WithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2beta2/namespaces/{namespaceParameter}/horizontalpodautoscalers").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V2beta2HorizontalPodAutoscalerList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1HorizontalPodAutoscaler>> CreateNamespacedHorizontalPodAutoscalerWithHttpMessagesAsync(
            V1HorizontalPodAutoscaler body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v1/namespaces/{namespaceParameter}/horizontalpodautoscalers").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1HorizontalPodAutoscaler>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V2HorizontalPodAutoscaler>> CreateNamespacedHorizontalPodAutoscaler1WithHttpMessagesAsync(
            V2HorizontalPodAutoscaler body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2/namespaces/{namespaceParameter}/horizontalpodautoscalers").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V2HorizontalPodAutoscaler>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V2beta1HorizontalPodAutoscaler>> CreateNamespacedHorizontalPodAutoscaler2WithHttpMessagesAsync(
            V2beta1HorizontalPodAutoscaler body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2beta1/namespaces/{namespaceParameter}/horizontalpodautoscalers").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V2beta1HorizontalPodAutoscaler>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V2beta2HorizontalPodAutoscaler>> CreateNamespacedHorizontalPodAutoscaler3WithHttpMessagesAsync(
            V2beta2HorizontalPodAutoscaler body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2beta2/namespaces/{namespaceParameter}/horizontalpodautoscalers").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V2beta2HorizontalPodAutoscaler>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteNamespacedHorizontalPodAutoscalerWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v1/namespaces/{namespaceParameter}/horizontalpodautoscalers/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteNamespacedHorizontalPodAutoscaler1WithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2/namespaces/{namespaceParameter}/horizontalpodautoscalers/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteNamespacedHorizontalPodAutoscaler2WithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2beta1/namespaces/{namespaceParameter}/horizontalpodautoscalers/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteNamespacedHorizontalPodAutoscaler3WithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2beta2/namespaces/{namespaceParameter}/horizontalpodautoscalers/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1HorizontalPodAutoscaler>> ReadNamespacedHorizontalPodAutoscalerWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v1/namespaces/{namespaceParameter}/horizontalpodautoscalers/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1HorizontalPodAutoscaler>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V2HorizontalPodAutoscaler>> ReadNamespacedHorizontalPodAutoscaler1WithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2/namespaces/{namespaceParameter}/horizontalpodautoscalers/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V2HorizontalPodAutoscaler>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V2beta1HorizontalPodAutoscaler>> ReadNamespacedHorizontalPodAutoscaler2WithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2beta1/namespaces/{namespaceParameter}/horizontalpodautoscalers/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V2beta1HorizontalPodAutoscaler>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V2beta2HorizontalPodAutoscaler>> ReadNamespacedHorizontalPodAutoscaler3WithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2beta2/namespaces/{namespaceParameter}/horizontalpodautoscalers/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V2beta2HorizontalPodAutoscaler>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1HorizontalPodAutoscaler>> PatchNamespacedHorizontalPodAutoscalerWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v1/namespaces/{namespaceParameter}/horizontalpodautoscalers/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1HorizontalPodAutoscaler>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V2HorizontalPodAutoscaler>> PatchNamespacedHorizontalPodAutoscaler1WithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2/namespaces/{namespaceParameter}/horizontalpodautoscalers/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V2HorizontalPodAutoscaler>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V2beta1HorizontalPodAutoscaler>> PatchNamespacedHorizontalPodAutoscaler2WithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2beta1/namespaces/{namespaceParameter}/horizontalpodautoscalers/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V2beta1HorizontalPodAutoscaler>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V2beta2HorizontalPodAutoscaler>> PatchNamespacedHorizontalPodAutoscaler3WithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2beta2/namespaces/{namespaceParameter}/horizontalpodautoscalers/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V2beta2HorizontalPodAutoscaler>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1HorizontalPodAutoscaler>> ReplaceNamespacedHorizontalPodAutoscalerWithHttpMessagesAsync(
            V1HorizontalPodAutoscaler body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v1/namespaces/{namespaceParameter}/horizontalpodautoscalers/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1HorizontalPodAutoscaler>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V2HorizontalPodAutoscaler>> ReplaceNamespacedHorizontalPodAutoscaler1WithHttpMessagesAsync(
            V2HorizontalPodAutoscaler body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2/namespaces/{namespaceParameter}/horizontalpodautoscalers/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V2HorizontalPodAutoscaler>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V2beta1HorizontalPodAutoscaler>> ReplaceNamespacedHorizontalPodAutoscaler2WithHttpMessagesAsync(
            V2beta1HorizontalPodAutoscaler body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2beta1/namespaces/{namespaceParameter}/horizontalpodautoscalers/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V2beta1HorizontalPodAutoscaler>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V2beta2HorizontalPodAutoscaler>> ReplaceNamespacedHorizontalPodAutoscaler3WithHttpMessagesAsync(
            V2beta2HorizontalPodAutoscaler body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2beta2/namespaces/{namespaceParameter}/horizontalpodautoscalers/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V2beta2HorizontalPodAutoscaler>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1HorizontalPodAutoscaler>> ReadNamespacedHorizontalPodAutoscalerStatusWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v1/namespaces/{namespaceParameter}/horizontalpodautoscalers/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1HorizontalPodAutoscaler>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V2HorizontalPodAutoscaler>> ReadNamespacedHorizontalPodAutoscalerStatus1WithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2/namespaces/{namespaceParameter}/horizontalpodautoscalers/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V2HorizontalPodAutoscaler>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V2beta1HorizontalPodAutoscaler>> ReadNamespacedHorizontalPodAutoscalerStatus2WithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2beta1/namespaces/{namespaceParameter}/horizontalpodautoscalers/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V2beta1HorizontalPodAutoscaler>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V2beta2HorizontalPodAutoscaler>> ReadNamespacedHorizontalPodAutoscalerStatus3WithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2beta2/namespaces/{namespaceParameter}/horizontalpodautoscalers/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V2beta2HorizontalPodAutoscaler>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1HorizontalPodAutoscaler>> PatchNamespacedHorizontalPodAutoscalerStatusWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v1/namespaces/{namespaceParameter}/horizontalpodautoscalers/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1HorizontalPodAutoscaler>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V2HorizontalPodAutoscaler>> PatchNamespacedHorizontalPodAutoscalerStatus1WithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2/namespaces/{namespaceParameter}/horizontalpodautoscalers/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V2HorizontalPodAutoscaler>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V2beta1HorizontalPodAutoscaler>> PatchNamespacedHorizontalPodAutoscalerStatus2WithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2beta1/namespaces/{namespaceParameter}/horizontalpodautoscalers/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V2beta1HorizontalPodAutoscaler>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V2beta2HorizontalPodAutoscaler>> PatchNamespacedHorizontalPodAutoscalerStatus3WithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2beta2/namespaces/{namespaceParameter}/horizontalpodautoscalers/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V2beta2HorizontalPodAutoscaler>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1HorizontalPodAutoscaler>> ReplaceNamespacedHorizontalPodAutoscalerStatusWithHttpMessagesAsync(
            V1HorizontalPodAutoscaler body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v1/namespaces/{namespaceParameter}/horizontalpodautoscalers/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1HorizontalPodAutoscaler>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V2HorizontalPodAutoscaler>> ReplaceNamespacedHorizontalPodAutoscalerStatus1WithHttpMessagesAsync(
            V2HorizontalPodAutoscaler body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2/namespaces/{namespaceParameter}/horizontalpodautoscalers/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V2HorizontalPodAutoscaler>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V2beta1HorizontalPodAutoscaler>> ReplaceNamespacedHorizontalPodAutoscalerStatus2WithHttpMessagesAsync(
            V2beta1HorizontalPodAutoscaler body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2beta1/namespaces/{namespaceParameter}/horizontalpodautoscalers/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V2beta1HorizontalPodAutoscaler>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V2beta2HorizontalPodAutoscaler>> ReplaceNamespacedHorizontalPodAutoscalerStatus3WithHttpMessagesAsync(
            V2beta2HorizontalPodAutoscaler body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/autoscaling/v2beta2/namespaces/{namespaceParameter}/horizontalpodautoscalers/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V2beta2HorizontalPodAutoscaler>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CronJobList>> ListCronJobForAllNamespacesWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1/cronjobs").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CronJobList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1CronJobList>> ListCronJobForAllNamespaces1WithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1beta1/cronjobs").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1CronJobList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1JobList>> ListJobForAllNamespacesWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1/jobs").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1JobList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedCronJobWithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1/namespaces/{namespaceParameter}/cronjobs").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedCronJob1WithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1beta1/namespaces/{namespaceParameter}/cronjobs").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CronJobList>> ListNamespacedCronJobWithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1/namespaces/{namespaceParameter}/cronjobs").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CronJobList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1CronJobList>> ListNamespacedCronJob1WithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1beta1/namespaces/{namespaceParameter}/cronjobs").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1CronJobList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CronJob>> CreateNamespacedCronJobWithHttpMessagesAsync(
            V1CronJob body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1/namespaces/{namespaceParameter}/cronjobs").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CronJob>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1CronJob>> CreateNamespacedCronJob1WithHttpMessagesAsync(
            V1beta1CronJob body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1beta1/namespaces/{namespaceParameter}/cronjobs").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1CronJob>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteNamespacedCronJobWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1/namespaces/{namespaceParameter}/cronjobs/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteNamespacedCronJob1WithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1beta1/namespaces/{namespaceParameter}/cronjobs/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CronJob>> ReadNamespacedCronJobWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1/namespaces/{namespaceParameter}/cronjobs/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CronJob>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1CronJob>> ReadNamespacedCronJob1WithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1beta1/namespaces/{namespaceParameter}/cronjobs/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1CronJob>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CronJob>> PatchNamespacedCronJobWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1/namespaces/{namespaceParameter}/cronjobs/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CronJob>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1CronJob>> PatchNamespacedCronJob1WithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1beta1/namespaces/{namespaceParameter}/cronjobs/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1CronJob>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CronJob>> ReplaceNamespacedCronJobWithHttpMessagesAsync(
            V1CronJob body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1/namespaces/{namespaceParameter}/cronjobs/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CronJob>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1CronJob>> ReplaceNamespacedCronJob1WithHttpMessagesAsync(
            V1beta1CronJob body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1beta1/namespaces/{namespaceParameter}/cronjobs/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1CronJob>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CronJob>> ReadNamespacedCronJobStatusWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1/namespaces/{namespaceParameter}/cronjobs/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CronJob>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1CronJob>> ReadNamespacedCronJobStatus1WithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1beta1/namespaces/{namespaceParameter}/cronjobs/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1CronJob>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CronJob>> PatchNamespacedCronJobStatusWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1/namespaces/{namespaceParameter}/cronjobs/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CronJob>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1CronJob>> PatchNamespacedCronJobStatus1WithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1beta1/namespaces/{namespaceParameter}/cronjobs/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1CronJob>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CronJob>> ReplaceNamespacedCronJobStatusWithHttpMessagesAsync(
            V1CronJob body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1/namespaces/{namespaceParameter}/cronjobs/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CronJob>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1CronJob>> ReplaceNamespacedCronJobStatus1WithHttpMessagesAsync(
            V1beta1CronJob body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1beta1/namespaces/{namespaceParameter}/cronjobs/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1CronJob>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedJobWithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1/namespaces/{namespaceParameter}/jobs").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1JobList>> ListNamespacedJobWithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1/namespaces/{namespaceParameter}/jobs").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1JobList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Job>> CreateNamespacedJobWithHttpMessagesAsync(
            V1Job body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1/namespaces/{namespaceParameter}/jobs").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Job>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteNamespacedJobWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1/namespaces/{namespaceParameter}/jobs/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Job>> ReadNamespacedJobWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1/namespaces/{namespaceParameter}/jobs/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Job>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Job>> PatchNamespacedJobWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1/namespaces/{namespaceParameter}/jobs/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Job>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Job>> ReplaceNamespacedJobWithHttpMessagesAsync(
            V1Job body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1/namespaces/{namespaceParameter}/jobs/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Job>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Job>> ReadNamespacedJobStatusWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1/namespaces/{namespaceParameter}/jobs/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Job>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Job>> PatchNamespacedJobStatusWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1/namespaces/{namespaceParameter}/jobs/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Job>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Job>> ReplaceNamespacedJobStatusWithHttpMessagesAsync(
            V1Job body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/batch/v1/namespaces/{namespaceParameter}/jobs/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Job>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionCertificateSigningRequestWithHttpMessagesAsync(
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/certificates.k8s.io/v1/certificatesigningrequests").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CertificateSigningRequestList>> ListCertificateSigningRequestWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/certificates.k8s.io/v1/certificatesigningrequests").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CertificateSigningRequestList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CertificateSigningRequest>> CreateCertificateSigningRequestWithHttpMessagesAsync(
            V1CertificateSigningRequest body,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/certificates.k8s.io/v1/certificatesigningrequests").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CertificateSigningRequest>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCertificateSigningRequestWithHttpMessagesAsync(
            string name,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/certificates.k8s.io/v1/certificatesigningrequests/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CertificateSigningRequest>> ReadCertificateSigningRequestWithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/certificates.k8s.io/v1/certificatesigningrequests/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CertificateSigningRequest>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CertificateSigningRequest>> PatchCertificateSigningRequestWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/certificates.k8s.io/v1/certificatesigningrequests/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CertificateSigningRequest>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CertificateSigningRequest>> ReplaceCertificateSigningRequestWithHttpMessagesAsync(
            V1CertificateSigningRequest body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/certificates.k8s.io/v1/certificatesigningrequests/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CertificateSigningRequest>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CertificateSigningRequest>> ReadCertificateSigningRequestApprovalWithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/certificates.k8s.io/v1/certificatesigningrequests/{name}/approval").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CertificateSigningRequest>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CertificateSigningRequest>> PatchCertificateSigningRequestApprovalWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/certificates.k8s.io/v1/certificatesigningrequests/{name}/approval").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CertificateSigningRequest>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CertificateSigningRequest>> ReplaceCertificateSigningRequestApprovalWithHttpMessagesAsync(
            V1CertificateSigningRequest body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/certificates.k8s.io/v1/certificatesigningrequests/{name}/approval").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CertificateSigningRequest>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CertificateSigningRequest>> ReadCertificateSigningRequestStatusWithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/certificates.k8s.io/v1/certificatesigningrequests/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CertificateSigningRequest>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CertificateSigningRequest>> PatchCertificateSigningRequestStatusWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/certificates.k8s.io/v1/certificatesigningrequests/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CertificateSigningRequest>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CertificateSigningRequest>> ReplaceCertificateSigningRequestStatusWithHttpMessagesAsync(
            V1CertificateSigningRequest body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/certificates.k8s.io/v1/certificatesigningrequests/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CertificateSigningRequest>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1LeaseList>> ListLeaseForAllNamespacesWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/coordination.k8s.io/v1/leases").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1LeaseList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedLeaseWithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/coordination.k8s.io/v1/namespaces/{namespaceParameter}/leases").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1LeaseList>> ListNamespacedLeaseWithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/coordination.k8s.io/v1/namespaces/{namespaceParameter}/leases").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1LeaseList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Lease>> CreateNamespacedLeaseWithHttpMessagesAsync(
            V1Lease body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/coordination.k8s.io/v1/namespaces/{namespaceParameter}/leases").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Lease>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteNamespacedLeaseWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/coordination.k8s.io/v1/namespaces/{namespaceParameter}/leases/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Lease>> ReadNamespacedLeaseWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/coordination.k8s.io/v1/namespaces/{namespaceParameter}/leases/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Lease>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Lease>> PatchNamespacedLeaseWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/coordination.k8s.io/v1/namespaces/{namespaceParameter}/leases/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Lease>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Lease>> ReplaceNamespacedLeaseWithHttpMessagesAsync(
            V1Lease body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/coordination.k8s.io/v1/namespaces/{namespaceParameter}/leases/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Lease>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1EndpointSliceList>> ListEndpointSliceForAllNamespacesWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/discovery.k8s.io/v1/endpointslices").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1EndpointSliceList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1EndpointSliceList>> ListEndpointSliceForAllNamespaces1WithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/discovery.k8s.io/v1beta1/endpointslices").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1EndpointSliceList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedEndpointSliceWithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/discovery.k8s.io/v1/namespaces/{namespaceParameter}/endpointslices").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedEndpointSlice1WithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/discovery.k8s.io/v1beta1/namespaces/{namespaceParameter}/endpointslices").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1EndpointSliceList>> ListNamespacedEndpointSliceWithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/discovery.k8s.io/v1/namespaces/{namespaceParameter}/endpointslices").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1EndpointSliceList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1EndpointSliceList>> ListNamespacedEndpointSlice1WithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/discovery.k8s.io/v1beta1/namespaces/{namespaceParameter}/endpointslices").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1EndpointSliceList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1EndpointSlice>> CreateNamespacedEndpointSliceWithHttpMessagesAsync(
            V1EndpointSlice body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/discovery.k8s.io/v1/namespaces/{namespaceParameter}/endpointslices").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1EndpointSlice>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1EndpointSlice>> CreateNamespacedEndpointSlice1WithHttpMessagesAsync(
            V1beta1EndpointSlice body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/discovery.k8s.io/v1beta1/namespaces/{namespaceParameter}/endpointslices").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1EndpointSlice>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteNamespacedEndpointSliceWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/discovery.k8s.io/v1/namespaces/{namespaceParameter}/endpointslices/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteNamespacedEndpointSlice1WithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/discovery.k8s.io/v1beta1/namespaces/{namespaceParameter}/endpointslices/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1EndpointSlice>> ReadNamespacedEndpointSliceWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/discovery.k8s.io/v1/namespaces/{namespaceParameter}/endpointslices/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1EndpointSlice>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1EndpointSlice>> ReadNamespacedEndpointSlice1WithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/discovery.k8s.io/v1beta1/namespaces/{namespaceParameter}/endpointslices/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1EndpointSlice>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1EndpointSlice>> PatchNamespacedEndpointSliceWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/discovery.k8s.io/v1/namespaces/{namespaceParameter}/endpointslices/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1EndpointSlice>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1EndpointSlice>> PatchNamespacedEndpointSlice1WithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/discovery.k8s.io/v1beta1/namespaces/{namespaceParameter}/endpointslices/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1EndpointSlice>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1EndpointSlice>> ReplaceNamespacedEndpointSliceWithHttpMessagesAsync(
            V1EndpointSlice body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/discovery.k8s.io/v1/namespaces/{namespaceParameter}/endpointslices/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1EndpointSlice>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1EndpointSlice>> ReplaceNamespacedEndpointSlice1WithHttpMessagesAsync(
            V1beta1EndpointSlice body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/discovery.k8s.io/v1beta1/namespaces/{namespaceParameter}/endpointslices/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1EndpointSlice>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionFlowSchemaWithHttpMessagesAsync(
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionFlowSchema1WithHttpMessagesAsync(
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1FlowSchemaList>> ListFlowSchemaWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1FlowSchemaList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta2FlowSchemaList>> ListFlowSchema1WithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta2FlowSchemaList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1FlowSchema>> CreateFlowSchemaWithHttpMessagesAsync(
            V1beta1FlowSchema body,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1FlowSchema>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta2FlowSchema>> CreateFlowSchema1WithHttpMessagesAsync(
            V1beta2FlowSchema body,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta2FlowSchema>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteFlowSchemaWithHttpMessagesAsync(
            string name,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteFlowSchema1WithHttpMessagesAsync(
            string name,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1FlowSchema>> ReadFlowSchemaWithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1FlowSchema>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta2FlowSchema>> ReadFlowSchema1WithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta2FlowSchema>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1FlowSchema>> PatchFlowSchemaWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1FlowSchema>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta2FlowSchema>> PatchFlowSchema1WithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta2FlowSchema>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1FlowSchema>> ReplaceFlowSchemaWithHttpMessagesAsync(
            V1beta1FlowSchema body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1FlowSchema>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta2FlowSchema>> ReplaceFlowSchema1WithHttpMessagesAsync(
            V1beta2FlowSchema body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta2FlowSchema>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1FlowSchema>> ReadFlowSchemaStatusWithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1FlowSchema>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta2FlowSchema>> ReadFlowSchemaStatus1WithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta2FlowSchema>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1FlowSchema>> PatchFlowSchemaStatusWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1FlowSchema>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta2FlowSchema>> PatchFlowSchemaStatus1WithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta2FlowSchema>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1FlowSchema>> ReplaceFlowSchemaStatusWithHttpMessagesAsync(
            V1beta1FlowSchema body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1FlowSchema>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta2FlowSchema>> ReplaceFlowSchemaStatus1WithHttpMessagesAsync(
            V1beta2FlowSchema body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta2FlowSchema>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionPriorityLevelConfigurationWithHttpMessagesAsync(
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionPriorityLevelConfiguration1WithHttpMessagesAsync(
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1PriorityLevelConfigurationList>> ListPriorityLevelConfigurationWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1PriorityLevelConfigurationList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta2PriorityLevelConfigurationList>> ListPriorityLevelConfiguration1WithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta2PriorityLevelConfigurationList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1PriorityLevelConfiguration>> CreatePriorityLevelConfigurationWithHttpMessagesAsync(
            V1beta1PriorityLevelConfiguration body,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1PriorityLevelConfiguration>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta2PriorityLevelConfiguration>> CreatePriorityLevelConfiguration1WithHttpMessagesAsync(
            V1beta2PriorityLevelConfiguration body,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta2PriorityLevelConfiguration>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeletePriorityLevelConfigurationWithHttpMessagesAsync(
            string name,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeletePriorityLevelConfiguration1WithHttpMessagesAsync(
            string name,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1PriorityLevelConfiguration>> ReadPriorityLevelConfigurationWithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1PriorityLevelConfiguration>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta2PriorityLevelConfiguration>> ReadPriorityLevelConfiguration1WithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta2PriorityLevelConfiguration>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1PriorityLevelConfiguration>> PatchPriorityLevelConfigurationWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1PriorityLevelConfiguration>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta2PriorityLevelConfiguration>> PatchPriorityLevelConfiguration1WithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta2PriorityLevelConfiguration>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1PriorityLevelConfiguration>> ReplacePriorityLevelConfigurationWithHttpMessagesAsync(
            V1beta1PriorityLevelConfiguration body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1PriorityLevelConfiguration>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta2PriorityLevelConfiguration>> ReplacePriorityLevelConfiguration1WithHttpMessagesAsync(
            V1beta2PriorityLevelConfiguration body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta2PriorityLevelConfiguration>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1PriorityLevelConfiguration>> ReadPriorityLevelConfigurationStatusWithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1PriorityLevelConfiguration>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta2PriorityLevelConfiguration>> ReadPriorityLevelConfigurationStatus1WithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta2PriorityLevelConfiguration>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1PriorityLevelConfiguration>> PatchPriorityLevelConfigurationStatusWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1PriorityLevelConfiguration>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta2PriorityLevelConfiguration>> PatchPriorityLevelConfigurationStatus1WithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta2PriorityLevelConfiguration>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1PriorityLevelConfiguration>> ReplacePriorityLevelConfigurationStatusWithHttpMessagesAsync(
            V1beta1PriorityLevelConfiguration body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1PriorityLevelConfiguration>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta2PriorityLevelConfiguration>> ReplacePriorityLevelConfigurationStatus1WithHttpMessagesAsync(
            V1beta2PriorityLevelConfiguration body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta2PriorityLevelConfiguration>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionStorageVersionWithHttpMessagesAsync(
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/internal.apiserver.k8s.io/v1alpha1/storageversions").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1alpha1StorageVersionList>> ListStorageVersionWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/internal.apiserver.k8s.io/v1alpha1/storageversions").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1alpha1StorageVersionList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1alpha1StorageVersion>> CreateStorageVersionWithHttpMessagesAsync(
            V1alpha1StorageVersion body,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/internal.apiserver.k8s.io/v1alpha1/storageversions").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1alpha1StorageVersion>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteStorageVersionWithHttpMessagesAsync(
            string name,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/internal.apiserver.k8s.io/v1alpha1/storageversions/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1alpha1StorageVersion>> ReadStorageVersionWithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/internal.apiserver.k8s.io/v1alpha1/storageversions/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1alpha1StorageVersion>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1alpha1StorageVersion>> PatchStorageVersionWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/internal.apiserver.k8s.io/v1alpha1/storageversions/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1alpha1StorageVersion>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1alpha1StorageVersion>> ReplaceStorageVersionWithHttpMessagesAsync(
            V1alpha1StorageVersion body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/internal.apiserver.k8s.io/v1alpha1/storageversions/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1alpha1StorageVersion>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1alpha1StorageVersion>> ReadStorageVersionStatusWithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/internal.apiserver.k8s.io/v1alpha1/storageversions/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1alpha1StorageVersion>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1alpha1StorageVersion>> PatchStorageVersionStatusWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/internal.apiserver.k8s.io/v1alpha1/storageversions/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1alpha1StorageVersion>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1alpha1StorageVersion>> ReplaceStorageVersionStatusWithHttpMessagesAsync(
            V1alpha1StorageVersion body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/internal.apiserver.k8s.io/v1alpha1/storageversions/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1alpha1StorageVersion>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionIngressClassWithHttpMessagesAsync(
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/networking.k8s.io/v1/ingressclasses").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1IngressClassList>> ListIngressClassWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/networking.k8s.io/v1/ingressclasses").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1IngressClassList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1IngressClass>> CreateIngressClassWithHttpMessagesAsync(
            V1IngressClass body,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/networking.k8s.io/v1/ingressclasses").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1IngressClass>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteIngressClassWithHttpMessagesAsync(
            string name,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/networking.k8s.io/v1/ingressclasses/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1IngressClass>> ReadIngressClassWithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/networking.k8s.io/v1/ingressclasses/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1IngressClass>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1IngressClass>> PatchIngressClassWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/networking.k8s.io/v1/ingressclasses/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1IngressClass>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1IngressClass>> ReplaceIngressClassWithHttpMessagesAsync(
            V1IngressClass body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/networking.k8s.io/v1/ingressclasses/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1IngressClass>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1IngressList>> ListIngressForAllNamespacesWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/networking.k8s.io/v1/ingresses").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1IngressList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedIngressWithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/networking.k8s.io/v1/namespaces/{namespaceParameter}/ingresses").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1IngressList>> ListNamespacedIngressWithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/networking.k8s.io/v1/namespaces/{namespaceParameter}/ingresses").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1IngressList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Ingress>> CreateNamespacedIngressWithHttpMessagesAsync(
            V1Ingress body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/networking.k8s.io/v1/namespaces/{namespaceParameter}/ingresses").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Ingress>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteNamespacedIngressWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/networking.k8s.io/v1/namespaces/{namespaceParameter}/ingresses/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Ingress>> ReadNamespacedIngressWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/networking.k8s.io/v1/namespaces/{namespaceParameter}/ingresses/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Ingress>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Ingress>> PatchNamespacedIngressWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/networking.k8s.io/v1/namespaces/{namespaceParameter}/ingresses/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Ingress>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Ingress>> ReplaceNamespacedIngressWithHttpMessagesAsync(
            V1Ingress body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/networking.k8s.io/v1/namespaces/{namespaceParameter}/ingresses/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Ingress>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Ingress>> ReadNamespacedIngressStatusWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/networking.k8s.io/v1/namespaces/{namespaceParameter}/ingresses/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Ingress>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Ingress>> PatchNamespacedIngressStatusWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/networking.k8s.io/v1/namespaces/{namespaceParameter}/ingresses/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Ingress>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Ingress>> ReplaceNamespacedIngressStatusWithHttpMessagesAsync(
            V1Ingress body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/networking.k8s.io/v1/namespaces/{namespaceParameter}/ingresses/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Ingress>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedNetworkPolicyWithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/networking.k8s.io/v1/namespaces/{namespaceParameter}/networkpolicies").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1NetworkPolicyList>> ListNamespacedNetworkPolicyWithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/networking.k8s.io/v1/namespaces/{namespaceParameter}/networkpolicies").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1NetworkPolicyList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1NetworkPolicy>> CreateNamespacedNetworkPolicyWithHttpMessagesAsync(
            V1NetworkPolicy body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/networking.k8s.io/v1/namespaces/{namespaceParameter}/networkpolicies").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1NetworkPolicy>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteNamespacedNetworkPolicyWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/networking.k8s.io/v1/namespaces/{namespaceParameter}/networkpolicies/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1NetworkPolicy>> ReadNamespacedNetworkPolicyWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/networking.k8s.io/v1/namespaces/{namespaceParameter}/networkpolicies/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1NetworkPolicy>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1NetworkPolicy>> PatchNamespacedNetworkPolicyWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/networking.k8s.io/v1/namespaces/{namespaceParameter}/networkpolicies/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1NetworkPolicy>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1NetworkPolicy>> ReplaceNamespacedNetworkPolicyWithHttpMessagesAsync(
            V1NetworkPolicy body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/networking.k8s.io/v1/namespaces/{namespaceParameter}/networkpolicies/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1NetworkPolicy>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1NetworkPolicyList>> ListNetworkPolicyForAllNamespacesWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/networking.k8s.io/v1/networkpolicies").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1NetworkPolicyList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionRuntimeClassWithHttpMessagesAsync(
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/node.k8s.io/v1/runtimeclasses").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionRuntimeClass1WithHttpMessagesAsync(
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/node.k8s.io/v1alpha1/runtimeclasses").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionRuntimeClass2WithHttpMessagesAsync(
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/node.k8s.io/v1beta1/runtimeclasses").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1RuntimeClassList>> ListRuntimeClassWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/node.k8s.io/v1/runtimeclasses").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1RuntimeClassList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1alpha1RuntimeClassList>> ListRuntimeClass1WithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/node.k8s.io/v1alpha1/runtimeclasses").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1alpha1RuntimeClassList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1RuntimeClassList>> ListRuntimeClass2WithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/node.k8s.io/v1beta1/runtimeclasses").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1RuntimeClassList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1RuntimeClass>> CreateRuntimeClassWithHttpMessagesAsync(
            V1RuntimeClass body,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/node.k8s.io/v1/runtimeclasses").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1RuntimeClass>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1alpha1RuntimeClass>> CreateRuntimeClass1WithHttpMessagesAsync(
            V1alpha1RuntimeClass body,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/node.k8s.io/v1alpha1/runtimeclasses").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1alpha1RuntimeClass>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1RuntimeClass>> CreateRuntimeClass2WithHttpMessagesAsync(
            V1beta1RuntimeClass body,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/node.k8s.io/v1beta1/runtimeclasses").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1RuntimeClass>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteRuntimeClassWithHttpMessagesAsync(
            string name,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/node.k8s.io/v1/runtimeclasses/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteRuntimeClass1WithHttpMessagesAsync(
            string name,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/node.k8s.io/v1alpha1/runtimeclasses/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteRuntimeClass2WithHttpMessagesAsync(
            string name,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/node.k8s.io/v1beta1/runtimeclasses/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1RuntimeClass>> ReadRuntimeClassWithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/node.k8s.io/v1/runtimeclasses/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1RuntimeClass>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1alpha1RuntimeClass>> ReadRuntimeClass1WithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/node.k8s.io/v1alpha1/runtimeclasses/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1alpha1RuntimeClass>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1RuntimeClass>> ReadRuntimeClass2WithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/node.k8s.io/v1beta1/runtimeclasses/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1RuntimeClass>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1RuntimeClass>> PatchRuntimeClassWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/node.k8s.io/v1/runtimeclasses/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1RuntimeClass>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1alpha1RuntimeClass>> PatchRuntimeClass1WithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/node.k8s.io/v1alpha1/runtimeclasses/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1alpha1RuntimeClass>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1RuntimeClass>> PatchRuntimeClass2WithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/node.k8s.io/v1beta1/runtimeclasses/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1RuntimeClass>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1RuntimeClass>> ReplaceRuntimeClassWithHttpMessagesAsync(
            V1RuntimeClass body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/node.k8s.io/v1/runtimeclasses/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1RuntimeClass>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1alpha1RuntimeClass>> ReplaceRuntimeClass1WithHttpMessagesAsync(
            V1alpha1RuntimeClass body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/node.k8s.io/v1alpha1/runtimeclasses/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1alpha1RuntimeClass>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1RuntimeClass>> ReplaceRuntimeClass2WithHttpMessagesAsync(
            V1beta1RuntimeClass body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/node.k8s.io/v1beta1/runtimeclasses/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1RuntimeClass>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedPodDisruptionBudgetWithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/policy/v1/namespaces/{namespaceParameter}/poddisruptionbudgets").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedPodDisruptionBudget1WithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/policy/v1beta1/namespaces/{namespaceParameter}/poddisruptionbudgets").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PodDisruptionBudgetList>> ListNamespacedPodDisruptionBudgetWithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/policy/v1/namespaces/{namespaceParameter}/poddisruptionbudgets").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PodDisruptionBudgetList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1PodDisruptionBudgetList>> ListNamespacedPodDisruptionBudget1WithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/policy/v1beta1/namespaces/{namespaceParameter}/poddisruptionbudgets").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1PodDisruptionBudgetList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PodDisruptionBudget>> CreateNamespacedPodDisruptionBudgetWithHttpMessagesAsync(
            V1PodDisruptionBudget body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/policy/v1/namespaces/{namespaceParameter}/poddisruptionbudgets").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PodDisruptionBudget>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1PodDisruptionBudget>> CreateNamespacedPodDisruptionBudget1WithHttpMessagesAsync(
            V1beta1PodDisruptionBudget body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/policy/v1beta1/namespaces/{namespaceParameter}/poddisruptionbudgets").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1PodDisruptionBudget>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteNamespacedPodDisruptionBudgetWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/policy/v1/namespaces/{namespaceParameter}/poddisruptionbudgets/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteNamespacedPodDisruptionBudget1WithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/policy/v1beta1/namespaces/{namespaceParameter}/poddisruptionbudgets/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PodDisruptionBudget>> ReadNamespacedPodDisruptionBudgetWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/policy/v1/namespaces/{namespaceParameter}/poddisruptionbudgets/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PodDisruptionBudget>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1PodDisruptionBudget>> ReadNamespacedPodDisruptionBudget1WithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/policy/v1beta1/namespaces/{namespaceParameter}/poddisruptionbudgets/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1PodDisruptionBudget>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PodDisruptionBudget>> PatchNamespacedPodDisruptionBudgetWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/policy/v1/namespaces/{namespaceParameter}/poddisruptionbudgets/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PodDisruptionBudget>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1PodDisruptionBudget>> PatchNamespacedPodDisruptionBudget1WithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/policy/v1beta1/namespaces/{namespaceParameter}/poddisruptionbudgets/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1PodDisruptionBudget>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PodDisruptionBudget>> ReplaceNamespacedPodDisruptionBudgetWithHttpMessagesAsync(
            V1PodDisruptionBudget body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/policy/v1/namespaces/{namespaceParameter}/poddisruptionbudgets/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PodDisruptionBudget>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1PodDisruptionBudget>> ReplaceNamespacedPodDisruptionBudget1WithHttpMessagesAsync(
            V1beta1PodDisruptionBudget body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/policy/v1beta1/namespaces/{namespaceParameter}/poddisruptionbudgets/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1PodDisruptionBudget>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PodDisruptionBudget>> ReadNamespacedPodDisruptionBudgetStatusWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/policy/v1/namespaces/{namespaceParameter}/poddisruptionbudgets/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PodDisruptionBudget>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1PodDisruptionBudget>> ReadNamespacedPodDisruptionBudgetStatus1WithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/policy/v1beta1/namespaces/{namespaceParameter}/poddisruptionbudgets/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1PodDisruptionBudget>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PodDisruptionBudget>> PatchNamespacedPodDisruptionBudgetStatusWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/policy/v1/namespaces/{namespaceParameter}/poddisruptionbudgets/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PodDisruptionBudget>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1PodDisruptionBudget>> PatchNamespacedPodDisruptionBudgetStatus1WithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/policy/v1beta1/namespaces/{namespaceParameter}/poddisruptionbudgets/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1PodDisruptionBudget>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PodDisruptionBudget>> ReplaceNamespacedPodDisruptionBudgetStatusWithHttpMessagesAsync(
            V1PodDisruptionBudget body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/policy/v1/namespaces/{namespaceParameter}/poddisruptionbudgets/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PodDisruptionBudget>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1PodDisruptionBudget>> ReplaceNamespacedPodDisruptionBudgetStatus1WithHttpMessagesAsync(
            V1beta1PodDisruptionBudget body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/policy/v1beta1/namespaces/{namespaceParameter}/poddisruptionbudgets/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1PodDisruptionBudget>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PodDisruptionBudgetList>> ListPodDisruptionBudgetForAllNamespacesWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/policy/v1/poddisruptionbudgets").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PodDisruptionBudgetList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1PodDisruptionBudgetList>> ListPodDisruptionBudgetForAllNamespaces1WithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/policy/v1beta1/poddisruptionbudgets").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1PodDisruptionBudgetList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionPodSecurityPolicyWithHttpMessagesAsync(
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/policy/v1beta1/podsecuritypolicies").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1PodSecurityPolicyList>> ListPodSecurityPolicyWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/policy/v1beta1/podsecuritypolicies").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1PodSecurityPolicyList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1PodSecurityPolicy>> CreatePodSecurityPolicyWithHttpMessagesAsync(
            V1beta1PodSecurityPolicy body,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/policy/v1beta1/podsecuritypolicies").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1PodSecurityPolicy>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1PodSecurityPolicy>> DeletePodSecurityPolicyWithHttpMessagesAsync(
            string name,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/policy/v1beta1/podsecuritypolicies/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1PodSecurityPolicy>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1PodSecurityPolicy>> ReadPodSecurityPolicyWithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/policy/v1beta1/podsecuritypolicies/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1PodSecurityPolicy>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1PodSecurityPolicy>> PatchPodSecurityPolicyWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/policy/v1beta1/podsecuritypolicies/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1PodSecurityPolicy>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1PodSecurityPolicy>> ReplacePodSecurityPolicyWithHttpMessagesAsync(
            V1beta1PodSecurityPolicy body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/policy/v1beta1/podsecuritypolicies/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1PodSecurityPolicy>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionClusterRoleBindingWithHttpMessagesAsync(
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/rbac.authorization.k8s.io/v1/clusterrolebindings").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ClusterRoleBindingList>> ListClusterRoleBindingWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/rbac.authorization.k8s.io/v1/clusterrolebindings").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ClusterRoleBindingList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ClusterRoleBinding>> CreateClusterRoleBindingWithHttpMessagesAsync(
            V1ClusterRoleBinding body,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/rbac.authorization.k8s.io/v1/clusterrolebindings").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ClusterRoleBinding>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteClusterRoleBindingWithHttpMessagesAsync(
            string name,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/rbac.authorization.k8s.io/v1/clusterrolebindings/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ClusterRoleBinding>> ReadClusterRoleBindingWithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/rbac.authorization.k8s.io/v1/clusterrolebindings/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ClusterRoleBinding>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ClusterRoleBinding>> PatchClusterRoleBindingWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/rbac.authorization.k8s.io/v1/clusterrolebindings/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ClusterRoleBinding>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ClusterRoleBinding>> ReplaceClusterRoleBindingWithHttpMessagesAsync(
            V1ClusterRoleBinding body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/rbac.authorization.k8s.io/v1/clusterrolebindings/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ClusterRoleBinding>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionClusterRoleWithHttpMessagesAsync(
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/rbac.authorization.k8s.io/v1/clusterroles").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ClusterRoleList>> ListClusterRoleWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/rbac.authorization.k8s.io/v1/clusterroles").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ClusterRoleList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ClusterRole>> CreateClusterRoleWithHttpMessagesAsync(
            V1ClusterRole body,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/rbac.authorization.k8s.io/v1/clusterroles").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ClusterRole>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteClusterRoleWithHttpMessagesAsync(
            string name,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/rbac.authorization.k8s.io/v1/clusterroles/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ClusterRole>> ReadClusterRoleWithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/rbac.authorization.k8s.io/v1/clusterroles/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ClusterRole>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ClusterRole>> PatchClusterRoleWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/rbac.authorization.k8s.io/v1/clusterroles/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ClusterRole>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1ClusterRole>> ReplaceClusterRoleWithHttpMessagesAsync(
            V1ClusterRole body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/rbac.authorization.k8s.io/v1/clusterroles/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1ClusterRole>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedRoleBindingWithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/rbac.authorization.k8s.io/v1/namespaces/{namespaceParameter}/rolebindings").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1RoleBindingList>> ListNamespacedRoleBindingWithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/rbac.authorization.k8s.io/v1/namespaces/{namespaceParameter}/rolebindings").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1RoleBindingList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1RoleBinding>> CreateNamespacedRoleBindingWithHttpMessagesAsync(
            V1RoleBinding body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/rbac.authorization.k8s.io/v1/namespaces/{namespaceParameter}/rolebindings").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1RoleBinding>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteNamespacedRoleBindingWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/rbac.authorization.k8s.io/v1/namespaces/{namespaceParameter}/rolebindings/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1RoleBinding>> ReadNamespacedRoleBindingWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/rbac.authorization.k8s.io/v1/namespaces/{namespaceParameter}/rolebindings/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1RoleBinding>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1RoleBinding>> PatchNamespacedRoleBindingWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/rbac.authorization.k8s.io/v1/namespaces/{namespaceParameter}/rolebindings/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1RoleBinding>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1RoleBinding>> ReplaceNamespacedRoleBindingWithHttpMessagesAsync(
            V1RoleBinding body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/rbac.authorization.k8s.io/v1/namespaces/{namespaceParameter}/rolebindings/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1RoleBinding>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedRoleWithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/rbac.authorization.k8s.io/v1/namespaces/{namespaceParameter}/roles").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1RoleList>> ListNamespacedRoleWithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/rbac.authorization.k8s.io/v1/namespaces/{namespaceParameter}/roles").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1RoleList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Role>> CreateNamespacedRoleWithHttpMessagesAsync(
            V1Role body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/rbac.authorization.k8s.io/v1/namespaces/{namespaceParameter}/roles").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Role>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteNamespacedRoleWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/rbac.authorization.k8s.io/v1/namespaces/{namespaceParameter}/roles/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Role>> ReadNamespacedRoleWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/rbac.authorization.k8s.io/v1/namespaces/{namespaceParameter}/roles/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Role>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Role>> PatchNamespacedRoleWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/rbac.authorization.k8s.io/v1/namespaces/{namespaceParameter}/roles/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Role>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Role>> ReplaceNamespacedRoleWithHttpMessagesAsync(
            V1Role body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/rbac.authorization.k8s.io/v1/namespaces/{namespaceParameter}/roles/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Role>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1RoleBindingList>> ListRoleBindingForAllNamespacesWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/rbac.authorization.k8s.io/v1/rolebindings").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1RoleBindingList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1RoleList>> ListRoleForAllNamespacesWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/rbac.authorization.k8s.io/v1/roles").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1RoleList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionPriorityClassWithHttpMessagesAsync(
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/scheduling.k8s.io/v1/priorityclasses").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PriorityClassList>> ListPriorityClassWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/scheduling.k8s.io/v1/priorityclasses").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PriorityClassList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PriorityClass>> CreatePriorityClassWithHttpMessagesAsync(
            V1PriorityClass body,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/scheduling.k8s.io/v1/priorityclasses").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PriorityClass>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeletePriorityClassWithHttpMessagesAsync(
            string name,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/scheduling.k8s.io/v1/priorityclasses/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PriorityClass>> ReadPriorityClassWithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/scheduling.k8s.io/v1/priorityclasses/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PriorityClass>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PriorityClass>> PatchPriorityClassWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/scheduling.k8s.io/v1/priorityclasses/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PriorityClass>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1PriorityClass>> ReplacePriorityClassWithHttpMessagesAsync(
            V1PriorityClass body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/scheduling.k8s.io/v1/priorityclasses/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1PriorityClass>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionCSIDriverWithHttpMessagesAsync(
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1/csidrivers").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CSIDriverList>> ListCSIDriverWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1/csidrivers").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CSIDriverList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CSIDriver>> CreateCSIDriverWithHttpMessagesAsync(
            V1CSIDriver body,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1/csidrivers").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CSIDriver>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CSIDriver>> DeleteCSIDriverWithHttpMessagesAsync(
            string name,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1/csidrivers/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CSIDriver>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CSIDriver>> ReadCSIDriverWithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1/csidrivers/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CSIDriver>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CSIDriver>> PatchCSIDriverWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1/csidrivers/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CSIDriver>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CSIDriver>> ReplaceCSIDriverWithHttpMessagesAsync(
            V1CSIDriver body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1/csidrivers/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CSIDriver>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionCSINodeWithHttpMessagesAsync(
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1/csinodes").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CSINodeList>> ListCSINodeWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1/csinodes").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CSINodeList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CSINode>> CreateCSINodeWithHttpMessagesAsync(
            V1CSINode body,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1/csinodes").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CSINode>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CSINode>> DeleteCSINodeWithHttpMessagesAsync(
            string name,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1/csinodes/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CSINode>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CSINode>> ReadCSINodeWithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1/csinodes/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CSINode>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CSINode>> PatchCSINodeWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1/csinodes/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CSINode>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1CSINode>> ReplaceCSINodeWithHttpMessagesAsync(
            V1CSINode body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1/csinodes/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1CSINode>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionStorageClassWithHttpMessagesAsync(
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1/storageclasses").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1StorageClassList>> ListStorageClassWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1/storageclasses").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1StorageClassList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1StorageClass>> CreateStorageClassWithHttpMessagesAsync(
            V1StorageClass body,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1/storageclasses").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1StorageClass>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1StorageClass>> DeleteStorageClassWithHttpMessagesAsync(
            string name,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1/storageclasses/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1StorageClass>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1StorageClass>> ReadStorageClassWithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1/storageclasses/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1StorageClass>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1StorageClass>> PatchStorageClassWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1/storageclasses/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1StorageClass>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1StorageClass>> ReplaceStorageClassWithHttpMessagesAsync(
            V1StorageClass body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1/storageclasses/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1StorageClass>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionVolumeAttachmentWithHttpMessagesAsync(
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1/volumeattachments").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1VolumeAttachmentList>> ListVolumeAttachmentWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1/volumeattachments").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1VolumeAttachmentList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1VolumeAttachment>> CreateVolumeAttachmentWithHttpMessagesAsync(
            V1VolumeAttachment body,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1/volumeattachments").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1VolumeAttachment>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1VolumeAttachment>> DeleteVolumeAttachmentWithHttpMessagesAsync(
            string name,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1/volumeattachments/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1VolumeAttachment>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1VolumeAttachment>> ReadVolumeAttachmentWithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1/volumeattachments/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1VolumeAttachment>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1VolumeAttachment>> PatchVolumeAttachmentWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1/volumeattachments/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1VolumeAttachment>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1VolumeAttachment>> ReplaceVolumeAttachmentWithHttpMessagesAsync(
            V1VolumeAttachment body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1/volumeattachments/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1VolumeAttachment>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1VolumeAttachment>> ReadVolumeAttachmentStatusWithHttpMessagesAsync(
            string name,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1/volumeattachments/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1VolumeAttachment>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1VolumeAttachment>> PatchVolumeAttachmentStatusWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1/volumeattachments/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1VolumeAttachment>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1VolumeAttachment>> ReplaceVolumeAttachmentStatusWithHttpMessagesAsync(
            V1VolumeAttachment body,
            string name,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1/volumeattachments/{name}/status").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1VolumeAttachment>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1alpha1CSIStorageCapacityList>> ListCSIStorageCapacityForAllNamespacesWithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1alpha1/csistoragecapacities").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1alpha1CSIStorageCapacityList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1CSIStorageCapacityList>> ListCSIStorageCapacityForAllNamespaces1WithHttpMessagesAsync(
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            bool? pretty = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1beta1/csistoragecapacities").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("pretty", pretty);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1CSIStorageCapacityList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedCSIStorageCapacityWithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1alpha1/namespaces/{namespaceParameter}/csistoragecapacities").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteCollectionNamespacedCSIStorageCapacity1WithHttpMessagesAsync(
            string namespaceParameter,
            V1DeleteOptions body = null,
            string continueParameter = null,
            string dryRun = null,
            string fieldSelector = null,
            int? gracePeriodSeconds = null,
            string labelSelector = null,
            int? limit = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1beta1/namespaces/{namespaceParameter}/csistoragecapacities").ToString();
            var q = new QueryBuilder();
            q.Append("continue", continueParameter);
            q.Append("dryRun", dryRun);
            q.Append("fieldSelector", fieldSelector);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1alpha1CSIStorageCapacityList>> ListNamespacedCSIStorageCapacityWithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1alpha1/namespaces/{namespaceParameter}/csistoragecapacities").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1alpha1CSIStorageCapacityList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1CSIStorageCapacityList>> ListNamespacedCSIStorageCapacity1WithHttpMessagesAsync(
            string namespaceParameter,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1beta1/namespaces/{namespaceParameter}/csistoragecapacities").ToString();
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1CSIStorageCapacityList>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1alpha1CSIStorageCapacity>> CreateNamespacedCSIStorageCapacityWithHttpMessagesAsync(
            V1alpha1CSIStorageCapacity body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1alpha1/namespaces/{namespaceParameter}/csistoragecapacities").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1alpha1CSIStorageCapacity>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1CSIStorageCapacity>> CreateNamespacedCSIStorageCapacity1WithHttpMessagesAsync(
            V1beta1CSIStorageCapacity body,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1beta1/namespaces/{namespaceParameter}/csistoragecapacities").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1CSIStorageCapacity>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteNamespacedCSIStorageCapacityWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1alpha1/namespaces/{namespaceParameter}/csistoragecapacities/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1Status>> DeleteNamespacedCSIStorageCapacity1WithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            V1DeleteOptions body = null,
            string dryRun = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1beta1/namespaces/{namespaceParameter}/csistoragecapacities/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1Status>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1alpha1CSIStorageCapacity>> ReadNamespacedCSIStorageCapacityWithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1alpha1/namespaces/{namespaceParameter}/csistoragecapacities/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1alpha1CSIStorageCapacity>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1CSIStorageCapacity>> ReadNamespacedCSIStorageCapacity1WithHttpMessagesAsync(
            string name,
            string namespaceParameter,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1beta1/namespaces/{namespaceParameter}/csistoragecapacities/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1CSIStorageCapacity>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1alpha1CSIStorageCapacity>> PatchNamespacedCSIStorageCapacityWithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1alpha1/namespaces/{namespaceParameter}/csistoragecapacities/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1alpha1CSIStorageCapacity>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1CSIStorageCapacity>> PatchNamespacedCSIStorageCapacity1WithHttpMessagesAsync(
            V1Patch body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? force = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1beta1/namespaces/{namespaceParameter}/csistoragecapacities/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("force", force);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1CSIStorageCapacity>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1alpha1CSIStorageCapacity>> ReplaceNamespacedCSIStorageCapacityWithHttpMessagesAsync(
            V1alpha1CSIStorageCapacity body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1alpha1/namespaces/{namespaceParameter}/csistoragecapacities/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1alpha1CSIStorageCapacity>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<V1beta1CSIStorageCapacity>> ReplaceNamespacedCSIStorageCapacity1WithHttpMessagesAsync(
            V1beta1CSIStorageCapacity body,
            string name,
            string namespaceParameter,
            string dryRun = null,
            string fieldManager = null,
            string fieldValidation = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/storage.k8s.io/v1beta1/namespaces/{namespaceParameter}/csistoragecapacities/{name}").ToString();
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("fieldValidation", fieldValidation);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<V1beta1CSIStorageCapacity>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse> LogFileListHandlerWithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"logs/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            HttpOperationResponse result = new HttpOperationResponse() { Request = httpRequest, Response =  httpResponse };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse> LogFileHandlerWithHttpMessagesAsync(
            string logpath,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (logpath == null)
            {
                throw new ArgumentNullException("logpath");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"logs/{logpath}").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            HttpOperationResponse result = new HttpOperationResponse() { Request = httpRequest, Response =  httpResponse };
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<string>> GetServiceAccountIssuerOpenIDKeysetWithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"openid/v1/jwks/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<string>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<VersionInfo>> GetCodeWithHttpMessagesAsync(
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;


            // Construct URL
            var url = new System.Uri(BaseUri, $"version/").ToString();
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<VersionInfo>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<object>> ListClusterCustomObjectWithHttpMessagesAsync(
            string group,
            string version,
            string plural,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (group == null)
            {
                throw new ArgumentNullException("group");
            }
            if (version == null)
            {
                throw new ArgumentNullException("version");
            }
            if (plural == null)
            {
                throw new ArgumentNullException("plural");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/{group}/{version}/{plural}").ToString();
            url = url.Replace("/apis//", "/api/");
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<object>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<object>> CreateClusterCustomObjectWithHttpMessagesAsync(
            object body,
            string group,
            string version,
            string plural,
            string dryRun = null,
            string fieldManager = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (group == null)
            {
                throw new ArgumentNullException("group");
            }
            if (version == null)
            {
                throw new ArgumentNullException("version");
            }
            if (plural == null)
            {
                throw new ArgumentNullException("plural");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/{group}/{version}/{plural}").ToString();
            url = url.Replace("/apis//", "/api/");
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<object>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<object>> DeleteCollectionClusterCustomObjectWithHttpMessagesAsync(
            string group,
            string version,
            string plural,
            V1DeleteOptions body = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string dryRun = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (group == null)
            {
                throw new ArgumentNullException("group");
            }
            if (version == null)
            {
                throw new ArgumentNullException("version");
            }
            if (plural == null)
            {
                throw new ArgumentNullException("plural");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/{group}/{version}/{plural}").ToString();
            url = url.Replace("/apis//", "/api/");
            var q = new QueryBuilder();
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("dryRun", dryRun);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<object>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<object>> ListNamespacedCustomObjectWithHttpMessagesAsync(
            string group,
            string version,
            string namespaceParameter,
            string plural,
            bool? allowWatchBookmarks = null,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            string resourceVersionMatch = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            if (watch == true)
            {
                cts.CancelAfter(Timeout.InfiniteTimeSpan);
            }
            cancellationToken = cts.Token;

            if (group == null)
            {
                throw new ArgumentNullException("group");
            }
            if (version == null)
            {
                throw new ArgumentNullException("version");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }
            if (plural == null)
            {
                throw new ArgumentNullException("plural");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/{group}/{version}/namespaces/{namespaceParameter}/{plural}").ToString();
            url = url.Replace("/apis//", "/api/");
            var q = new QueryBuilder();
            q.Append("allowWatchBookmarks", allowWatchBookmarks);
            q.Append("continue", continueParameter);
            q.Append("fieldSelector", fieldSelector);
            q.Append("labelSelector", labelSelector);
            q.Append("limit", limit);
            q.Append("resourceVersion", resourceVersion);
            q.Append("resourceVersionMatch", resourceVersionMatch);
            q.Append("timeoutSeconds", timeoutSeconds);
            q.Append("watch", watch);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<object>(httpRequest,
                httpResponse,
                watch,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<object>> CreateNamespacedCustomObjectWithHttpMessagesAsync(
            object body,
            string group,
            string version,
            string namespaceParameter,
            string plural,
            string dryRun = null,
            string fieldManager = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (group == null)
            {
                throw new ArgumentNullException("group");
            }
            if (version == null)
            {
                throw new ArgumentNullException("version");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }
            if (plural == null)
            {
                throw new ArgumentNullException("plural");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/{group}/{version}/namespaces/{namespaceParameter}/{plural}").ToString();
            url = url.Replace("/apis//", "/api/");
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<object>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<object>> DeleteCollectionNamespacedCustomObjectWithHttpMessagesAsync(
            string group,
            string version,
            string namespaceParameter,
            string plural,
            V1DeleteOptions body = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string dryRun = null,
            bool? pretty = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (group == null)
            {
                throw new ArgumentNullException("group");
            }
            if (version == null)
            {
                throw new ArgumentNullException("version");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }
            if (plural == null)
            {
                throw new ArgumentNullException("plural");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/{group}/{version}/namespaces/{namespaceParameter}/{plural}").ToString();
            url = url.Replace("/apis//", "/api/");
            var q = new QueryBuilder();
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("dryRun", dryRun);
            q.Append("pretty", pretty);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<object>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<object>> GetClusterCustomObjectWithHttpMessagesAsync(
            string group,
            string version,
            string plural,
            string name,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (group == null)
            {
                throw new ArgumentNullException("group");
            }
            if (version == null)
            {
                throw new ArgumentNullException("version");
            }
            if (plural == null)
            {
                throw new ArgumentNullException("plural");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/{group}/{version}/{plural}/{name}").ToString();
            url = url.Replace("/apis//", "/api/");
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<object>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<object>> DeleteClusterCustomObjectWithHttpMessagesAsync(
            string group,
            string version,
            string plural,
            string name,
            V1DeleteOptions body = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string dryRun = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (group == null)
            {
                throw new ArgumentNullException("group");
            }
            if (version == null)
            {
                throw new ArgumentNullException("version");
            }
            if (plural == null)
            {
                throw new ArgumentNullException("plural");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/{group}/{version}/{plural}/{name}").ToString();
            url = url.Replace("/apis//", "/api/");
            var q = new QueryBuilder();
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("dryRun", dryRun);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<object>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<object>> PatchClusterCustomObjectWithHttpMessagesAsync(
            object body,
            string group,
            string version,
            string plural,
            string name,
            string dryRun = null,
            string fieldManager = null,
            bool? force = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (group == null)
            {
                throw new ArgumentNullException("group");
            }
            if (version == null)
            {
                throw new ArgumentNullException("version");
            }
            if (plural == null)
            {
                throw new ArgumentNullException("plural");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/{group}/{version}/{plural}/{name}").ToString();
            url = url.Replace("/apis//", "/api/");
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("force", force);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<object>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<object>> ReplaceClusterCustomObjectWithHttpMessagesAsync(
            object body,
            string group,
            string version,
            string plural,
            string name,
            string dryRun = null,
            string fieldManager = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (group == null)
            {
                throw new ArgumentNullException("group");
            }
            if (version == null)
            {
                throw new ArgumentNullException("version");
            }
            if (plural == null)
            {
                throw new ArgumentNullException("plural");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/{group}/{version}/{plural}/{name}").ToString();
            url = url.Replace("/apis//", "/api/");
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<object>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<object>> GetClusterCustomObjectStatusWithHttpMessagesAsync(
            string group,
            string version,
            string plural,
            string name,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (group == null)
            {
                throw new ArgumentNullException("group");
            }
            if (version == null)
            {
                throw new ArgumentNullException("version");
            }
            if (plural == null)
            {
                throw new ArgumentNullException("plural");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/{group}/{version}/{plural}/{name}/status").ToString();
            url = url.Replace("/apis//", "/api/");
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<object>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<object>> ReplaceClusterCustomObjectStatusWithHttpMessagesAsync(
            object body,
            string group,
            string version,
            string plural,
            string name,
            string dryRun = null,
            string fieldManager = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (group == null)
            {
                throw new ArgumentNullException("group");
            }
            if (version == null)
            {
                throw new ArgumentNullException("version");
            }
            if (plural == null)
            {
                throw new ArgumentNullException("plural");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/{group}/{version}/{plural}/{name}/status").ToString();
            url = url.Replace("/apis//", "/api/");
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<object>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<object>> PatchClusterCustomObjectStatusWithHttpMessagesAsync(
            object body,
            string group,
            string version,
            string plural,
            string name,
            string dryRun = null,
            string fieldManager = null,
            bool? force = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (group == null)
            {
                throw new ArgumentNullException("group");
            }
            if (version == null)
            {
                throw new ArgumentNullException("version");
            }
            if (plural == null)
            {
                throw new ArgumentNullException("plural");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/{group}/{version}/{plural}/{name}/status").ToString();
            url = url.Replace("/apis//", "/api/");
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("force", force);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<object>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<object>> GetClusterCustomObjectScaleWithHttpMessagesAsync(
            string group,
            string version,
            string plural,
            string name,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (group == null)
            {
                throw new ArgumentNullException("group");
            }
            if (version == null)
            {
                throw new ArgumentNullException("version");
            }
            if (plural == null)
            {
                throw new ArgumentNullException("plural");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/{group}/{version}/{plural}/{name}/scale").ToString();
            url = url.Replace("/apis//", "/api/");
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<object>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<object>> ReplaceClusterCustomObjectScaleWithHttpMessagesAsync(
            object body,
            string group,
            string version,
            string plural,
            string name,
            string dryRun = null,
            string fieldManager = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (group == null)
            {
                throw new ArgumentNullException("group");
            }
            if (version == null)
            {
                throw new ArgumentNullException("version");
            }
            if (plural == null)
            {
                throw new ArgumentNullException("plural");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/{group}/{version}/{plural}/{name}/scale").ToString();
            url = url.Replace("/apis//", "/api/");
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<object>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<object>> PatchClusterCustomObjectScaleWithHttpMessagesAsync(
            object body,
            string group,
            string version,
            string plural,
            string name,
            string dryRun = null,
            string fieldManager = null,
            bool? force = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (group == null)
            {
                throw new ArgumentNullException("group");
            }
            if (version == null)
            {
                throw new ArgumentNullException("version");
            }
            if (plural == null)
            {
                throw new ArgumentNullException("plural");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/{group}/{version}/{plural}/{name}/scale").ToString();
            url = url.Replace("/apis//", "/api/");
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("force", force);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<object>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<object>> GetNamespacedCustomObjectWithHttpMessagesAsync(
            string group,
            string version,
            string namespaceParameter,
            string plural,
            string name,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (group == null)
            {
                throw new ArgumentNullException("group");
            }
            if (version == null)
            {
                throw new ArgumentNullException("version");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }
            if (plural == null)
            {
                throw new ArgumentNullException("plural");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/{group}/{version}/namespaces/{namespaceParameter}/{plural}/{name}").ToString();
            url = url.Replace("/apis//", "/api/");
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<object>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<object>> DeleteNamespacedCustomObjectWithHttpMessagesAsync(
            string group,
            string version,
            string namespaceParameter,
            string plural,
            string name,
            V1DeleteOptions body = null,
            int? gracePeriodSeconds = null,
            bool? orphanDependents = null,
            string propagationPolicy = null,
            string dryRun = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (group == null)
            {
                throw new ArgumentNullException("group");
            }
            if (version == null)
            {
                throw new ArgumentNullException("version");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }
            if (plural == null)
            {
                throw new ArgumentNullException("plural");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/{group}/{version}/namespaces/{namespaceParameter}/{plural}/{name}").ToString();
            url = url.Replace("/apis//", "/api/");
            var q = new QueryBuilder();
            q.Append("gracePeriodSeconds", gracePeriodSeconds);
            q.Append("orphanDependents", orphanDependents);
            q.Append("propagationPolicy", propagationPolicy);
            q.Append("dryRun", dryRun);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<object>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<object>> PatchNamespacedCustomObjectWithHttpMessagesAsync(
            object body,
            string group,
            string version,
            string namespaceParameter,
            string plural,
            string name,
            string dryRun = null,
            string fieldManager = null,
            bool? force = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (group == null)
            {
                throw new ArgumentNullException("group");
            }
            if (version == null)
            {
                throw new ArgumentNullException("version");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }
            if (plural == null)
            {
                throw new ArgumentNullException("plural");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/{group}/{version}/namespaces/{namespaceParameter}/{plural}/{name}").ToString();
            url = url.Replace("/apis//", "/api/");
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("force", force);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<object>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<object>> ReplaceNamespacedCustomObjectWithHttpMessagesAsync(
            object body,
            string group,
            string version,
            string namespaceParameter,
            string plural,
            string name,
            string dryRun = null,
            string fieldManager = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (group == null)
            {
                throw new ArgumentNullException("group");
            }
            if (version == null)
            {
                throw new ArgumentNullException("version");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }
            if (plural == null)
            {
                throw new ArgumentNullException("plural");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/{group}/{version}/namespaces/{namespaceParameter}/{plural}/{name}").ToString();
            url = url.Replace("/apis//", "/api/");
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<object>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<object>> GetNamespacedCustomObjectStatusWithHttpMessagesAsync(
            string group,
            string version,
            string namespaceParameter,
            string plural,
            string name,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (group == null)
            {
                throw new ArgumentNullException("group");
            }
            if (version == null)
            {
                throw new ArgumentNullException("version");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }
            if (plural == null)
            {
                throw new ArgumentNullException("plural");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/{group}/{version}/namespaces/{namespaceParameter}/{plural}/{name}/status").ToString();
            url = url.Replace("/apis//", "/api/");
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<object>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<object>> ReplaceNamespacedCustomObjectStatusWithHttpMessagesAsync(
            object body,
            string group,
            string version,
            string namespaceParameter,
            string plural,
            string name,
            string dryRun = null,
            string fieldManager = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (group == null)
            {
                throw new ArgumentNullException("group");
            }
            if (version == null)
            {
                throw new ArgumentNullException("version");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }
            if (plural == null)
            {
                throw new ArgumentNullException("plural");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/{group}/{version}/namespaces/{namespaceParameter}/{plural}/{name}/status").ToString();
            url = url.Replace("/apis//", "/api/");
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<object>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<object>> PatchNamespacedCustomObjectStatusWithHttpMessagesAsync(
            object body,
            string group,
            string version,
            string namespaceParameter,
            string plural,
            string name,
            string dryRun = null,
            string fieldManager = null,
            bool? force = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (group == null)
            {
                throw new ArgumentNullException("group");
            }
            if (version == null)
            {
                throw new ArgumentNullException("version");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }
            if (plural == null)
            {
                throw new ArgumentNullException("plural");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/{group}/{version}/namespaces/{namespaceParameter}/{plural}/{name}/status").ToString();
            url = url.Replace("/apis//", "/api/");
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("force", force);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<object>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<object>> GetNamespacedCustomObjectScaleWithHttpMessagesAsync(
            string group,
            string version,
            string namespaceParameter,
            string plural,
            string name,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (group == null)
            {
                throw new ArgumentNullException("group");
            }
            if (version == null)
            {
                throw new ArgumentNullException("version");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }
            if (plural == null)
            {
                throw new ArgumentNullException("plural");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/{group}/{version}/namespaces/{namespaceParameter}/{plural}/{name}/scale").ToString();
            url = url.Replace("/apis//", "/api/");
            var q = new QueryBuilder();
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
            var httpResponse = await SendRequestRaw("", httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<object>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<object>> ReplaceNamespacedCustomObjectScaleWithHttpMessagesAsync(
            object body,
            string group,
            string version,
            string namespaceParameter,
            string plural,
            string name,
            string dryRun = null,
            string fieldManager = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (group == null)
            {
                throw new ArgumentNullException("group");
            }
            if (version == null)
            {
                throw new ArgumentNullException("version");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }
            if (plural == null)
            {
                throw new ArgumentNullException("plural");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/{group}/{version}/namespaces/{namespaceParameter}/{plural}/{name}/scale").ToString();
            url = url.Replace("/apis//", "/api/");
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Put, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<object>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
        /// <inheritdoc/>
        public async Task<HttpOperationResponse<object>> PatchNamespacedCustomObjectScaleWithHttpMessagesAsync(
            object body,
            string group,
            string version,
            string namespaceParameter,
            string plural,
            string name,
            string dryRun = null,
            string fieldManager = null,
            bool? force = null,
            IDictionary<string, IList<string>> customHeaders = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(HttpClientTimeout);
            cancellationToken = cts.Token;

            if (body == null)
            {
                throw new ArgumentNullException("body");
            }
            if (group == null)
            {
                throw new ArgumentNullException("group");
            }
            if (version == null)
            {
                throw new ArgumentNullException("version");
            }
            if (namespaceParameter == null)
            {
                throw new ArgumentNullException("namespaceParameter");
            }
            if (plural == null)
            {
                throw new ArgumentNullException("plural");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            // Construct URL
            var url = new System.Uri(BaseUri, $"apis/{group}/{version}/namespaces/{namespaceParameter}/{plural}/{name}/scale").ToString();
            url = url.Replace("/apis//", "/api/");
            var q = new QueryBuilder();
            q.Append("dryRun", dryRun);
            q.Append("fieldManager", fieldManager);
            q.Append("force", force);
            url += q.ToString();

            // Create HTTP transport
            var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
            var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
            // Create Result
            var result = await CreateResultAsync<object>(httpRequest,
                httpResponse,
                false,
                cancellationToken);
            return result;
        }
    }
}
