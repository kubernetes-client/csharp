// <auto-generated>
// Code generated by https://github.com/kubernetes-client/csharp/tree/master/gen/KubernetesGenerator
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace k8s.Models
{
    using Microsoft.Rest;
    using Newtonsoft.Json;
    using System.Collections.Generic;
    using System.Collections;
    using System.Linq;

    /// <summary>
    /// ServiceSpec describes the attributes that a user creates on a service.
    /// </summary>
    public partial class V1ServiceSpec
    {
        /// <summary>
        /// Initializes a new instance of the V1ServiceSpec class.
        /// </summary>
        public V1ServiceSpec()
        {
            CustomInit();
        }

        /// <summary>
        /// Initializes a new instance of the V1ServiceSpec class.
        /// </summary>
        /// <param name="allocateLoadBalancerNodePorts">
        /// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
        /// allocated for services with type LoadBalancer.  Default is &quot;true&quot;. It may be set
        /// to &quot;false&quot; if the cluster load-balancer does not rely on NodePorts.  If the
        /// caller requests specific NodePorts (by specifying a value), those requests will
        /// be respected, regardless of this field. This field may only be set for services
        /// with type LoadBalancer and will be cleared if the type is changed to any other
        /// type. This field is beta-level and is only honored by servers that enable the
        /// ServiceLBNodePortControl feature.
        /// </param>
        /// <param name="clusterIP">
        /// clusterIP is the IP address of the service and is usually assigned randomly. If
        /// an address is specified manually, is in-range (as per system configuration), and
        /// is not in use, it will be allocated to the service; otherwise creation of the
        /// service will fail. This field may not be changed through updates unless the type
        /// field is also being changed to ExternalName (which requires this field to be
        /// blank) or the type field is being changed from ExternalName (in which case this
        /// field may optionally be specified, as describe above).  Valid values are &quot;None&quot;,
        /// empty string (&quot;&quot;), or a valid IP address. Setting this to &quot;None&quot; makes a
        /// &quot;headless service&quot; (no virtual IP), which is useful when direct endpoint
        /// connections are preferred and proxying is not required.  Only applies to types
        /// ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating
        /// a Service of type ExternalName, creation will fail. This field will be wiped
        /// when updating a Service to type ExternalName. More info:
        /// https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
        /// </param>
        /// <param name="clusterIPs">
        /// ClusterIPs is a list of IP addresses assigned to this service, and are usually
        /// assigned randomly.  If an address is specified manually, is in-range (as per
        /// system configuration), and is not in use, it will be allocated to the service;
        /// otherwise creation of the service will fail. This field may not be changed
        /// through updates unless the type field is also being changed to ExternalName
        /// (which requires this field to be empty) or the type field is being changed from
        /// ExternalName (in which case this field may optionally be specified, as describe
        /// above).  Valid values are &quot;None&quot;, empty string (&quot;&quot;), or a valid IP address. 
        /// Setting this to &quot;None&quot; makes a &quot;headless service&quot; (no virtual IP), which is
        /// useful when direct endpoint connections are preferred and proxying is not
        /// required.  Only applies to types ClusterIP, NodePort, and LoadBalancer. If this
        /// field is specified when creating a Service of type ExternalName, creation will
        /// fail. This field will be wiped when updating a Service to type ExternalName.  If
        /// this field is not specified, it will be initialized from the clusterIP field. 
        /// If this field is specified, clients must ensure that clusterIPs[0] and clusterIP
        /// have the same value.
        /// 
        /// Unless the &quot;IPv6DualStack&quot; feature gate is enabled, this field is limited to one
        /// value, which must be the same as the clusterIP field.  If the feature gate is
        /// enabled, this field may hold a maximum of two entries (dual-stack IPs, in either
        /// order).  These IPs must correspond to the values of the ipFamilies field. Both
        /// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field. More info:
        /// https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
        /// </param>
        /// <param name="externalIPs">
        /// externalIPs is a list of IP addresses for which nodes in the cluster will also
        /// accept traffic for this service.  These IPs are not managed by Kubernetes.  The
        /// user is responsible for ensuring that traffic arrives at a node with this IP.  A
        /// common example is external load-balancers that are not part of the Kubernetes
        /// system.
        /// </param>
        /// <param name="externalName">
        /// externalName is the external reference that discovery mechanisms will return as
        /// an alias for this service (e.g. a DNS CNAME record). No proxying will be
        /// involved.  Must be a lowercase RFC-1123 hostname
        /// (https://tools.ietf.org/html/rfc1123) and requires `type` to be &quot;ExternalName&quot;.
        /// </param>
        /// <param name="externalTrafficPolicy">
        /// externalTrafficPolicy denotes if this Service desires to route external traffic
        /// to node-local or cluster-wide endpoints. &quot;Local&quot; preserves the client source IP
        /// and avoids a second hop for LoadBalancer and Nodeport type services, but risks
        /// potentially imbalanced traffic spreading. &quot;Cluster&quot; obscures the client source
        /// IP and may cause a second hop to another node, but should have good overall
        /// load-spreading.
        /// </param>
        /// <param name="healthCheckNodePort">
        /// healthCheckNodePort specifies the healthcheck nodePort for the service. This
        /// only applies when type is set to LoadBalancer and externalTrafficPolicy is set
        /// to Local. If a value is specified, is in-range, and is not in use, it will be
        /// used.  If not specified, a value will be automatically allocated.  External
        /// systems (e.g. load-balancers) can use this port to determine if a given node
        /// holds endpoints for this service or not.  If this field is specified when
        /// creating a Service which does not need it, creation will fail. This field will
        /// be wiped when updating a Service to no longer need it (e.g. changing type).
        /// </param>
        /// <param name="internalTrafficPolicy">
        /// InternalTrafficPolicy specifies if the cluster internal traffic should be routed
        /// to all endpoints or node-local endpoints only. &quot;Cluster&quot; routes internal traffic
        /// to a Service to all endpoints. &quot;Local&quot; routes traffic to node-local endpoints
        /// only, traffic is dropped if no node-local endpoints are ready. The default value
        /// is &quot;Cluster&quot;.
        /// </param>
        /// <param name="ipFamilies">
        /// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this service,
        /// and is gated by the &quot;IPv6DualStack&quot; feature gate.  This field is usually
        /// assigned automatically based on cluster configuration and the ipFamilyPolicy
        /// field. If this field is specified manually, the requested family is available in
        /// the cluster, and ipFamilyPolicy allows it, it will be used; otherwise creation
        /// of the service will fail.  This field is conditionally mutable: it allows for
        /// adding or removing a secondary IP family, but it does not allow changing the
        /// primary IP family of the Service.  Valid values are &quot;IPv4&quot; and &quot;IPv6&quot;.  This
        /// field only applies to Services of types ClusterIP, NodePort, and LoadBalancer,
        /// and does apply to &quot;headless&quot; services.  This field will be wiped when updating a
        /// Service to type ExternalName.
        /// 
        /// This field may hold a maximum of two entries (dual-stack families, in either
        /// order).  These families must correspond to the values of the clusterIPs field,
        /// if specified. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy
        /// field.
        /// </param>
        /// <param name="ipFamilyPolicy">
        /// IPFamilyPolicy represents the dual-stack-ness requested or required by this
        /// Service, and is gated by the &quot;IPv6DualStack&quot; feature gate.  If there is no value
        /// provided, then this field will be set to SingleStack. Services can be
        /// &quot;SingleStack&quot; (a single IP family), &quot;PreferDualStack&quot; (two IP families on
        /// dual-stack configured clusters or a single IP family on single-stack clusters),
        /// or &quot;RequireDualStack&quot; (two IP families on dual-stack configured clusters,
        /// otherwise fail). The ipFamilies and clusterIPs fields depend on the value of
        /// this field.  This field will be wiped when updating a service to type
        /// ExternalName.
        /// </param>
        /// <param name="loadBalancerClass">
        /// loadBalancerClass is the class of the load balancer implementation this Service
        /// belongs to. If specified, the value of this field must be a label-style
        /// identifier, with an optional prefix, e.g. &quot;internal-vip&quot; or
        /// &quot;example.com/internal-vip&quot;. Unprefixed names are reserved for end-users. This
        /// field can only be set when the Service type is &apos;LoadBalancer&apos;. If not set, the
        /// default load balancer implementation is used, today this is typically done
        /// through the cloud provider integration, but should apply for any default
        /// implementation. If set, it is assumed that a load balancer implementation is
        /// watching for Services with a matching class. Any default load balancer
        /// implementation (e.g. cloud providers) should ignore Services that set this
        /// field. This field can only be set when creating or updating a Service to type
        /// &apos;LoadBalancer&apos;. Once set, it can not be changed. This field will be wiped when a
        /// service is updated to a non &apos;LoadBalancer&apos; type.
        /// </param>
        /// <param name="loadBalancerIP">
        /// Only applies to Service Type: LoadBalancer LoadBalancer will get created with
        /// the IP specified in this field. This feature depends on whether the underlying
        /// cloud-provider supports specifying the loadBalancerIP when a load balancer is
        /// created. This field will be ignored if the cloud-provider does not support the
        /// feature.
        /// </param>
        /// <param name="loadBalancerSourceRanges">
        /// If specified and supported by the platform, this will restrict traffic through
        /// the cloud-provider load-balancer will be restricted to the specified client IPs.
        /// This field will be ignored if the cloud-provider does not support the feature.&quot;
        /// More info:
        /// https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
        /// </param>
        /// <param name="ports">
        /// The list of ports that are exposed by this service. More info:
        /// https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
        /// </param>
        /// <param name="publishNotReadyAddresses">
        /// publishNotReadyAddresses indicates that any agent which deals with endpoints for
        /// this Service should disregard any indications of ready/not-ready. The primary
        /// use case for setting this field is for a StatefulSet&apos;s Headless Service to
        /// propagate SRV DNS records for its Pods for the purpose of peer discovery. The
        /// Kubernetes controllers that generate Endpoints and EndpointSlice resources for
        /// Services interpret this to mean that all endpoints are considered &quot;ready&quot; even
        /// if the Pods themselves are not. Agents which consume only Kubernetes generated
        /// endpoints through the Endpoints or EndpointSlice resources can safely assume
        /// this behavior.
        /// </param>
        /// <param name="selector">
        /// Route service traffic to pods with label keys and values matching this selector.
        /// If empty or not present, the service is assumed to have an external process
        /// managing its endpoints, which Kubernetes will not modify. Only applies to types
        /// ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More
        /// info: https://kubernetes.io/docs/concepts/services-networking/service/
        /// </param>
        /// <param name="sessionAffinity">
        /// Supports &quot;ClientIP&quot; and &quot;None&quot;. Used to maintain session affinity. Enable client
        /// IP based session affinity. Must be ClientIP or None. Defaults to None. More
        /// info:
        /// https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
        /// </param>
        /// <param name="sessionAffinityConfig">
        /// sessionAffinityConfig contains the configurations of session affinity.
        /// </param>
        /// <param name="type">
        /// type determines how the Service is exposed. Defaults to ClusterIP. Valid options
        /// are ExternalName, ClusterIP, NodePort, and LoadBalancer. &quot;ClusterIP&quot; allocates a
        /// cluster-internal IP address for load-balancing to endpoints. Endpoints are
        /// determined by the selector or if that is not specified, by manual construction
        /// of an Endpoints object or EndpointSlice objects. If clusterIP is &quot;None&quot;, no
        /// virtual IP is allocated and the endpoints are published as a set of endpoints
        /// rather than a virtual IP. &quot;NodePort&quot; builds on ClusterIP and allocates a port on
        /// every node which routes to the same endpoints as the clusterIP. &quot;LoadBalancer&quot;
        /// builds on NodePort and creates an external load-balancer (if supported in the
        /// current cloud) which routes to the same endpoints as the clusterIP.
        /// &quot;ExternalName&quot; aliases this service to the specified externalName. Several other
        /// fields do not apply to ExternalName services. More info:
        /// https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
        /// </param>
        public V1ServiceSpec(bool? allocateLoadBalancerNodePorts = null, string clusterIP = null, IList<string> clusterIPs = null, IList<string> externalIPs = null, string externalName = null, string externalTrafficPolicy = null, int? healthCheckNodePort = null, string internalTrafficPolicy = null, IList<string> ipFamilies = null, string ipFamilyPolicy = null, string loadBalancerClass = null, string loadBalancerIP = null, IList<string> loadBalancerSourceRanges = null, IList<V1ServicePort> ports = null, bool? publishNotReadyAddresses = null, IDictionary<string, string> selector = null, string sessionAffinity = null, V1SessionAffinityConfig sessionAffinityConfig = null, string type = null)
        {
            AllocateLoadBalancerNodePorts = allocateLoadBalancerNodePorts;
            ClusterIP = clusterIP;
            ClusterIPs = clusterIPs;
            ExternalIPs = externalIPs;
            ExternalName = externalName;
            ExternalTrafficPolicy = externalTrafficPolicy;
            HealthCheckNodePort = healthCheckNodePort;
            InternalTrafficPolicy = internalTrafficPolicy;
            IpFamilies = ipFamilies;
            IpFamilyPolicy = ipFamilyPolicy;
            LoadBalancerClass = loadBalancerClass;
            LoadBalancerIP = loadBalancerIP;
            LoadBalancerSourceRanges = loadBalancerSourceRanges;
            Ports = ports;
            PublishNotReadyAddresses = publishNotReadyAddresses;
            Selector = selector;
            SessionAffinity = sessionAffinity;
            SessionAffinityConfig = sessionAffinityConfig;
            Type = type;
            CustomInit();
        }

        /// <summary>
        /// An initialization method that performs custom operations like setting defaults
        /// </summary>
        partial void CustomInit();

        /// <summary>
        /// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
        /// allocated for services with type LoadBalancer.  Default is &quot;true&quot;. It may be set
        /// to &quot;false&quot; if the cluster load-balancer does not rely on NodePorts.  If the
        /// caller requests specific NodePorts (by specifying a value), those requests will
        /// be respected, regardless of this field. This field may only be set for services
        /// with type LoadBalancer and will be cleared if the type is changed to any other
        /// type. This field is beta-level and is only honored by servers that enable the
        /// ServiceLBNodePortControl feature.
        /// </summary>
        [JsonProperty(PropertyName = "allocateLoadBalancerNodePorts")]
        public bool? AllocateLoadBalancerNodePorts { get; set; }

        /// <summary>
        /// clusterIP is the IP address of the service and is usually assigned randomly. If
        /// an address is specified manually, is in-range (as per system configuration), and
        /// is not in use, it will be allocated to the service; otherwise creation of the
        /// service will fail. This field may not be changed through updates unless the type
        /// field is also being changed to ExternalName (which requires this field to be
        /// blank) or the type field is being changed from ExternalName (in which case this
        /// field may optionally be specified, as describe above).  Valid values are &quot;None&quot;,
        /// empty string (&quot;&quot;), or a valid IP address. Setting this to &quot;None&quot; makes a
        /// &quot;headless service&quot; (no virtual IP), which is useful when direct endpoint
        /// connections are preferred and proxying is not required.  Only applies to types
        /// ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating
        /// a Service of type ExternalName, creation will fail. This field will be wiped
        /// when updating a Service to type ExternalName. More info:
        /// https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
        /// </summary>
        [JsonProperty(PropertyName = "clusterIP")]
        public string ClusterIP { get; set; }

        /// <summary>
        /// ClusterIPs is a list of IP addresses assigned to this service, and are usually
        /// assigned randomly.  If an address is specified manually, is in-range (as per
        /// system configuration), and is not in use, it will be allocated to the service;
        /// otherwise creation of the service will fail. This field may not be changed
        /// through updates unless the type field is also being changed to ExternalName
        /// (which requires this field to be empty) or the type field is being changed from
        /// ExternalName (in which case this field may optionally be specified, as describe
        /// above).  Valid values are &quot;None&quot;, empty string (&quot;&quot;), or a valid IP address. 
        /// Setting this to &quot;None&quot; makes a &quot;headless service&quot; (no virtual IP), which is
        /// useful when direct endpoint connections are preferred and proxying is not
        /// required.  Only applies to types ClusterIP, NodePort, and LoadBalancer. If this
        /// field is specified when creating a Service of type ExternalName, creation will
        /// fail. This field will be wiped when updating a Service to type ExternalName.  If
        /// this field is not specified, it will be initialized from the clusterIP field. 
        /// If this field is specified, clients must ensure that clusterIPs[0] and clusterIP
        /// have the same value.
        /// 
        /// Unless the &quot;IPv6DualStack&quot; feature gate is enabled, this field is limited to one
        /// value, which must be the same as the clusterIP field.  If the feature gate is
        /// enabled, this field may hold a maximum of two entries (dual-stack IPs, in either
        /// order).  These IPs must correspond to the values of the ipFamilies field. Both
        /// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field. More info:
        /// https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
        /// </summary>
        [JsonProperty(PropertyName = "clusterIPs")]
        public IList<string> ClusterIPs { get; set; }

        /// <summary>
        /// externalIPs is a list of IP addresses for which nodes in the cluster will also
        /// accept traffic for this service.  These IPs are not managed by Kubernetes.  The
        /// user is responsible for ensuring that traffic arrives at a node with this IP.  A
        /// common example is external load-balancers that are not part of the Kubernetes
        /// system.
        /// </summary>
        [JsonProperty(PropertyName = "externalIPs")]
        public IList<string> ExternalIPs { get; set; }

        /// <summary>
        /// externalName is the external reference that discovery mechanisms will return as
        /// an alias for this service (e.g. a DNS CNAME record). No proxying will be
        /// involved.  Must be a lowercase RFC-1123 hostname
        /// (https://tools.ietf.org/html/rfc1123) and requires `type` to be &quot;ExternalName&quot;.
        /// </summary>
        [JsonProperty(PropertyName = "externalName")]
        public string ExternalName { get; set; }

        /// <summary>
        /// externalTrafficPolicy denotes if this Service desires to route external traffic
        /// to node-local or cluster-wide endpoints. &quot;Local&quot; preserves the client source IP
        /// and avoids a second hop for LoadBalancer and Nodeport type services, but risks
        /// potentially imbalanced traffic spreading. &quot;Cluster&quot; obscures the client source
        /// IP and may cause a second hop to another node, but should have good overall
        /// load-spreading.
        /// </summary>
        [JsonProperty(PropertyName = "externalTrafficPolicy")]
        public string ExternalTrafficPolicy { get; set; }

        /// <summary>
        /// healthCheckNodePort specifies the healthcheck nodePort for the service. This
        /// only applies when type is set to LoadBalancer and externalTrafficPolicy is set
        /// to Local. If a value is specified, is in-range, and is not in use, it will be
        /// used.  If not specified, a value will be automatically allocated.  External
        /// systems (e.g. load-balancers) can use this port to determine if a given node
        /// holds endpoints for this service or not.  If this field is specified when
        /// creating a Service which does not need it, creation will fail. This field will
        /// be wiped when updating a Service to no longer need it (e.g. changing type).
        /// </summary>
        [JsonProperty(PropertyName = "healthCheckNodePort")]
        public int? HealthCheckNodePort { get; set; }

        /// <summary>
        /// InternalTrafficPolicy specifies if the cluster internal traffic should be routed
        /// to all endpoints or node-local endpoints only. &quot;Cluster&quot; routes internal traffic
        /// to a Service to all endpoints. &quot;Local&quot; routes traffic to node-local endpoints
        /// only, traffic is dropped if no node-local endpoints are ready. The default value
        /// is &quot;Cluster&quot;.
        /// </summary>
        [JsonProperty(PropertyName = "internalTrafficPolicy")]
        public string InternalTrafficPolicy { get; set; }

        /// <summary>
        /// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this service,
        /// and is gated by the &quot;IPv6DualStack&quot; feature gate.  This field is usually
        /// assigned automatically based on cluster configuration and the ipFamilyPolicy
        /// field. If this field is specified manually, the requested family is available in
        /// the cluster, and ipFamilyPolicy allows it, it will be used; otherwise creation
        /// of the service will fail.  This field is conditionally mutable: it allows for
        /// adding or removing a secondary IP family, but it does not allow changing the
        /// primary IP family of the Service.  Valid values are &quot;IPv4&quot; and &quot;IPv6&quot;.  This
        /// field only applies to Services of types ClusterIP, NodePort, and LoadBalancer,
        /// and does apply to &quot;headless&quot; services.  This field will be wiped when updating a
        /// Service to type ExternalName.
        /// 
        /// This field may hold a maximum of two entries (dual-stack families, in either
        /// order).  These families must correspond to the values of the clusterIPs field,
        /// if specified. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy
        /// field.
        /// </summary>
        [JsonProperty(PropertyName = "ipFamilies")]
        public IList<string> IpFamilies { get; set; }

        /// <summary>
        /// IPFamilyPolicy represents the dual-stack-ness requested or required by this
        /// Service, and is gated by the &quot;IPv6DualStack&quot; feature gate.  If there is no value
        /// provided, then this field will be set to SingleStack. Services can be
        /// &quot;SingleStack&quot; (a single IP family), &quot;PreferDualStack&quot; (two IP families on
        /// dual-stack configured clusters or a single IP family on single-stack clusters),
        /// or &quot;RequireDualStack&quot; (two IP families on dual-stack configured clusters,
        /// otherwise fail). The ipFamilies and clusterIPs fields depend on the value of
        /// this field.  This field will be wiped when updating a service to type
        /// ExternalName.
        /// </summary>
        [JsonProperty(PropertyName = "ipFamilyPolicy")]
        public string IpFamilyPolicy { get; set; }

        /// <summary>
        /// loadBalancerClass is the class of the load balancer implementation this Service
        /// belongs to. If specified, the value of this field must be a label-style
        /// identifier, with an optional prefix, e.g. &quot;internal-vip&quot; or
        /// &quot;example.com/internal-vip&quot;. Unprefixed names are reserved for end-users. This
        /// field can only be set when the Service type is &apos;LoadBalancer&apos;. If not set, the
        /// default load balancer implementation is used, today this is typically done
        /// through the cloud provider integration, but should apply for any default
        /// implementation. If set, it is assumed that a load balancer implementation is
        /// watching for Services with a matching class. Any default load balancer
        /// implementation (e.g. cloud providers) should ignore Services that set this
        /// field. This field can only be set when creating or updating a Service to type
        /// &apos;LoadBalancer&apos;. Once set, it can not be changed. This field will be wiped when a
        /// service is updated to a non &apos;LoadBalancer&apos; type.
        /// </summary>
        [JsonProperty(PropertyName = "loadBalancerClass")]
        public string LoadBalancerClass { get; set; }

        /// <summary>
        /// Only applies to Service Type: LoadBalancer LoadBalancer will get created with
        /// the IP specified in this field. This feature depends on whether the underlying
        /// cloud-provider supports specifying the loadBalancerIP when a load balancer is
        /// created. This field will be ignored if the cloud-provider does not support the
        /// feature.
        /// </summary>
        [JsonProperty(PropertyName = "loadBalancerIP")]
        public string LoadBalancerIP { get; set; }

        /// <summary>
        /// If specified and supported by the platform, this will restrict traffic through
        /// the cloud-provider load-balancer will be restricted to the specified client IPs.
        /// This field will be ignored if the cloud-provider does not support the feature.&quot;
        /// More info:
        /// https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
        /// </summary>
        [JsonProperty(PropertyName = "loadBalancerSourceRanges")]
        public IList<string> LoadBalancerSourceRanges { get; set; }

        /// <summary>
        /// The list of ports that are exposed by this service. More info:
        /// https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
        /// </summary>
        [JsonProperty(PropertyName = "ports")]
        public IList<V1ServicePort> Ports { get; set; }

        /// <summary>
        /// publishNotReadyAddresses indicates that any agent which deals with endpoints for
        /// this Service should disregard any indications of ready/not-ready. The primary
        /// use case for setting this field is for a StatefulSet&apos;s Headless Service to
        /// propagate SRV DNS records for its Pods for the purpose of peer discovery. The
        /// Kubernetes controllers that generate Endpoints and EndpointSlice resources for
        /// Services interpret this to mean that all endpoints are considered &quot;ready&quot; even
        /// if the Pods themselves are not. Agents which consume only Kubernetes generated
        /// endpoints through the Endpoints or EndpointSlice resources can safely assume
        /// this behavior.
        /// </summary>
        [JsonProperty(PropertyName = "publishNotReadyAddresses")]
        public bool? PublishNotReadyAddresses { get; set; }

        /// <summary>
        /// Route service traffic to pods with label keys and values matching this selector.
        /// If empty or not present, the service is assumed to have an external process
        /// managing its endpoints, which Kubernetes will not modify. Only applies to types
        /// ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More
        /// info: https://kubernetes.io/docs/concepts/services-networking/service/
        /// </summary>
        [JsonProperty(PropertyName = "selector")]
        public IDictionary<string, string> Selector { get; set; }

        /// <summary>
        /// Supports &quot;ClientIP&quot; and &quot;None&quot;. Used to maintain session affinity. Enable client
        /// IP based session affinity. Must be ClientIP or None. Defaults to None. More
        /// info:
        /// https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
        /// </summary>
        [JsonProperty(PropertyName = "sessionAffinity")]
        public string SessionAffinity { get; set; }

        /// <summary>
        /// sessionAffinityConfig contains the configurations of session affinity.
        /// </summary>
        [JsonProperty(PropertyName = "sessionAffinityConfig")]
        public V1SessionAffinityConfig SessionAffinityConfig { get; set; }

        /// <summary>
        /// type determines how the Service is exposed. Defaults to ClusterIP. Valid options
        /// are ExternalName, ClusterIP, NodePort, and LoadBalancer. &quot;ClusterIP&quot; allocates a
        /// cluster-internal IP address for load-balancing to endpoints. Endpoints are
        /// determined by the selector or if that is not specified, by manual construction
        /// of an Endpoints object or EndpointSlice objects. If clusterIP is &quot;None&quot;, no
        /// virtual IP is allocated and the endpoints are published as a set of endpoints
        /// rather than a virtual IP. &quot;NodePort&quot; builds on ClusterIP and allocates a port on
        /// every node which routes to the same endpoints as the clusterIP. &quot;LoadBalancer&quot;
        /// builds on NodePort and creates an external load-balancer (if supported in the
        /// current cloud) which routes to the same endpoints as the clusterIP.
        /// &quot;ExternalName&quot; aliases this service to the specified externalName. Several other
        /// fields do not apply to ExternalName services. More info:
        /// https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
        /// </summary>
        [JsonProperty(PropertyName = "type")]
        public string Type { get; set; }

        /// <summary>
        /// Validate the object.
        /// </summary>
        /// <exception cref="ValidationException">
        /// Thrown if validation fails
        /// </exception>
        public virtual void Validate()
        {
            foreach(var obj in Ports)
            {
                obj.Validate();
            }
            SessionAffinityConfig?.Validate();
        }
    }
}
