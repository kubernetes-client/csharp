// <auto-generated>
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace k8s.Models
{
    using Microsoft.Rest;
    using Newtonsoft.Json;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;

    /// <summary>
    /// CertificateSigningRequestSpec contains the certificate request.
    /// </summary>
    public partial class V1CertificateSigningRequestSpec
    {
        /// <summary>
        /// Initializes a new instance of the V1CertificateSigningRequestSpec
        /// class.
        /// </summary>
        public V1CertificateSigningRequestSpec()
        {
            CustomInit();
        }

        /// <summary>
        /// Initializes a new instance of the V1CertificateSigningRequestSpec
        /// class.
        /// </summary>
        /// <param name="request">request contains an x509 certificate signing
        /// request encoded in a "CERTIFICATE REQUEST" PEM block. When
        /// serialized as JSON or YAML, the data is additionally
        /// base64-encoded.</param>
        /// <param name="signerName">signerName indicates the requested signer,
        /// and is a qualified name.
        ///
        /// List/watch requests for CertificateSigningRequests can filter on
        /// this field using a "spec.signerName=NAME" fieldSelector.
        ///
        /// Well-known Kubernetes signers are:
        /// 1. "kubernetes.io/kube-apiserver-client": issues client
        /// certificates that can be used to authenticate to kube-apiserver.
        /// Requests for this signer are never auto-approved by
        /// kube-controller-manager, can be issued by the "csrsigning"
        /// controller in kube-controller-manager.
        /// 2. "kubernetes.io/kube-apiserver-client-kubelet": issues client
        /// certificates that kubelets use to authenticate to kube-apiserver.
        /// Requests for this signer can be auto-approved by the "csrapproving"
        /// controller in kube-controller-manager, and can be issued by the
        /// "csrsigning" controller in kube-controller-manager.
        /// 3. "kubernetes.io/kubelet-serving" issues serving certificates that
        /// kubelets use to serve TLS endpoints, which kube-apiserver can
        /// connect to securely.
        /// Requests for this signer are never auto-approved by
        /// kube-controller-manager, and can be issued by the "csrsigning"
        /// controller in kube-controller-manager.
        ///
        /// More details are available at
        /// https://k8s.io/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers
        ///
        /// Custom signerNames can also be specified. The signer defines:
        /// 1. Trust distribution: how trust (CA bundles) are distributed.
        /// 2. Permitted subjects: and behavior when a disallowed subject is
        /// requested.
        /// 3. Required, permitted, or forbidden x509 extensions in the request
        /// (including whether subjectAltNames are allowed, which types,
        /// restrictions on allowed values) and behavior when a disallowed
        /// extension is requested.
        /// 4. Required, permitted, or forbidden key usages / extended key
        /// usages.
        /// 5. Expiration/certificate lifetime: whether it is fixed by the
        /// signer, configurable by the admin.
        /// 6. Whether or not requests for CA certificates are allowed.</param>
        /// <param name="extra">extra contains extra attributes of the user
        /// that created the CertificateSigningRequest. Populated by the API
        /// server on creation and immutable.</param>
        /// <param name="groups">groups contains group membership of the user
        /// that created the CertificateSigningRequest. Populated by the API
        /// server on creation and immutable.</param>
        /// <param name="uid">uid contains the uid of the user that created the
        /// CertificateSigningRequest. Populated by the API server on creation
        /// and immutable.</param>
        /// <param name="usages">usages specifies a set of key usages requested
        /// in the issued certificate.
        ///
        /// Requests for TLS client certificates typically request: "digital
        /// signature", "key encipherment", "client auth".
        ///
        /// Requests for TLS serving certificates typically request: "key
        /// encipherment", "digital signature", "server auth".
        ///
        /// Valid values are:
        /// "signing", "digital signature", "content commitment",
        /// "key encipherment", "key agreement", "data encipherment",
        /// "cert sign", "crl sign", "encipher only", "decipher only", "any",
        /// "server auth", "client auth",
        /// "code signing", "email protection", "s/mime",
        /// "ipsec end system", "ipsec tunnel", "ipsec user",
        /// "timestamping", "ocsp signing", "microsoft sgc", "netscape
        /// sgc"</param>
        /// <param name="username">username contains the name of the user that
        /// created the CertificateSigningRequest. Populated by the API server
        /// on creation and immutable.</param>
        public V1CertificateSigningRequestSpec(byte[] request, string signerName, IDictionary<string, IList<string>> extra = default(IDictionary<string, IList<string>>), IList<string> groups = default(IList<string>), string uid = default(string), IList<string> usages = default(IList<string>), string username = default(string))
        {
            Extra = extra;
            Groups = groups;
            Request = request;
            SignerName = signerName;
            Uid = uid;
            Usages = usages;
            Username = username;
            CustomInit();
        }

        /// <summary>
        /// An initialization method that performs custom operations like setting defaults
        /// </summary>
        partial void CustomInit();

        /// <summary>
        /// Gets or sets extra contains extra attributes of the user that
        /// created the CertificateSigningRequest. Populated by the API server
        /// on creation and immutable.
        /// </summary>
        [JsonProperty(PropertyName = "extra")]
        public IDictionary<string, IList<string>> Extra { get; set; }

        /// <summary>
        /// Gets or sets groups contains group membership of the user that
        /// created the CertificateSigningRequest. Populated by the API server
        /// on creation and immutable.
        /// </summary>
        [JsonProperty(PropertyName = "groups")]
        public IList<string> Groups { get; set; }

        /// <summary>
        /// Gets or sets request contains an x509 certificate signing request
        /// encoded in a "CERTIFICATE REQUEST" PEM block. When serialized as
        /// JSON or YAML, the data is additionally base64-encoded.
        /// </summary>
        [JsonProperty(PropertyName = "request")]
        public byte[] Request { get; set; }

        /// <summary>
        /// Gets or sets signerName indicates the requested signer, and is a
        /// qualified name.
        ///
        /// List/watch requests for CertificateSigningRequests can filter on
        /// this field using a "spec.signerName=NAME" fieldSelector.
        ///
        /// Well-known Kubernetes signers are:
        /// 1. "kubernetes.io/kube-apiserver-client": issues client
        /// certificates that can be used to authenticate to kube-apiserver.
        /// Requests for this signer are never auto-approved by
        /// kube-controller-manager, can be issued by the "csrsigning"
        /// controller in kube-controller-manager.
        /// 2. "kubernetes.io/kube-apiserver-client-kubelet": issues client
        /// certificates that kubelets use to authenticate to kube-apiserver.
        /// Requests for this signer can be auto-approved by the "csrapproving"
        /// controller in kube-controller-manager, and can be issued by the
        /// "csrsigning" controller in kube-controller-manager.
        /// 3. "kubernetes.io/kubelet-serving" issues serving certificates that
        /// kubelets use to serve TLS endpoints, which kube-apiserver can
        /// connect to securely.
        /// Requests for this signer are never auto-approved by
        /// kube-controller-manager, and can be issued by the "csrsigning"
        /// controller in kube-controller-manager.
        ///
        /// More details are available at
        /// https://k8s.io/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers
        ///
        /// Custom signerNames can also be specified. The signer defines:
        /// 1. Trust distribution: how trust (CA bundles) are distributed.
        /// 2. Permitted subjects: and behavior when a disallowed subject is
        /// requested.
        /// 3. Required, permitted, or forbidden x509 extensions in the request
        /// (including whether subjectAltNames are allowed, which types,
        /// restrictions on allowed values) and behavior when a disallowed
        /// extension is requested.
        /// 4. Required, permitted, or forbidden key usages / extended key
        /// usages.
        /// 5. Expiration/certificate lifetime: whether it is fixed by the
        /// signer, configurable by the admin.
        /// 6. Whether or not requests for CA certificates are allowed.
        /// </summary>
        [JsonProperty(PropertyName = "signerName")]
        public string SignerName { get; set; }

        /// <summary>
        /// Gets or sets uid contains the uid of the user that created the
        /// CertificateSigningRequest. Populated by the API server on creation
        /// and immutable.
        /// </summary>
        [JsonProperty(PropertyName = "uid")]
        public string Uid { get; set; }

        /// <summary>
        /// Gets or sets usages specifies a set of key usages requested in the
        /// issued certificate.
        ///
        /// Requests for TLS client certificates typically request: "digital
        /// signature", "key encipherment", "client auth".
        ///
        /// Requests for TLS serving certificates typically request: "key
        /// encipherment", "digital signature", "server auth".
        ///
        /// Valid values are:
        /// "signing", "digital signature", "content commitment",
        /// "key encipherment", "key agreement", "data encipherment",
        /// "cert sign", "crl sign", "encipher only", "decipher only", "any",
        /// "server auth", "client auth",
        /// "code signing", "email protection", "s/mime",
        /// "ipsec end system", "ipsec tunnel", "ipsec user",
        /// "timestamping", "ocsp signing", "microsoft sgc", "netscape sgc"
        /// </summary>
        [JsonProperty(PropertyName = "usages")]
        public IList<string> Usages { get; set; }

        /// <summary>
        /// Gets or sets username contains the name of the user that created
        /// the CertificateSigningRequest. Populated by the API server on
        /// creation and immutable.
        /// </summary>
        [JsonProperty(PropertyName = "username")]
        public string Username { get; set; }

        /// <summary>
        /// Validate the object.
        /// </summary>
        /// <exception cref="ValidationException">
        /// Thrown if validation fails
        /// </exception>
        public virtual void Validate()
        {
            if (Request == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "Request");
            }
            if (SignerName == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "SignerName");
            }
        }
    }
}
