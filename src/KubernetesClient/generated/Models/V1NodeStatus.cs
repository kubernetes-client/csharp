// <auto-generated>
// Code generated by https://github.com/kubernetes-client/csharp/tree/master/gen/KubernetesGenerator
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace k8s.Models
{
    using Microsoft.Rest;
    using Newtonsoft.Json;
    using System.Collections.Generic;
    using System.Collections;
    using System.Linq;

    /// <summary>
    /// NodeStatus is information about the current status of a node.
    /// </summary>
    public partial class V1NodeStatus
    {
        /// <summary>
        /// Initializes a new instance of the V1NodeStatus class.
        /// </summary>
        public V1NodeStatus()
        {
            CustomInit();
        }

        /// <summary>
        /// Initializes a new instance of the V1NodeStatus class.
        /// </summary>
        /// <param name="addresses">
        /// List of addresses reachable to the node. Queried from cloud provider, if
        /// available. More info: https://kubernetes.io/docs/concepts/nodes/node/#addresses
        /// Note: This field is declared as mergeable, but the merge key is not sufficiently
        /// unique, which can cause data corruption when it is merged. Callers should
        /// instead use a full-replacement patch. See http://pr.k8s.io/79391 for an example.
        /// </param>
        /// <param name="allocatable">
        /// Allocatable represents the resources of a node that are available for
        /// scheduling. Defaults to Capacity.
        /// </param>
        /// <param name="capacity">
        /// Capacity represents the total resources of a node. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
        /// </param>
        /// <param name="conditions">
        /// Conditions is an array of current observed node conditions. More info:
        /// https://kubernetes.io/docs/concepts/nodes/node/#condition
        /// </param>
        /// <param name="config">
        /// Status of the config assigned to the node via the dynamic Kubelet config
        /// feature.
        /// </param>
        /// <param name="daemonEndpoints">
        /// Endpoints of daemons running on the Node.
        /// </param>
        /// <param name="images">
        /// List of container images on this node
        /// </param>
        /// <param name="nodeInfo">
        /// Set of ids/uuids to uniquely identify the node. More info:
        /// https://kubernetes.io/docs/concepts/nodes/node/#info
        /// </param>
        /// <param name="phase">
        /// NodePhase is the recently observed lifecycle phase of the node. More info:
        /// https://kubernetes.io/docs/concepts/nodes/node/#phase The field is never
        /// populated, and now is deprecated.
        /// </param>
        /// <param name="volumesAttached">
        /// List of volumes that are attached to the node.
        /// </param>
        /// <param name="volumesInUse">
        /// List of attachable volumes in use (mounted) by the node.
        /// </param>
        public V1NodeStatus(IList<V1NodeAddress> addresses = null, IDictionary<string, ResourceQuantity> allocatable = null, IDictionary<string, ResourceQuantity> capacity = null, IList<V1NodeCondition> conditions = null, V1NodeConfigStatus config = null, V1NodeDaemonEndpoints daemonEndpoints = null, IList<V1ContainerImage> images = null, V1NodeSystemInfo nodeInfo = null, string phase = null, IList<V1AttachedVolume> volumesAttached = null, IList<string> volumesInUse = null)
        {
            Addresses = addresses;
            Allocatable = allocatable;
            Capacity = capacity;
            Conditions = conditions;
            Config = config;
            DaemonEndpoints = daemonEndpoints;
            Images = images;
            NodeInfo = nodeInfo;
            Phase = phase;
            VolumesAttached = volumesAttached;
            VolumesInUse = volumesInUse;
            CustomInit();
        }

        /// <summary>
        /// An initialization method that performs custom operations like setting defaults
        /// </summary>
        partial void CustomInit();

        /// <summary>
        /// List of addresses reachable to the node. Queried from cloud provider, if
        /// available. More info: https://kubernetes.io/docs/concepts/nodes/node/#addresses
        /// Note: This field is declared as mergeable, but the merge key is not sufficiently
        /// unique, which can cause data corruption when it is merged. Callers should
        /// instead use a full-replacement patch. See http://pr.k8s.io/79391 for an example.
        /// </summary>
        [JsonProperty(PropertyName = "addresses")]
        public IList<V1NodeAddress> Addresses { get; set; }

        /// <summary>
        /// Allocatable represents the resources of a node that are available for
        /// scheduling. Defaults to Capacity.
        /// </summary>
        [JsonProperty(PropertyName = "allocatable")]
        public IDictionary<string, ResourceQuantity> Allocatable { get; set; }

        /// <summary>
        /// Capacity represents the total resources of a node. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
        /// </summary>
        [JsonProperty(PropertyName = "capacity")]
        public IDictionary<string, ResourceQuantity> Capacity { get; set; }

        /// <summary>
        /// Conditions is an array of current observed node conditions. More info:
        /// https://kubernetes.io/docs/concepts/nodes/node/#condition
        /// </summary>
        [JsonProperty(PropertyName = "conditions")]
        public IList<V1NodeCondition> Conditions { get; set; }

        /// <summary>
        /// Status of the config assigned to the node via the dynamic Kubelet config
        /// feature.
        /// </summary>
        [JsonProperty(PropertyName = "config")]
        public V1NodeConfigStatus Config { get; set; }

        /// <summary>
        /// Endpoints of daemons running on the Node.
        /// </summary>
        [JsonProperty(PropertyName = "daemonEndpoints")]
        public V1NodeDaemonEndpoints DaemonEndpoints { get; set; }

        /// <summary>
        /// List of container images on this node
        /// </summary>
        [JsonProperty(PropertyName = "images")]
        public IList<V1ContainerImage> Images { get; set; }

        /// <summary>
        /// Set of ids/uuids to uniquely identify the node. More info:
        /// https://kubernetes.io/docs/concepts/nodes/node/#info
        /// </summary>
        [JsonProperty(PropertyName = "nodeInfo")]
        public V1NodeSystemInfo NodeInfo { get; set; }

        /// <summary>
        /// NodePhase is the recently observed lifecycle phase of the node. More info:
        /// https://kubernetes.io/docs/concepts/nodes/node/#phase The field is never
        /// populated, and now is deprecated.
        /// </summary>
        [JsonProperty(PropertyName = "phase")]
        public string Phase { get; set; }

        /// <summary>
        /// List of volumes that are attached to the node.
        /// </summary>
        [JsonProperty(PropertyName = "volumesAttached")]
        public IList<V1AttachedVolume> VolumesAttached { get; set; }

        /// <summary>
        /// List of attachable volumes in use (mounted) by the node.
        /// </summary>
        [JsonProperty(PropertyName = "volumesInUse")]
        public IList<string> VolumesInUse { get; set; }

        /// <summary>
        /// Validate the object.
        /// </summary>
        /// <exception cref="ValidationException">
        /// Thrown if validation fails
        /// </exception>
        public virtual void Validate()
        {
            if (Addresses != null){
                foreach(var obj in Addresses)
                {
                    obj.Validate();
                }
            }
            if (Conditions != null){
                foreach(var obj in Conditions)
                {
                    obj.Validate();
                }
            }
            Config?.Validate();
            DaemonEndpoints?.Validate();
            if (Images != null){
                foreach(var obj in Images)
                {
                    obj.Validate();
                }
            }
            NodeInfo?.Validate();
            if (VolumesAttached != null){
                foreach(var obj in VolumesAttached)
                {
                    obj.Validate();
                }
            }
        }
    }
}
