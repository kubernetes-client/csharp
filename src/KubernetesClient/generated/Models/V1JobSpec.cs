// <auto-generated>
// Code generated by https://github.com/kubernetes-client/csharp/tree/master/gen/KubernetesGenerator
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace k8s.Models
{
    using Microsoft.Rest;
    using Newtonsoft.Json;
    using System.Collections.Generic;
    using System.Collections;
    using System.Linq;

    /// <summary>
    /// JobSpec describes how the job execution will look like.
    /// </summary>
    public partial class V1JobSpec
    {
        /// <summary>
        /// Initializes a new instance of the V1JobSpec class.
        /// </summary>
        public V1JobSpec()
        {
            CustomInit();
        }

        /// <summary>
        /// Initializes a new instance of the V1JobSpec class.
        /// </summary>
        /// <param name="template">
        /// Describes the pod that will be created when executing a job. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        /// </param>
        /// <param name="activeDeadlineSeconds">
        /// Specifies the duration in seconds relative to the startTime that the job may be
        /// continuously active before the system tries to terminate it; value must be
        /// positive integer. If a Job is suspended (at creation or through an update), this
        /// timer will effectively be stopped and reset when the Job is resumed again.
        /// </param>
        /// <param name="backoffLimit">
        /// Specifies the number of retries before marking this job failed. Defaults to 6
        /// </param>
        /// <param name="completionMode">
        /// CompletionMode specifies how Pod completions are tracked. It can be `NonIndexed`
        /// (default) or `Indexed`.
        /// 
        /// `NonIndexed` means that the Job is considered complete when there have been
        /// .spec.completions successfully completed Pods. Each Pod completion is homologous
        /// to each other.
        /// 
        /// `Indexed` means that the Pods of a Job get an associated completion index from 0
        /// to (.spec.completions - 1), available in the annotation
        /// batch.kubernetes.io/job-completion-index. The Job is considered complete when
        /// there is one successfully completed Pod for each index. When value is `Indexed`,
        /// .spec.completions must be specified and `.spec.parallelism` must be less than or
        /// equal to 10^5. In addition, The Pod name takes the form
        /// `$(job-name)-$(index)-$(random-string)`, the Pod hostname takes the form
        /// `$(job-name)-$(index)`.
        /// 
        /// This field is beta-level. More completion modes can be added in the future. If
        /// the Job controller observes a mode that it doesn&apos;t recognize, the controller
        /// skips updates for the Job.
        /// </param>
        /// <param name="completions">
        /// Specifies the desired number of successfully finished pods the job should be run
        /// with.  Setting to nil means that the success of any pod signals the success of
        /// all pods, and allows parallelism to have any positive value.  Setting to 1 means
        /// that parallelism is limited to 1 and the success of that pod signals the success
        /// of the job. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        /// </param>
        /// <param name="manualSelector">
        /// manualSelector controls generation of pod labels and pod selectors. Leave
        /// `manualSelector` unset unless you are certain what you are doing. When false or
        /// unset, the system pick labels unique to this job and appends those labels to the
        /// pod template.  When true, the user is responsible for picking unique labels and
        /// specifying the selector.  Failure to pick a unique label may cause this and
        /// other jobs to not function correctly.  However, You may see
        /// `manualSelector=true` in jobs that were created with the old
        /// `extensions/v1beta1` API. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/#specifying-your-own-pod-selector
        /// </param>
        /// <param name="parallelism">
        /// Specifies the maximum desired number of pods the job should run at any given
        /// time. The actual number of pods running in steady state will be less than this
        /// number when ((.spec.completions - .status.successful) &lt; .spec.parallelism), i.e.
        /// when the work left to do is less than max parallelism. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        /// </param>
        /// <param name="selector">
        /// A label query over pods that should match the pod count. Normally, the system
        /// sets this field for you. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </param>
        /// <param name="suspend">
        /// Suspend specifies whether the Job controller should create Pods or not. If a Job
        /// is created with suspend set to true, no Pods are created by the Job controller.
        /// If a Job is suspended after creation (i.e. the flag goes from false to true),
        /// the Job controller will delete all active Pods associated with this Job. Users
        /// must design their workload to gracefully handle this. Suspending a Job will
        /// reset the StartTime field of the Job, effectively resetting the
        /// ActiveDeadlineSeconds timer too. Defaults to false.
        /// 
        /// This field is beta-level, gated by SuspendJob feature flag (enabled by default).
        /// </param>
        /// <param name="ttlSecondsAfterFinished">
        /// ttlSecondsAfterFinished limits the lifetime of a Job that has finished execution
        /// (either Complete or Failed). If this field is set, ttlSecondsAfterFinished after
        /// the Job finishes, it is eligible to be automatically deleted. When the Job is
        /// being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If
        /// this field is unset, the Job won&apos;t be automatically deleted. If this field is
        /// set to zero, the Job becomes eligible to be deleted immediately after it
        /// finishes. This field is alpha-level and is only honored by servers that enable
        /// the TTLAfterFinished feature.
        /// </param>
        public V1JobSpec(V1PodTemplateSpec template, long? activeDeadlineSeconds = null, int? backoffLimit = null, string completionMode = null, int? completions = null, bool? manualSelector = null, int? parallelism = null, V1LabelSelector selector = null, bool? suspend = null, int? ttlSecondsAfterFinished = null)
        {
            ActiveDeadlineSeconds = activeDeadlineSeconds;
            BackoffLimit = backoffLimit;
            CompletionMode = completionMode;
            Completions = completions;
            ManualSelector = manualSelector;
            Parallelism = parallelism;
            Selector = selector;
            Suspend = suspend;
            Template = template;
            TtlSecondsAfterFinished = ttlSecondsAfterFinished;
            CustomInit();
        }

        /// <summary>
        /// An initialization method that performs custom operations like setting defaults
        /// </summary>
        partial void CustomInit();

        /// <summary>
        /// Specifies the duration in seconds relative to the startTime that the job may be
        /// continuously active before the system tries to terminate it; value must be
        /// positive integer. If a Job is suspended (at creation or through an update), this
        /// timer will effectively be stopped and reset when the Job is resumed again.
        /// </summary>
        [JsonProperty(PropertyName = "activeDeadlineSeconds")]
        public long? ActiveDeadlineSeconds { get; set; }

        /// <summary>
        /// Specifies the number of retries before marking this job failed. Defaults to 6
        /// </summary>
        [JsonProperty(PropertyName = "backoffLimit")]
        public int? BackoffLimit { get; set; }

        /// <summary>
        /// CompletionMode specifies how Pod completions are tracked. It can be `NonIndexed`
        /// (default) or `Indexed`.
        /// 
        /// `NonIndexed` means that the Job is considered complete when there have been
        /// .spec.completions successfully completed Pods. Each Pod completion is homologous
        /// to each other.
        /// 
        /// `Indexed` means that the Pods of a Job get an associated completion index from 0
        /// to (.spec.completions - 1), available in the annotation
        /// batch.kubernetes.io/job-completion-index. The Job is considered complete when
        /// there is one successfully completed Pod for each index. When value is `Indexed`,
        /// .spec.completions must be specified and `.spec.parallelism` must be less than or
        /// equal to 10^5. In addition, The Pod name takes the form
        /// `$(job-name)-$(index)-$(random-string)`, the Pod hostname takes the form
        /// `$(job-name)-$(index)`.
        /// 
        /// This field is beta-level. More completion modes can be added in the future. If
        /// the Job controller observes a mode that it doesn&apos;t recognize, the controller
        /// skips updates for the Job.
        /// </summary>
        [JsonProperty(PropertyName = "completionMode")]
        public string CompletionMode { get; set; }

        /// <summary>
        /// Specifies the desired number of successfully finished pods the job should be run
        /// with.  Setting to nil means that the success of any pod signals the success of
        /// all pods, and allows parallelism to have any positive value.  Setting to 1 means
        /// that parallelism is limited to 1 and the success of that pod signals the success
        /// of the job. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        /// </summary>
        [JsonProperty(PropertyName = "completions")]
        public int? Completions { get; set; }

        /// <summary>
        /// manualSelector controls generation of pod labels and pod selectors. Leave
        /// `manualSelector` unset unless you are certain what you are doing. When false or
        /// unset, the system pick labels unique to this job and appends those labels to the
        /// pod template.  When true, the user is responsible for picking unique labels and
        /// specifying the selector.  Failure to pick a unique label may cause this and
        /// other jobs to not function correctly.  However, You may see
        /// `manualSelector=true` in jobs that were created with the old
        /// `extensions/v1beta1` API. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/#specifying-your-own-pod-selector
        /// </summary>
        [JsonProperty(PropertyName = "manualSelector")]
        public bool? ManualSelector { get; set; }

        /// <summary>
        /// Specifies the maximum desired number of pods the job should run at any given
        /// time. The actual number of pods running in steady state will be less than this
        /// number when ((.spec.completions - .status.successful) &lt; .spec.parallelism), i.e.
        /// when the work left to do is less than max parallelism. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        /// </summary>
        [JsonProperty(PropertyName = "parallelism")]
        public int? Parallelism { get; set; }

        /// <summary>
        /// A label query over pods that should match the pod count. Normally, the system
        /// sets this field for you. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
        [JsonProperty(PropertyName = "selector")]
        public V1LabelSelector Selector { get; set; }

        /// <summary>
        /// Suspend specifies whether the Job controller should create Pods or not. If a Job
        /// is created with suspend set to true, no Pods are created by the Job controller.
        /// If a Job is suspended after creation (i.e. the flag goes from false to true),
        /// the Job controller will delete all active Pods associated with this Job. Users
        /// must design their workload to gracefully handle this. Suspending a Job will
        /// reset the StartTime field of the Job, effectively resetting the
        /// ActiveDeadlineSeconds timer too. Defaults to false.
        /// 
        /// This field is beta-level, gated by SuspendJob feature flag (enabled by default).
        /// </summary>
        [JsonProperty(PropertyName = "suspend")]
        public bool? Suspend { get; set; }

        /// <summary>
        /// Describes the pod that will be created when executing a job. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        /// </summary>
        [JsonProperty(PropertyName = "template")]
        public V1PodTemplateSpec Template { get; set; }

        /// <summary>
        /// ttlSecondsAfterFinished limits the lifetime of a Job that has finished execution
        /// (either Complete or Failed). If this field is set, ttlSecondsAfterFinished after
        /// the Job finishes, it is eligible to be automatically deleted. When the Job is
        /// being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If
        /// this field is unset, the Job won&apos;t be automatically deleted. If this field is
        /// set to zero, the Job becomes eligible to be deleted immediately after it
        /// finishes. This field is alpha-level and is only honored by servers that enable
        /// the TTLAfterFinished feature.
        /// </summary>
        [JsonProperty(PropertyName = "ttlSecondsAfterFinished")]
        public int? TtlSecondsAfterFinished { get; set; }

        /// <summary>
        /// Validate the object.
        /// </summary>
        /// <exception cref="ValidationException">
        /// Thrown if validation fails
        /// </exception>
        public virtual void Validate()
        {
            if (Template == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "Template");    
            }
            Selector?.Validate();
            Template?.Validate();
        }
    }
}
