// <auto-generated>
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace k8s.Models
{
    using Microsoft.Rest;
    using Newtonsoft.Json;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;

    /// <summary>
    /// An EphemeralContainer is a container that may be added temporarily to
    /// an existing pod for user-initiated activities such as debugging.
    /// Ephemeral containers have no resource or scheduling guarantees, and
    /// they will not be restarted when they exit or when a pod is removed or
    /// restarted. If an ephemeral container causes a pod to exceed its
    /// resource allocation, the pod may be evicted. Ephemeral containers may
    /// not be added by directly updating the pod spec. They must be added via
    /// the pod's ephemeralcontainers subresource, and they will appear in the
    /// pod spec once added. This is an alpha feature enabled by the
    /// EphemeralContainers feature flag.
    /// </summary>
    public partial class V1EphemeralContainer
    {
        /// <summary>
        /// Initializes a new instance of the V1EphemeralContainer class.
        /// </summary>
        public V1EphemeralContainer()
        {
            CustomInit();
        }

        /// <summary>
        /// Initializes a new instance of the V1EphemeralContainer class.
        /// </summary>
        /// <param name="name">Name of the ephemeral container specified as a
        /// DNS_LABEL. This name must be unique among all containers, init
        /// containers and ephemeral containers.</param>
        /// <param name="args">Arguments to the entrypoint. The docker image's
        /// CMD is used if this is not provided. Variable references
        /// $(VAR_NAME) are expanded using the container's environment. If a
        /// variable cannot be resolved, the reference in the input string will
        /// be unchanged. The $(VAR_NAME) syntax can be escaped with a double
        /// $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
        /// regardless of whether the variable exists or not. Cannot be
        /// updated. More info:
        /// https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell</param>
        /// <param name="command">Entrypoint array. Not executed within a
        /// shell. The docker image's ENTRYPOINT is used if this is not
        /// provided. Variable references $(VAR_NAME) are expanded using the
        /// container's environment. If a variable cannot be resolved, the
        /// reference in the input string will be unchanged. The $(VAR_NAME)
        /// syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped
        /// references will never be expanded, regardless of whether the
        /// variable exists or not. Cannot be updated. More info:
        /// https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell</param>
        /// <param name="env">List of environment variables to set in the
        /// container. Cannot be updated.</param>
        /// <param name="envFrom">List of sources to populate environment
        /// variables in the container. The keys defined within a source must
        /// be a C_IDENTIFIER. All invalid keys will be reported as an event
        /// when the container is starting. When a key exists in multiple
        /// sources, the value associated with the last source will take
        /// precedence. Values defined by an Env with a duplicate key will take
        /// precedence. Cannot be updated.</param>
        /// <param name="image">Docker image name. More info:
        /// https://kubernetes.io/docs/concepts/containers/images</param>
        /// <param name="imagePullPolicy">Image pull policy. One of Always,
        /// Never, IfNotPresent. Defaults to Always if :latest tag is
        /// specified, or IfNotPresent otherwise. Cannot be updated. More info:
        /// https://kubernetes.io/docs/concepts/containers/images#updating-images</param>
        /// <param name="lifecycle">Lifecycle is not allowed for ephemeral
        /// containers.</param>
        /// <param name="livenessProbe">Probes are not allowed for ephemeral
        /// containers.</param>
        /// <param name="ports">Ports are not allowed for ephemeral
        /// containers.</param>
        /// <param name="readinessProbe">Probes are not allowed for ephemeral
        /// containers.</param>
        /// <param name="resources">Resources are not allowed for ephemeral
        /// containers. Ephemeral containers use spare resources already
        /// allocated to the pod.</param>
        /// <param name="securityContext">SecurityContext is not allowed for
        /// ephemeral containers.</param>
        /// <param name="startupProbe">Probes are not allowed for ephemeral
        /// containers.</param>
        /// <param name="stdin">Whether this container should allocate a buffer
        /// for stdin in the container runtime. If this is not set, reads from
        /// stdin in the container will always result in EOF. Default is
        /// false.</param>
        /// <param name="stdinOnce">Whether the container runtime should close
        /// the stdin channel after it has been opened by a single attach. When
        /// stdin is true the stdin stream will remain open across multiple
        /// attach sessions. If stdinOnce is set to true, stdin is opened on
        /// container start, is empty until the first client attaches to stdin,
        /// and then remains open and accepts data until the client
        /// disconnects, at which time stdin is closed and remains closed until
        /// the container is restarted. If this flag is false, a container
        /// processes that reads from stdin will never receive an EOF. Default
        /// is false</param>
        /// <param name="targetContainerName">If set, the name of the container
        /// from PodSpec that this ephemeral container targets. The ephemeral
        /// container will be run in the namespaces (IPC, PID, etc) of this
        /// container. If not set then the ephemeral container is run in
        /// whatever namespaces are shared for the pod. Note that the container
        /// runtime must support this feature.</param>
        /// <param name="terminationMessagePath">Optional: Path at which the
        /// file to which the container's termination message will be written
        /// is mounted into the container's filesystem. Message written is
        /// intended to be brief final status, such as an assertion failure
        /// message. Will be truncated by the node if greater than 4096 bytes.
        /// The total message length across all containers will be limited to
        /// 12kb. Defaults to /dev/termination-log. Cannot be updated.</param>
        /// <param name="terminationMessagePolicy">Indicate how the termination
        /// message should be populated. File will use the contents of
        /// terminationMessagePath to populate the container status message on
        /// both success and failure. FallbackToLogsOnError will use the last
        /// chunk of container log output if the termination message file is
        /// empty and the container exited with an error. The log output is
        /// limited to 2048 bytes or 80 lines, whichever is smaller. Defaults
        /// to File. Cannot be updated.</param>
        /// <param name="tty">Whether this container should allocate a TTY for
        /// itself, also requires 'stdin' to be true. Default is false.</param>
        /// <param name="volumeDevices">volumeDevices is the list of block
        /// devices to be used by the container.</param>
        /// <param name="volumeMounts">Pod volumes to mount into the
        /// container's filesystem. Cannot be updated.</param>
        /// <param name="workingDir">Container's working directory. If not
        /// specified, the container runtime's default will be used, which
        /// might be configured in the container image. Cannot be
        /// updated.</param>
        public V1EphemeralContainer(string name, IList<string> args = default(IList<string>), IList<string> command = default(IList<string>), IList<V1EnvVar> env = default(IList<V1EnvVar>), IList<V1EnvFromSource> envFrom = default(IList<V1EnvFromSource>), string image = default(string), string imagePullPolicy = default(string), V1Lifecycle lifecycle = default(V1Lifecycle), V1Probe livenessProbe = default(V1Probe), IList<V1ContainerPort> ports = default(IList<V1ContainerPort>), V1Probe readinessProbe = default(V1Probe), V1ResourceRequirements resources = default(V1ResourceRequirements), V1SecurityContext securityContext = default(V1SecurityContext), V1Probe startupProbe = default(V1Probe), bool? stdin = default(bool?), bool? stdinOnce = default(bool?), string targetContainerName = default(string), string terminationMessagePath = default(string), string terminationMessagePolicy = default(string), bool? tty = default(bool?), IList<V1VolumeDevice> volumeDevices = default(IList<V1VolumeDevice>), IList<V1VolumeMount> volumeMounts = default(IList<V1VolumeMount>), string workingDir = default(string))
        {
            Args = args;
            Command = command;
            Env = env;
            EnvFrom = envFrom;
            Image = image;
            ImagePullPolicy = imagePullPolicy;
            Lifecycle = lifecycle;
            LivenessProbe = livenessProbe;
            Name = name;
            Ports = ports;
            ReadinessProbe = readinessProbe;
            Resources = resources;
            SecurityContext = securityContext;
            StartupProbe = startupProbe;
            Stdin = stdin;
            StdinOnce = stdinOnce;
            TargetContainerName = targetContainerName;
            TerminationMessagePath = terminationMessagePath;
            TerminationMessagePolicy = terminationMessagePolicy;
            Tty = tty;
            VolumeDevices = volumeDevices;
            VolumeMounts = volumeMounts;
            WorkingDir = workingDir;
            CustomInit();
        }

        /// <summary>
        /// An initialization method that performs custom operations like setting defaults
        /// </summary>
        partial void CustomInit();

        /// <summary>
        /// Gets or sets arguments to the entrypoint. The docker image's CMD is
        /// used if this is not provided. Variable references $(VAR_NAME) are
        /// expanded using the container's environment. If a variable cannot be
        /// resolved, the reference in the input string will be unchanged. The
        /// $(VAR_NAME) syntax can be escaped with a double $$, ie:
        /// $$(VAR_NAME). Escaped references will never be expanded, regardless
        /// of whether the variable exists or not. Cannot be updated. More
        /// info:
        /// https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        /// </summary>
        [JsonProperty(PropertyName = "args")]
        public IList<string> Args { get; set; }

        /// <summary>
        /// Gets or sets entrypoint array. Not executed within a shell. The
        /// docker image's ENTRYPOINT is used if this is not provided. Variable
        /// references $(VAR_NAME) are expanded using the container's
        /// environment. If a variable cannot be resolved, the reference in the
        /// input string will be unchanged. The $(VAR_NAME) syntax can be
        /// escaped with a double $$, ie: $$(VAR_NAME). Escaped references will
        /// never be expanded, regardless of whether the variable exists or
        /// not. Cannot be updated. More info:
        /// https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        /// </summary>
        [JsonProperty(PropertyName = "command")]
        public IList<string> Command { get; set; }

        /// <summary>
        /// Gets or sets list of environment variables to set in the container.
        /// Cannot be updated.
        /// </summary>
        [JsonProperty(PropertyName = "env")]
        public IList<V1EnvVar> Env { get; set; }

        /// <summary>
        /// Gets or sets list of sources to populate environment variables in
        /// the container. The keys defined within a source must be a
        /// C_IDENTIFIER. All invalid keys will be reported as an event when
        /// the container is starting. When a key exists in multiple sources,
        /// the value associated with the last source will take precedence.
        /// Values defined by an Env with a duplicate key will take precedence.
        /// Cannot be updated.
        /// </summary>
        [JsonProperty(PropertyName = "envFrom")]
        public IList<V1EnvFromSource> EnvFrom { get; set; }

        /// <summary>
        /// Gets or sets docker image name. More info:
        /// https://kubernetes.io/docs/concepts/containers/images
        /// </summary>
        [JsonProperty(PropertyName = "image")]
        public string Image { get; set; }

        /// <summary>
        /// Gets or sets image pull policy. One of Always, Never, IfNotPresent.
        /// Defaults to Always if :latest tag is specified, or IfNotPresent
        /// otherwise. Cannot be updated. More info:
        /// https://kubernetes.io/docs/concepts/containers/images#updating-images
        /// </summary>
        [JsonProperty(PropertyName = "imagePullPolicy")]
        public string ImagePullPolicy { get; set; }

        /// <summary>
        /// Gets or sets lifecycle is not allowed for ephemeral containers.
        /// </summary>
        [JsonProperty(PropertyName = "lifecycle")]
        public V1Lifecycle Lifecycle { get; set; }

        /// <summary>
        /// Gets or sets probes are not allowed for ephemeral containers.
        /// </summary>
        [JsonProperty(PropertyName = "livenessProbe")]
        public V1Probe LivenessProbe { get; set; }

        /// <summary>
        /// Gets or sets name of the ephemeral container specified as a
        /// DNS_LABEL. This name must be unique among all containers, init
        /// containers and ephemeral containers.
        /// </summary>
        [JsonProperty(PropertyName = "name")]
        public string Name { get; set; }

        /// <summary>
        /// Gets or sets ports are not allowed for ephemeral containers.
        /// </summary>
        [JsonProperty(PropertyName = "ports")]
        public IList<V1ContainerPort> Ports { get; set; }

        /// <summary>
        /// Gets or sets probes are not allowed for ephemeral containers.
        /// </summary>
        [JsonProperty(PropertyName = "readinessProbe")]
        public V1Probe ReadinessProbe { get; set; }

        /// <summary>
        /// Gets or sets resources are not allowed for ephemeral containers.
        /// Ephemeral containers use spare resources already allocated to the
        /// pod.
        /// </summary>
        [JsonProperty(PropertyName = "resources")]
        public V1ResourceRequirements Resources { get; set; }

        /// <summary>
        /// Gets or sets securityContext is not allowed for ephemeral
        /// containers.
        /// </summary>
        [JsonProperty(PropertyName = "securityContext")]
        public V1SecurityContext SecurityContext { get; set; }

        /// <summary>
        /// Gets or sets probes are not allowed for ephemeral containers.
        /// </summary>
        [JsonProperty(PropertyName = "startupProbe")]
        public V1Probe StartupProbe { get; set; }

        /// <summary>
        /// Gets or sets whether this container should allocate a buffer for
        /// stdin in the container runtime. If this is not set, reads from
        /// stdin in the container will always result in EOF. Default is false.
        /// </summary>
        [JsonProperty(PropertyName = "stdin")]
        public bool? Stdin { get; set; }

        /// <summary>
        /// Gets or sets whether the container runtime should close the stdin
        /// channel after it has been opened by a single attach. When stdin is
        /// true the stdin stream will remain open across multiple attach
        /// sessions. If stdinOnce is set to true, stdin is opened on container
        /// start, is empty until the first client attaches to stdin, and then
        /// remains open and accepts data until the client disconnects, at
        /// which time stdin is closed and remains closed until the container
        /// is restarted. If this flag is false, a container processes that
        /// reads from stdin will never receive an EOF. Default is false
        /// </summary>
        [JsonProperty(PropertyName = "stdinOnce")]
        public bool? StdinOnce { get; set; }

        /// <summary>
        /// Gets or sets if set, the name of the container from PodSpec that
        /// this ephemeral container targets. The ephemeral container will be
        /// run in the namespaces (IPC, PID, etc) of this container. If not set
        /// then the ephemeral container is run in whatever namespaces are
        /// shared for the pod. Note that the container runtime must support
        /// this feature.
        /// </summary>
        [JsonProperty(PropertyName = "targetContainerName")]
        public string TargetContainerName { get; set; }

        /// <summary>
        /// Gets or sets optional: Path at which the file to which the
        /// container's termination message will be written is mounted into the
        /// container's filesystem. Message written is intended to be brief
        /// final status, such as an assertion failure message. Will be
        /// truncated by the node if greater than 4096 bytes. The total message
        /// length across all containers will be limited to 12kb. Defaults to
        /// /dev/termination-log. Cannot be updated.
        /// </summary>
        [JsonProperty(PropertyName = "terminationMessagePath")]
        public string TerminationMessagePath { get; set; }

        /// <summary>
        /// Gets or sets indicate how the termination message should be
        /// populated. File will use the contents of terminationMessagePath to
        /// populate the container status message on both success and failure.
        /// FallbackToLogsOnError will use the last chunk of container log
        /// output if the termination message file is empty and the container
        /// exited with an error. The log output is limited to 2048 bytes or 80
        /// lines, whichever is smaller. Defaults to File. Cannot be updated.
        /// </summary>
        [JsonProperty(PropertyName = "terminationMessagePolicy")]
        public string TerminationMessagePolicy { get; set; }

        /// <summary>
        /// Gets or sets whether this container should allocate a TTY for
        /// itself, also requires 'stdin' to be true. Default is false.
        /// </summary>
        [JsonProperty(PropertyName = "tty")]
        public bool? Tty { get; set; }

        /// <summary>
        /// Gets or sets volumeDevices is the list of block devices to be used
        /// by the container.
        /// </summary>
        [JsonProperty(PropertyName = "volumeDevices")]
        public IList<V1VolumeDevice> VolumeDevices { get; set; }

        /// <summary>
        /// Gets or sets pod volumes to mount into the container's filesystem.
        /// Cannot be updated.
        /// </summary>
        [JsonProperty(PropertyName = "volumeMounts")]
        public IList<V1VolumeMount> VolumeMounts { get; set; }

        /// <summary>
        /// Gets or sets container's working directory. If not specified, the
        /// container runtime's default will be used, which might be configured
        /// in the container image. Cannot be updated.
        /// </summary>
        [JsonProperty(PropertyName = "workingDir")]
        public string WorkingDir { get; set; }

        /// <summary>
        /// Validate the object.
        /// </summary>
        /// <exception cref="ValidationException">
        /// Thrown if validation fails
        /// </exception>
        public virtual void Validate()
        {
            if (Name == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "Name");
            }
            if (Env != null)
            {
                foreach (var element in Env)
                {
                    if (element != null)
                    {
                        element.Validate();
                    }
                }
            }
            if (Lifecycle != null)
            {
                Lifecycle.Validate();
            }
            if (LivenessProbe != null)
            {
                LivenessProbe.Validate();
            }
            if (Ports != null)
            {
                foreach (var element1 in Ports)
                {
                    if (element1 != null)
                    {
                        element1.Validate();
                    }
                }
            }
            if (ReadinessProbe != null)
            {
                ReadinessProbe.Validate();
            }
            if (SecurityContext != null)
            {
                SecurityContext.Validate();
            }
            if (StartupProbe != null)
            {
                StartupProbe.Validate();
            }
            if (VolumeDevices != null)
            {
                foreach (var element2 in VolumeDevices)
                {
                    if (element2 != null)
                    {
                        element2.Validate();
                    }
                }
            }
            if (VolumeMounts != null)
            {
                foreach (var element3 in VolumeMounts)
                {
                    if (element3 != null)
                    {
                        element3.Validate();
                    }
                }
            }
        }
    }
}
