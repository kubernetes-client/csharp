// <auto-generated>
// Code generated by https://github.com/kubernetes-client/csharp/tree/master/gen/KubernetesGenerator
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace k8s.Models
{
    using Microsoft.Rest;
    using Newtonsoft.Json;
    using System.Collections.Generic;
    using System.Collections;
    using System.Linq;

    /// <summary>
    /// PersistentVolumeSpec is the specification of a persistent volume.
    /// </summary>
    public partial class V1PersistentVolumeSpec
    {
        /// <summary>
        /// Initializes a new instance of the V1PersistentVolumeSpec class.
        /// </summary>
        public V1PersistentVolumeSpec()
        {
            CustomInit();
        }

        /// <summary>
        /// Initializes a new instance of the V1PersistentVolumeSpec class.
        /// </summary>
        /// <param name="accessModes">
        /// AccessModes contains all ways the volume can be mounted. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes
        /// </param>
        /// <param name="awsElasticBlockStore">
        /// AWSElasticBlockStore represents an AWS Disk resource that is attached to a
        /// kubelet&apos;s host machine and then exposed to the pod. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        /// </param>
        /// <param name="azureDisk">
        /// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the
        /// pod.
        /// </param>
        /// <param name="azureFile">
        /// AzureFile represents an Azure File Service mount on the host and bind mount to
        /// the pod.
        /// </param>
        /// <param name="capacity">
        /// A description of the persistent volume&apos;s resources and capacity. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
        /// </param>
        /// <param name="cephfs">
        /// CephFS represents a Ceph FS mount on the host that shares a pod&apos;s lifetime
        /// </param>
        /// <param name="cinder">
        /// Cinder represents a cinder volume attached and mounted on kubelets host machine.
        /// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        /// </param>
        /// <param name="claimRef">
        /// ClaimRef is part of a bi-directional binding between PersistentVolume and
        /// PersistentVolumeClaim. Expected to be non-nil when bound. claim.VolumeName is
        /// the authoritative bind between PV and PVC. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding
        /// </param>
        /// <param name="csi">
        /// CSI represents storage that is handled by an external CSI driver (Beta feature).
        /// </param>
        /// <param name="fc">
        /// FC represents a Fibre Channel resource that is attached to a kubelet&apos;s host
        /// machine and then exposed to the pod.
        /// </param>
        /// <param name="flexVolume">
        /// FlexVolume represents a generic volume resource that is provisioned/attached
        /// using an exec based plugin.
        /// </param>
        /// <param name="flocker">
        /// Flocker represents a Flocker volume attached to a kubelet&apos;s host machine and
        /// exposed to the pod for its usage. This depends on the Flocker control service
        /// being running
        /// </param>
        /// <param name="gcePersistentDisk">
        /// GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet&apos;s
        /// host machine and then exposed to the pod. Provisioned by an admin. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        /// </param>
        /// <param name="glusterfs">
        /// Glusterfs represents a Glusterfs volume that is attached to a host and exposed
        /// to the pod. Provisioned by an admin. More info:
        /// https://examples.k8s.io/volumes/glusterfs/README.md
        /// </param>
        /// <param name="hostPath">
        /// HostPath represents a directory on the host. Provisioned by a developer or
        /// tester. This is useful for single-node development and testing only! On-host
        /// storage is not supported in any way and WILL NOT WORK in a multi-node cluster.
        /// More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
        /// </param>
        /// <param name="iscsi">
        /// ISCSI represents an ISCSI Disk resource that is attached to a kubelet&apos;s host
        /// machine and then exposed to the pod. Provisioned by an admin.
        /// </param>
        /// <param name="local">
        /// Local represents directly-attached storage with node affinity
        /// </param>
        /// <param name="mountOptions">
        /// A list of mount options, e.g. [&quot;ro&quot;, &quot;soft&quot;]. Not validated - mount will simply
        /// fail if one is invalid. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options
        /// </param>
        /// <param name="nfs">
        /// NFS represents an NFS mount on the host. Provisioned by an admin. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#nfs
        /// </param>
        /// <param name="nodeAffinity">
        /// NodeAffinity defines constraints that limit what nodes this volume can be
        /// accessed from. This field influences the scheduling of pods that use this
        /// volume.
        /// </param>
        /// <param name="persistentVolumeReclaimPolicy">
        /// What happens to a persistent volume when released from its claim. Valid options
        /// are Retain (default for manually created PersistentVolumes), Delete (default for
        /// dynamically provisioned PersistentVolumes), and Recycle (deprecated). Recycle
        /// must be supported by the volume plugin underlying this PersistentVolume. More
        /// info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming
        /// </param>
        /// <param name="photonPersistentDisk">
        /// PhotonPersistentDisk represents a PhotonController persistent disk attached and
        /// mounted on kubelets host machine
        /// </param>
        /// <param name="portworxVolume">
        /// PortworxVolume represents a portworx volume attached and mounted on kubelets
        /// host machine
        /// </param>
        /// <param name="quobyte">
        /// Quobyte represents a Quobyte mount on the host that shares a pod&apos;s lifetime
        /// </param>
        /// <param name="rbd">
        /// RBD represents a Rados Block Device mount on the host that shares a pod&apos;s
        /// lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
        /// </param>
        /// <param name="scaleIO">
        /// ScaleIO represents a ScaleIO persistent volume attached and mounted on
        /// Kubernetes nodes.
        /// </param>
        /// <param name="storageClassName">
        /// Name of StorageClass to which this persistent volume belongs. Empty value means
        /// that this volume does not belong to any StorageClass.
        /// </param>
        /// <param name="storageos">
        /// StorageOS represents a StorageOS volume that is attached to the kubelet&apos;s host
        /// machine and mounted into the pod More info:
        /// https://examples.k8s.io/volumes/storageos/README.md
        /// </param>
        /// <param name="volumeMode">
        /// volumeMode defines if a volume is intended to be used with a formatted
        /// filesystem or to remain in raw block state. Value of Filesystem is implied when
        /// not included in spec.
        /// </param>
        /// <param name="vsphereVolume">
        /// VsphereVolume represents a vSphere volume attached and mounted on kubelets host
        /// machine
        /// </param>
        public V1PersistentVolumeSpec(IList<string> accessModes = null, V1AWSElasticBlockStoreVolumeSource awsElasticBlockStore = null, V1AzureDiskVolumeSource azureDisk = null, V1AzureFilePersistentVolumeSource azureFile = null, IDictionary<string, ResourceQuantity> capacity = null, V1CephFSPersistentVolumeSource cephfs = null, V1CinderPersistentVolumeSource cinder = null, V1ObjectReference claimRef = null, V1CSIPersistentVolumeSource csi = null, V1FCVolumeSource fc = null, V1FlexPersistentVolumeSource flexVolume = null, V1FlockerVolumeSource flocker = null, V1GCEPersistentDiskVolumeSource gcePersistentDisk = null, V1GlusterfsPersistentVolumeSource glusterfs = null, V1HostPathVolumeSource hostPath = null, V1ISCSIPersistentVolumeSource iscsi = null, V1LocalVolumeSource local = null, IList<string> mountOptions = null, V1NFSVolumeSource nfs = null, V1VolumeNodeAffinity nodeAffinity = null, string persistentVolumeReclaimPolicy = null, V1PhotonPersistentDiskVolumeSource photonPersistentDisk = null, V1PortworxVolumeSource portworxVolume = null, V1QuobyteVolumeSource quobyte = null, V1RBDPersistentVolumeSource rbd = null, V1ScaleIOPersistentVolumeSource scaleIO = null, string storageClassName = null, V1StorageOSPersistentVolumeSource storageos = null, string volumeMode = null, V1VsphereVirtualDiskVolumeSource vsphereVolume = null)
        {
            AccessModes = accessModes;
            AwsElasticBlockStore = awsElasticBlockStore;
            AzureDisk = azureDisk;
            AzureFile = azureFile;
            Capacity = capacity;
            Cephfs = cephfs;
            Cinder = cinder;
            ClaimRef = claimRef;
            Csi = csi;
            Fc = fc;
            FlexVolume = flexVolume;
            Flocker = flocker;
            GcePersistentDisk = gcePersistentDisk;
            Glusterfs = glusterfs;
            HostPath = hostPath;
            Iscsi = iscsi;
            Local = local;
            MountOptions = mountOptions;
            Nfs = nfs;
            NodeAffinity = nodeAffinity;
            PersistentVolumeReclaimPolicy = persistentVolumeReclaimPolicy;
            PhotonPersistentDisk = photonPersistentDisk;
            PortworxVolume = portworxVolume;
            Quobyte = quobyte;
            Rbd = rbd;
            ScaleIO = scaleIO;
            StorageClassName = storageClassName;
            Storageos = storageos;
            VolumeMode = volumeMode;
            VsphereVolume = vsphereVolume;
            CustomInit();
        }

        /// <summary>
        /// An initialization method that performs custom operations like setting defaults
        /// </summary>
        partial void CustomInit();

        /// <summary>
        /// AccessModes contains all ways the volume can be mounted. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes
        /// </summary>
        [JsonProperty(PropertyName = "accessModes")]
        public IList<string> AccessModes { get; set; }

        /// <summary>
        /// AWSElasticBlockStore represents an AWS Disk resource that is attached to a
        /// kubelet&apos;s host machine and then exposed to the pod. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        /// </summary>
        [JsonProperty(PropertyName = "awsElasticBlockStore")]
        public V1AWSElasticBlockStoreVolumeSource AwsElasticBlockStore { get; set; }

        /// <summary>
        /// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the
        /// pod.
        /// </summary>
        [JsonProperty(PropertyName = "azureDisk")]
        public V1AzureDiskVolumeSource AzureDisk { get; set; }

        /// <summary>
        /// AzureFile represents an Azure File Service mount on the host and bind mount to
        /// the pod.
        /// </summary>
        [JsonProperty(PropertyName = "azureFile")]
        public V1AzureFilePersistentVolumeSource AzureFile { get; set; }

        /// <summary>
        /// A description of the persistent volume&apos;s resources and capacity. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
        /// </summary>
        [JsonProperty(PropertyName = "capacity")]
        public IDictionary<string, ResourceQuantity> Capacity { get; set; }

        /// <summary>
        /// CephFS represents a Ceph FS mount on the host that shares a pod&apos;s lifetime
        /// </summary>
        [JsonProperty(PropertyName = "cephfs")]
        public V1CephFSPersistentVolumeSource Cephfs { get; set; }

        /// <summary>
        /// Cinder represents a cinder volume attached and mounted on kubelets host machine.
        /// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        /// </summary>
        [JsonProperty(PropertyName = "cinder")]
        public V1CinderPersistentVolumeSource Cinder { get; set; }

        /// <summary>
        /// ClaimRef is part of a bi-directional binding between PersistentVolume and
        /// PersistentVolumeClaim. Expected to be non-nil when bound. claim.VolumeName is
        /// the authoritative bind between PV and PVC. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding
        /// </summary>
        [JsonProperty(PropertyName = "claimRef")]
        public V1ObjectReference ClaimRef { get; set; }

        /// <summary>
        /// CSI represents storage that is handled by an external CSI driver (Beta feature).
        /// </summary>
        [JsonProperty(PropertyName = "csi")]
        public V1CSIPersistentVolumeSource Csi { get; set; }

        /// <summary>
        /// FC represents a Fibre Channel resource that is attached to a kubelet&apos;s host
        /// machine and then exposed to the pod.
        /// </summary>
        [JsonProperty(PropertyName = "fc")]
        public V1FCVolumeSource Fc { get; set; }

        /// <summary>
        /// FlexVolume represents a generic volume resource that is provisioned/attached
        /// using an exec based plugin.
        /// </summary>
        [JsonProperty(PropertyName = "flexVolume")]
        public V1FlexPersistentVolumeSource FlexVolume { get; set; }

        /// <summary>
        /// Flocker represents a Flocker volume attached to a kubelet&apos;s host machine and
        /// exposed to the pod for its usage. This depends on the Flocker control service
        /// being running
        /// </summary>
        [JsonProperty(PropertyName = "flocker")]
        public V1FlockerVolumeSource Flocker { get; set; }

        /// <summary>
        /// GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet&apos;s
        /// host machine and then exposed to the pod. Provisioned by an admin. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        /// </summary>
        [JsonProperty(PropertyName = "gcePersistentDisk")]
        public V1GCEPersistentDiskVolumeSource GcePersistentDisk { get; set; }

        /// <summary>
        /// Glusterfs represents a Glusterfs volume that is attached to a host and exposed
        /// to the pod. Provisioned by an admin. More info:
        /// https://examples.k8s.io/volumes/glusterfs/README.md
        /// </summary>
        [JsonProperty(PropertyName = "glusterfs")]
        public V1GlusterfsPersistentVolumeSource Glusterfs { get; set; }

        /// <summary>
        /// HostPath represents a directory on the host. Provisioned by a developer or
        /// tester. This is useful for single-node development and testing only! On-host
        /// storage is not supported in any way and WILL NOT WORK in a multi-node cluster.
        /// More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
        /// </summary>
        [JsonProperty(PropertyName = "hostPath")]
        public V1HostPathVolumeSource HostPath { get; set; }

        /// <summary>
        /// ISCSI represents an ISCSI Disk resource that is attached to a kubelet&apos;s host
        /// machine and then exposed to the pod. Provisioned by an admin.
        /// </summary>
        [JsonProperty(PropertyName = "iscsi")]
        public V1ISCSIPersistentVolumeSource Iscsi { get; set; }

        /// <summary>
        /// Local represents directly-attached storage with node affinity
        /// </summary>
        [JsonProperty(PropertyName = "local")]
        public V1LocalVolumeSource Local { get; set; }

        /// <summary>
        /// A list of mount options, e.g. [&quot;ro&quot;, &quot;soft&quot;]. Not validated - mount will simply
        /// fail if one is invalid. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options
        /// </summary>
        [JsonProperty(PropertyName = "mountOptions")]
        public IList<string> MountOptions { get; set; }

        /// <summary>
        /// NFS represents an NFS mount on the host. Provisioned by an admin. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#nfs
        /// </summary>
        [JsonProperty(PropertyName = "nfs")]
        public V1NFSVolumeSource Nfs { get; set; }

        /// <summary>
        /// NodeAffinity defines constraints that limit what nodes this volume can be
        /// accessed from. This field influences the scheduling of pods that use this
        /// volume.
        /// </summary>
        [JsonProperty(PropertyName = "nodeAffinity")]
        public V1VolumeNodeAffinity NodeAffinity { get; set; }

        /// <summary>
        /// What happens to a persistent volume when released from its claim. Valid options
        /// are Retain (default for manually created PersistentVolumes), Delete (default for
        /// dynamically provisioned PersistentVolumes), and Recycle (deprecated). Recycle
        /// must be supported by the volume plugin underlying this PersistentVolume. More
        /// info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming
        /// </summary>
        [JsonProperty(PropertyName = "persistentVolumeReclaimPolicy")]
        public string PersistentVolumeReclaimPolicy { get; set; }

        /// <summary>
        /// PhotonPersistentDisk represents a PhotonController persistent disk attached and
        /// mounted on kubelets host machine
        /// </summary>
        [JsonProperty(PropertyName = "photonPersistentDisk")]
        public V1PhotonPersistentDiskVolumeSource PhotonPersistentDisk { get; set; }

        /// <summary>
        /// PortworxVolume represents a portworx volume attached and mounted on kubelets
        /// host machine
        /// </summary>
        [JsonProperty(PropertyName = "portworxVolume")]
        public V1PortworxVolumeSource PortworxVolume { get; set; }

        /// <summary>
        /// Quobyte represents a Quobyte mount on the host that shares a pod&apos;s lifetime
        /// </summary>
        [JsonProperty(PropertyName = "quobyte")]
        public V1QuobyteVolumeSource Quobyte { get; set; }

        /// <summary>
        /// RBD represents a Rados Block Device mount on the host that shares a pod&apos;s
        /// lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
        /// </summary>
        [JsonProperty(PropertyName = "rbd")]
        public V1RBDPersistentVolumeSource Rbd { get; set; }

        /// <summary>
        /// ScaleIO represents a ScaleIO persistent volume attached and mounted on
        /// Kubernetes nodes.
        /// </summary>
        [JsonProperty(PropertyName = "scaleIO")]
        public V1ScaleIOPersistentVolumeSource ScaleIO { get; set; }

        /// <summary>
        /// Name of StorageClass to which this persistent volume belongs. Empty value means
        /// that this volume does not belong to any StorageClass.
        /// </summary>
        [JsonProperty(PropertyName = "storageClassName")]
        public string StorageClassName { get; set; }

        /// <summary>
        /// StorageOS represents a StorageOS volume that is attached to the kubelet&apos;s host
        /// machine and mounted into the pod More info:
        /// https://examples.k8s.io/volumes/storageos/README.md
        /// </summary>
        [JsonProperty(PropertyName = "storageos")]
        public V1StorageOSPersistentVolumeSource Storageos { get; set; }

        /// <summary>
        /// volumeMode defines if a volume is intended to be used with a formatted
        /// filesystem or to remain in raw block state. Value of Filesystem is implied when
        /// not included in spec.
        /// </summary>
        [JsonProperty(PropertyName = "volumeMode")]
        public string VolumeMode { get; set; }

        /// <summary>
        /// VsphereVolume represents a vSphere volume attached and mounted on kubelets host
        /// machine
        /// </summary>
        [JsonProperty(PropertyName = "vsphereVolume")]
        public V1VsphereVirtualDiskVolumeSource VsphereVolume { get; set; }

        /// <summary>
        /// Validate the object.
        /// </summary>
        /// <exception cref="ValidationException">
        /// Thrown if validation fails
        /// </exception>
        public virtual void Validate()
        {
            AwsElasticBlockStore?.Validate();
            AzureDisk?.Validate();
            AzureFile?.Validate();
            Cephfs?.Validate();
            Cinder?.Validate();
            ClaimRef?.Validate();
            Csi?.Validate();
            Fc?.Validate();
            FlexVolume?.Validate();
            Flocker?.Validate();
            GcePersistentDisk?.Validate();
            Glusterfs?.Validate();
            HostPath?.Validate();
            Iscsi?.Validate();
            Local?.Validate();
            Nfs?.Validate();
            NodeAffinity?.Validate();
            PhotonPersistentDisk?.Validate();
            PortworxVolume?.Validate();
            Quobyte?.Validate();
            Rbd?.Validate();
            ScaleIO?.Validate();
            Storageos?.Validate();
            VsphereVolume?.Validate();
        }
    }
}
