// <auto-generated>
// Code generated by https://github.com/kubernetes-client/csharp/tree/master/gen/KubernetesGenerator
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace k8s.Models
{
    /// <summary>
    /// PodSpec is a description of a pod.
    /// </summary>
    public partial class V1PodSpec
    {
        /// <summary>
        /// Initializes a new instance of the V1PodSpec class.
        /// </summary>
        public V1PodSpec()
        {
            CustomInit();
        }

        /// <summary>
        /// Initializes a new instance of the V1PodSpec class.
        /// </summary>
        /// <param name="containers">
        /// List of containers belonging to the pod. Containers cannot currently be added or
        /// removed. There must be at least one container in a Pod. Cannot be updated.
        /// </param>
        /// <param name="activeDeadlineSeconds">
        /// Optional duration in seconds the pod may be active on the node relative to
        /// StartTime before the system will actively try to mark it failed and kill
        /// associated containers. Value must be a positive integer.
        /// </param>
        /// <param name="affinity">
        /// If specified, the pod&apos;s scheduling constraints
        /// </param>
        /// <param name="automountServiceAccountToken">
        /// AutomountServiceAccountToken indicates whether a service account token should be
        /// automatically mounted.
        /// </param>
        /// <param name="dnsConfig">
        /// Specifies the DNS parameters of a pod. Parameters specified here will be merged
        /// to the generated DNS configuration based on DNSPolicy.
        /// </param>
        /// <param name="dnsPolicy">
        /// Set DNS policy for the pod. Defaults to &quot;ClusterFirst&quot;. Valid values are
        /// &apos;ClusterFirstWithHostNet&apos;, &apos;ClusterFirst&apos;, &apos;Default&apos; or &apos;None&apos;. DNS parameters
        /// given in DNSConfig will be merged with the policy selected with DNSPolicy. To
        /// have DNS options set along with hostNetwork, you have to specify DNS policy
        /// explicitly to &apos;ClusterFirstWithHostNet&apos;.
        /// 
        /// Possible enum values:
        /// - `&quot;ClusterFirst&quot;` indicates that the pod should use cluster DNS first unless
        /// hostNetwork is true, if it is available, then fall back on the default (as
        /// determined by kubelet) DNS settings.
        /// - `&quot;ClusterFirstWithHostNet&quot;` indicates that the pod should use cluster DNS
        /// first, if it is available, then fall back on the default (as determined by
        /// kubelet) DNS settings.
        /// - `&quot;Default&quot;` indicates that the pod should use the default (as determined by
        /// kubelet) DNS settings.
        /// - `&quot;None&quot;` indicates that the pod should use empty DNS settings. DNS parameters
        /// such as nameservers and search paths should be defined via DNSConfig.
        /// </param>
        /// <param name="enableServiceLinks">
        /// EnableServiceLinks indicates whether information about services should be
        /// injected into pod&apos;s environment variables, matching the syntax of Docker links.
        /// Optional: Defaults to true.
        /// </param>
        /// <param name="ephemeralContainers">
        /// List of ephemeral containers run in this pod. Ephemeral containers may be run in
        /// an existing pod to perform user-initiated actions such as debugging. This list
        /// cannot be specified when creating a pod, and it cannot be modified by updating
        /// the pod spec. In order to add an ephemeral container to an existing pod, use the
        /// pod&apos;s ephemeralcontainers subresource. This field is beta-level and available on
        /// clusters that haven&apos;t disabled the EphemeralContainers feature gate.
        /// </param>
        /// <param name="hostAliases">
        /// HostAliases is an optional list of hosts and IPs that will be injected into the
        /// pod&apos;s hosts file if specified. This is only valid for non-hostNetwork pods.
        /// </param>
        /// <param name="hostIPC">
        /// Use the host&apos;s ipc namespace. Optional: Default to false.
        /// </param>
        /// <param name="hostNetwork">
        /// Host networking requested for this pod. Use the host&apos;s network namespace. If
        /// this option is set, the ports that will be used must be specified. Default to
        /// false.
        /// </param>
        /// <param name="hostPID">
        /// Use the host&apos;s pid namespace. Optional: Default to false.
        /// </param>
        /// <param name="hostname">
        /// Specifies the hostname of the Pod If not specified, the pod&apos;s hostname will be
        /// set to a system-defined value.
        /// </param>
        /// <param name="imagePullSecrets">
        /// ImagePullSecrets is an optional list of references to secrets in the same
        /// namespace to use for pulling any of the images used by this PodSpec. If
        /// specified, these secrets will be passed to individual puller implementations for
        /// them to use. For example, in the case of docker, only DockerConfig type secrets
        /// are honored. More info:
        /// https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
        /// </param>
        /// <param name="initContainers">
        /// List of initialization containers belonging to the pod. Init containers are
        /// executed in order prior to containers being started. If any init container
        /// fails, the pod is considered to have failed and is handled according to its
        /// restartPolicy. The name for an init container or normal container must be unique
        /// among all containers. Init containers may not have Lifecycle actions, Readiness
        /// probes, Liveness probes, or Startup probes. The resourceRequirements of an init
        /// container are taken into account during scheduling by finding the highest
        /// request/limit for each resource type, and then using the max of of that value or
        /// the sum of the normal containers. Limits are applied to init containers in a
        /// similar fashion. Init containers cannot currently be added or removed. Cannot be
        /// updated. More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
        /// </param>
        /// <param name="nodeName">
        /// NodeName is a request to schedule this pod onto a specific node. If it is
        /// non-empty, the scheduler simply schedules this pod onto that node, assuming that
        /// it fits resource requirements.
        /// </param>
        /// <param name="nodeSelector">
        /// NodeSelector is a selector which must be true for the pod to fit on a node.
        /// Selector which must match a node&apos;s labels for the pod to be scheduled on that
        /// node. More info:
        /// https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
        /// </param>
        /// <param name="os">
        /// Specifies the OS of the containers in the pod. Some pod and container fields are
        /// restricted if this is set.
        /// 
        /// If the OS field is set to linux, the following fields must be unset:
        /// -securityContext.windowsOptions
        /// 
        /// If the OS field is set to windows, following fields must be unset: -
        /// spec.hostPID - spec.hostIPC - spec.securityContext.seLinuxOptions -
        /// spec.securityContext.seccompProfile - spec.securityContext.fsGroup -
        /// spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls -
        /// spec.shareProcessNamespace - spec.securityContext.runAsUser -
        /// spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups -
        /// spec.containers[*].securityContext.seLinuxOptions -
        /// spec.containers[*].securityContext.seccompProfile -
        /// spec.containers[*].securityContext.capabilities -
        /// spec.containers[*].securityContext.readOnlyRootFilesystem -
        /// spec.containers[*].securityContext.privileged -
        /// spec.containers[*].securityContext.allowPrivilegeEscalation -
        /// spec.containers[*].securityContext.procMount -
        /// spec.containers[*].securityContext.runAsUser -
        /// spec.containers[*].securityContext.runAsGroup This is an alpha field and
        /// requires the IdentifyPodOS feature
        /// </param>
        /// <param name="overhead">
        /// Overhead represents the resource overhead associated with running a pod for a
        /// given RuntimeClass. This field will be autopopulated at admission time by the
        /// RuntimeClass admission controller. If the RuntimeClass admission controller is
        /// enabled, overhead must not be set in Pod create requests. The RuntimeClass
        /// admission controller will reject Pod create requests which have the overhead
        /// already set. If RuntimeClass is configured and selected in the PodSpec, Overhead
        /// will be set to the value defined in the corresponding RuntimeClass, otherwise it
        /// will remain unset and treated as zero. More info:
        /// https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md This
        /// field is beta-level as of Kubernetes v1.18, and is only honored by servers that
        /// enable the PodOverhead feature.
        /// </param>
        /// <param name="preemptionPolicy">
        /// PreemptionPolicy is the Policy for preempting pods with lower priority. One of
        /// Never, PreemptLowerPriority. Defaults to PreemptLowerPriority if unset. This
        /// field is beta-level, gated by the NonPreemptingPriority feature-gate.
        /// </param>
        /// <param name="priority">
        /// The priority value. Various system components use this field to find the
        /// priority of the pod. When Priority Admission Controller is enabled, it prevents
        /// users from setting this field. The admission controller populates this field
        /// from PriorityClassName. The higher the value, the higher the priority.
        /// </param>
        /// <param name="priorityClassName">
        /// If specified, indicates the pod&apos;s priority. &quot;system-node-critical&quot; and
        /// &quot;system-cluster-critical&quot; are two special keywords which indicate the highest
        /// priorities with the former being the highest priority. Any other name must be
        /// defined by creating a PriorityClass object with that name. If not specified, the
        /// pod priority will be default or zero if there is no default.
        /// </param>
        /// <param name="readinessGates">
        /// If specified, all readiness gates will be evaluated for pod readiness. A pod is
        /// ready when all its containers are ready AND all conditions specified in the
        /// readiness gates have status equal to &quot;True&quot; More info:
        /// https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates
        /// </param>
        /// <param name="restartPolicy">
        /// Restart policy for all containers within the pod. One of Always, OnFailure,
        /// Never. Default to Always. More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
        /// 
        /// Possible enum values:
        /// - `&quot;Always&quot;`
        /// - `&quot;Never&quot;`
        /// - `&quot;OnFailure&quot;`
        /// </param>
        /// <param name="runtimeClassName">
        /// RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which
        /// should be used to run this pod.  If no RuntimeClass resource matches the named
        /// class, the pod will not be run. If unset or empty, the &quot;legacy&quot; RuntimeClass
        /// will be used, which is an implicit class with an empty definition that uses the
        /// default runtime handler. More info:
        /// https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class This is a beta
        /// feature as of Kubernetes v1.14.
        /// </param>
        /// <param name="schedulerName">
        /// If specified, the pod will be dispatched by specified scheduler. If not
        /// specified, the pod will be dispatched by default scheduler.
        /// </param>
        /// <param name="securityContext">
        /// SecurityContext holds pod-level security attributes and common container
        /// settings. Optional: Defaults to empty.  See type description for default values
        /// of each field.
        /// </param>
        /// <param name="serviceAccount">
        /// DeprecatedServiceAccount is a depreciated alias for ServiceAccountName.
        /// Deprecated: Use serviceAccountName instead.
        /// </param>
        /// <param name="serviceAccountName">
        /// ServiceAccountName is the name of the ServiceAccount to use to run this pod.
        /// More info:
        /// https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
        /// </param>
        /// <param name="setHostnameAsFQDN">
        /// If true the pod&apos;s hostname will be configured as the pod&apos;s FQDN, rather than the
        /// leaf name (the default). In Linux containers, this means setting the FQDN in the
        /// hostname field of the kernel (the nodename field of struct utsname). In Windows
        /// containers, this means setting the registry value of hostname for the registry
        /// key HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters to
        /// FQDN. If a pod does not have FQDN, this has no effect. Default to false.
        /// </param>
        /// <param name="shareProcessNamespace">
        /// Share a single process namespace between all of the containers in a pod. When
        /// this is set containers will be able to view and signal processes from other
        /// containers in the same pod, and the first process in each container will not be
        /// assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional:
        /// Default to false.
        /// </param>
        /// <param name="subdomain">
        /// If specified, the fully qualified Pod hostname will be
        /// &quot;&lt;hostname&gt;.&lt;subdomain&gt;.&lt;pod namespace&gt;.svc.&lt;cluster domain&gt;&quot;. If not specified,
        /// the pod will not have a domainname at all.
        /// </param>
        /// <param name="terminationGracePeriodSeconds">
        /// Optional duration in seconds the pod needs to terminate gracefully. May be
        /// decreased in delete request. Value must be non-negative integer. The value zero
        /// indicates stop immediately via the kill signal (no opportunity to shut down). If
        /// this value is nil, the default grace period will be used instead. The grace
        /// period is the duration in seconds after the processes running in the pod are
        /// sent a termination signal and the time when the processes are forcibly halted
        /// with a kill signal. Set this value longer than the expected cleanup time for
        /// your process. Defaults to 30 seconds.
        /// </param>
        /// <param name="tolerations">
        /// If specified, the pod&apos;s tolerations.
        /// </param>
        /// <param name="topologySpreadConstraints">
        /// TopologySpreadConstraints describes how a group of pods ought to spread across
        /// topology domains. Scheduler will schedule pods in a way which abides by the
        /// constraints. All topologySpreadConstraints are ANDed.
        /// </param>
        /// <param name="volumes">
        /// List of volumes that can be mounted by containers belonging to the pod. More
        /// info: https://kubernetes.io/docs/concepts/storage/volumes
        /// </param>
        public V1PodSpec(IList<V1Container> containers, long? activeDeadlineSeconds = null, V1Affinity affinity = null, bool? automountServiceAccountToken = null, V1PodDNSConfig dnsConfig = null, string dnsPolicy = null, bool? enableServiceLinks = null, IList<V1EphemeralContainer> ephemeralContainers = null, IList<V1HostAlias> hostAliases = null, bool? hostIPC = null, bool? hostNetwork = null, bool? hostPID = null, string hostname = null, IList<V1LocalObjectReference> imagePullSecrets = null, IList<V1Container> initContainers = null, string nodeName = null, IDictionary<string, string> nodeSelector = null, V1PodOS os = null, IDictionary<string, ResourceQuantity> overhead = null, string preemptionPolicy = null, int? priority = null, string priorityClassName = null, IList<V1PodReadinessGate> readinessGates = null, string restartPolicy = null, string runtimeClassName = null, string schedulerName = null, V1PodSecurityContext securityContext = null, string serviceAccount = null, string serviceAccountName = null, bool? setHostnameAsFQDN = null, bool? shareProcessNamespace = null, string subdomain = null, long? terminationGracePeriodSeconds = null, IList<V1Toleration> tolerations = null, IList<V1TopologySpreadConstraint> topologySpreadConstraints = null, IList<V1Volume> volumes = null)
        {
            ActiveDeadlineSeconds = activeDeadlineSeconds;
            Affinity = affinity;
            AutomountServiceAccountToken = automountServiceAccountToken;
            Containers = containers;
            DnsConfig = dnsConfig;
            DnsPolicy = dnsPolicy;
            EnableServiceLinks = enableServiceLinks;
            EphemeralContainers = ephemeralContainers;
            HostAliases = hostAliases;
            HostIPC = hostIPC;
            HostNetwork = hostNetwork;
            HostPID = hostPID;
            Hostname = hostname;
            ImagePullSecrets = imagePullSecrets;
            InitContainers = initContainers;
            NodeName = nodeName;
            NodeSelector = nodeSelector;
            Os = os;
            Overhead = overhead;
            PreemptionPolicy = preemptionPolicy;
            Priority = priority;
            PriorityClassName = priorityClassName;
            ReadinessGates = readinessGates;
            RestartPolicy = restartPolicy;
            RuntimeClassName = runtimeClassName;
            SchedulerName = schedulerName;
            SecurityContext = securityContext;
            ServiceAccount = serviceAccount;
            ServiceAccountName = serviceAccountName;
            SetHostnameAsFQDN = setHostnameAsFQDN;
            ShareProcessNamespace = shareProcessNamespace;
            Subdomain = subdomain;
            TerminationGracePeriodSeconds = terminationGracePeriodSeconds;
            Tolerations = tolerations;
            TopologySpreadConstraints = topologySpreadConstraints;
            Volumes = volumes;
            CustomInit();
        }

        /// <summary>
        /// An initialization method that performs custom operations like setting defaults
        /// </summary>
        partial void CustomInit();

        /// <summary>
        /// Optional duration in seconds the pod may be active on the node relative to
        /// StartTime before the system will actively try to mark it failed and kill
        /// associated containers. Value must be a positive integer.
        /// </summary>
        [JsonPropertyName("activeDeadlineSeconds")]
        public long? ActiveDeadlineSeconds { get; set; }

        /// <summary>
        /// If specified, the pod&apos;s scheduling constraints
        /// </summary>
        [JsonPropertyName("affinity")]
        public V1Affinity Affinity { get; set; }

        /// <summary>
        /// AutomountServiceAccountToken indicates whether a service account token should be
        /// automatically mounted.
        /// </summary>
        [JsonPropertyName("automountServiceAccountToken")]
        public bool? AutomountServiceAccountToken { get; set; }

        /// <summary>
        /// List of containers belonging to the pod. Containers cannot currently be added or
        /// removed. There must be at least one container in a Pod. Cannot be updated.
        /// </summary>
        [JsonPropertyName("containers")]
        public IList<V1Container> Containers { get; set; }

        /// <summary>
        /// Specifies the DNS parameters of a pod. Parameters specified here will be merged
        /// to the generated DNS configuration based on DNSPolicy.
        /// </summary>
        [JsonPropertyName("dnsConfig")]
        public V1PodDNSConfig DnsConfig { get; set; }

        /// <summary>
        /// Set DNS policy for the pod. Defaults to &quot;ClusterFirst&quot;. Valid values are
        /// &apos;ClusterFirstWithHostNet&apos;, &apos;ClusterFirst&apos;, &apos;Default&apos; or &apos;None&apos;. DNS parameters
        /// given in DNSConfig will be merged with the policy selected with DNSPolicy. To
        /// have DNS options set along with hostNetwork, you have to specify DNS policy
        /// explicitly to &apos;ClusterFirstWithHostNet&apos;.
        /// 
        /// Possible enum values:
        /// - `&quot;ClusterFirst&quot;` indicates that the pod should use cluster DNS first unless
        /// hostNetwork is true, if it is available, then fall back on the default (as
        /// determined by kubelet) DNS settings.
        /// - `&quot;ClusterFirstWithHostNet&quot;` indicates that the pod should use cluster DNS
        /// first, if it is available, then fall back on the default (as determined by
        /// kubelet) DNS settings.
        /// - `&quot;Default&quot;` indicates that the pod should use the default (as determined by
        /// kubelet) DNS settings.
        /// - `&quot;None&quot;` indicates that the pod should use empty DNS settings. DNS parameters
        /// such as nameservers and search paths should be defined via DNSConfig.
        /// </summary>
        [JsonPropertyName("dnsPolicy")]
        public string DnsPolicy { get; set; }

        /// <summary>
        /// EnableServiceLinks indicates whether information about services should be
        /// injected into pod&apos;s environment variables, matching the syntax of Docker links.
        /// Optional: Defaults to true.
        /// </summary>
        [JsonPropertyName("enableServiceLinks")]
        public bool? EnableServiceLinks { get; set; }

        /// <summary>
        /// List of ephemeral containers run in this pod. Ephemeral containers may be run in
        /// an existing pod to perform user-initiated actions such as debugging. This list
        /// cannot be specified when creating a pod, and it cannot be modified by updating
        /// the pod spec. In order to add an ephemeral container to an existing pod, use the
        /// pod&apos;s ephemeralcontainers subresource. This field is beta-level and available on
        /// clusters that haven&apos;t disabled the EphemeralContainers feature gate.
        /// </summary>
        [JsonPropertyName("ephemeralContainers")]
        public IList<V1EphemeralContainer> EphemeralContainers { get; set; }

        /// <summary>
        /// HostAliases is an optional list of hosts and IPs that will be injected into the
        /// pod&apos;s hosts file if specified. This is only valid for non-hostNetwork pods.
        /// </summary>
        [JsonPropertyName("hostAliases")]
        public IList<V1HostAlias> HostAliases { get; set; }

        /// <summary>
        /// Use the host&apos;s ipc namespace. Optional: Default to false.
        /// </summary>
        [JsonPropertyName("hostIPC")]
        public bool? HostIPC { get; set; }

        /// <summary>
        /// Host networking requested for this pod. Use the host&apos;s network namespace. If
        /// this option is set, the ports that will be used must be specified. Default to
        /// false.
        /// </summary>
        [JsonPropertyName("hostNetwork")]
        public bool? HostNetwork { get; set; }

        /// <summary>
        /// Use the host&apos;s pid namespace. Optional: Default to false.
        /// </summary>
        [JsonPropertyName("hostPID")]
        public bool? HostPID { get; set; }

        /// <summary>
        /// Specifies the hostname of the Pod If not specified, the pod&apos;s hostname will be
        /// set to a system-defined value.
        /// </summary>
        [JsonPropertyName("hostname")]
        public string Hostname { get; set; }

        /// <summary>
        /// ImagePullSecrets is an optional list of references to secrets in the same
        /// namespace to use for pulling any of the images used by this PodSpec. If
        /// specified, these secrets will be passed to individual puller implementations for
        /// them to use. For example, in the case of docker, only DockerConfig type secrets
        /// are honored. More info:
        /// https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
        /// </summary>
        [JsonPropertyName("imagePullSecrets")]
        public IList<V1LocalObjectReference> ImagePullSecrets { get; set; }

        /// <summary>
        /// List of initialization containers belonging to the pod. Init containers are
        /// executed in order prior to containers being started. If any init container
        /// fails, the pod is considered to have failed and is handled according to its
        /// restartPolicy. The name for an init container or normal container must be unique
        /// among all containers. Init containers may not have Lifecycle actions, Readiness
        /// probes, Liveness probes, or Startup probes. The resourceRequirements of an init
        /// container are taken into account during scheduling by finding the highest
        /// request/limit for each resource type, and then using the max of of that value or
        /// the sum of the normal containers. Limits are applied to init containers in a
        /// similar fashion. Init containers cannot currently be added or removed. Cannot be
        /// updated. More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
        /// </summary>
        [JsonPropertyName("initContainers")]
        public IList<V1Container> InitContainers { get; set; }

        /// <summary>
        /// NodeName is a request to schedule this pod onto a specific node. If it is
        /// non-empty, the scheduler simply schedules this pod onto that node, assuming that
        /// it fits resource requirements.
        /// </summary>
        [JsonPropertyName("nodeName")]
        public string NodeName { get; set; }

        /// <summary>
        /// NodeSelector is a selector which must be true for the pod to fit on a node.
        /// Selector which must match a node&apos;s labels for the pod to be scheduled on that
        /// node. More info:
        /// https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
        /// </summary>
        [JsonPropertyName("nodeSelector")]
        public IDictionary<string, string> NodeSelector { get; set; }

        /// <summary>
        /// Specifies the OS of the containers in the pod. Some pod and container fields are
        /// restricted if this is set.
        /// 
        /// If the OS field is set to linux, the following fields must be unset:
        /// -securityContext.windowsOptions
        /// 
        /// If the OS field is set to windows, following fields must be unset: -
        /// spec.hostPID - spec.hostIPC - spec.securityContext.seLinuxOptions -
        /// spec.securityContext.seccompProfile - spec.securityContext.fsGroup -
        /// spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls -
        /// spec.shareProcessNamespace - spec.securityContext.runAsUser -
        /// spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups -
        /// spec.containers[*].securityContext.seLinuxOptions -
        /// spec.containers[*].securityContext.seccompProfile -
        /// spec.containers[*].securityContext.capabilities -
        /// spec.containers[*].securityContext.readOnlyRootFilesystem -
        /// spec.containers[*].securityContext.privileged -
        /// spec.containers[*].securityContext.allowPrivilegeEscalation -
        /// spec.containers[*].securityContext.procMount -
        /// spec.containers[*].securityContext.runAsUser -
        /// spec.containers[*].securityContext.runAsGroup This is an alpha field and
        /// requires the IdentifyPodOS feature
        /// </summary>
        [JsonPropertyName("os")]
        public V1PodOS Os { get; set; }

        /// <summary>
        /// Overhead represents the resource overhead associated with running a pod for a
        /// given RuntimeClass. This field will be autopopulated at admission time by the
        /// RuntimeClass admission controller. If the RuntimeClass admission controller is
        /// enabled, overhead must not be set in Pod create requests. The RuntimeClass
        /// admission controller will reject Pod create requests which have the overhead
        /// already set. If RuntimeClass is configured and selected in the PodSpec, Overhead
        /// will be set to the value defined in the corresponding RuntimeClass, otherwise it
        /// will remain unset and treated as zero. More info:
        /// https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md This
        /// field is beta-level as of Kubernetes v1.18, and is only honored by servers that
        /// enable the PodOverhead feature.
        /// </summary>
        [JsonPropertyName("overhead")]
        public IDictionary<string, ResourceQuantity> Overhead { get; set; }

        /// <summary>
        /// PreemptionPolicy is the Policy for preempting pods with lower priority. One of
        /// Never, PreemptLowerPriority. Defaults to PreemptLowerPriority if unset. This
        /// field is beta-level, gated by the NonPreemptingPriority feature-gate.
        /// </summary>
        [JsonPropertyName("preemptionPolicy")]
        public string PreemptionPolicy { get; set; }

        /// <summary>
        /// The priority value. Various system components use this field to find the
        /// priority of the pod. When Priority Admission Controller is enabled, it prevents
        /// users from setting this field. The admission controller populates this field
        /// from PriorityClassName. The higher the value, the higher the priority.
        /// </summary>
        [JsonPropertyName("priority")]
        public int? Priority { get; set; }

        /// <summary>
        /// If specified, indicates the pod&apos;s priority. &quot;system-node-critical&quot; and
        /// &quot;system-cluster-critical&quot; are two special keywords which indicate the highest
        /// priorities with the former being the highest priority. Any other name must be
        /// defined by creating a PriorityClass object with that name. If not specified, the
        /// pod priority will be default or zero if there is no default.
        /// </summary>
        [JsonPropertyName("priorityClassName")]
        public string PriorityClassName { get; set; }

        /// <summary>
        /// If specified, all readiness gates will be evaluated for pod readiness. A pod is
        /// ready when all its containers are ready AND all conditions specified in the
        /// readiness gates have status equal to &quot;True&quot; More info:
        /// https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates
        /// </summary>
        [JsonPropertyName("readinessGates")]
        public IList<V1PodReadinessGate> ReadinessGates { get; set; }

        /// <summary>
        /// Restart policy for all containers within the pod. One of Always, OnFailure,
        /// Never. Default to Always. More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
        /// 
        /// Possible enum values:
        /// - `&quot;Always&quot;`
        /// - `&quot;Never&quot;`
        /// - `&quot;OnFailure&quot;`
        /// </summary>
        [JsonPropertyName("restartPolicy")]
        public string RestartPolicy { get; set; }

        /// <summary>
        /// RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which
        /// should be used to run this pod.  If no RuntimeClass resource matches the named
        /// class, the pod will not be run. If unset or empty, the &quot;legacy&quot; RuntimeClass
        /// will be used, which is an implicit class with an empty definition that uses the
        /// default runtime handler. More info:
        /// https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class This is a beta
        /// feature as of Kubernetes v1.14.
        /// </summary>
        [JsonPropertyName("runtimeClassName")]
        public string RuntimeClassName { get; set; }

        /// <summary>
        /// If specified, the pod will be dispatched by specified scheduler. If not
        /// specified, the pod will be dispatched by default scheduler.
        /// </summary>
        [JsonPropertyName("schedulerName")]
        public string SchedulerName { get; set; }

        /// <summary>
        /// SecurityContext holds pod-level security attributes and common container
        /// settings. Optional: Defaults to empty.  See type description for default values
        /// of each field.
        /// </summary>
        [JsonPropertyName("securityContext")]
        public V1PodSecurityContext SecurityContext { get; set; }

        /// <summary>
        /// DeprecatedServiceAccount is a depreciated alias for ServiceAccountName.
        /// Deprecated: Use serviceAccountName instead.
        /// </summary>
        [JsonPropertyName("serviceAccount")]
        public string ServiceAccount { get; set; }

        /// <summary>
        /// ServiceAccountName is the name of the ServiceAccount to use to run this pod.
        /// More info:
        /// https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
        /// </summary>
        [JsonPropertyName("serviceAccountName")]
        public string ServiceAccountName { get; set; }

        /// <summary>
        /// If true the pod&apos;s hostname will be configured as the pod&apos;s FQDN, rather than the
        /// leaf name (the default). In Linux containers, this means setting the FQDN in the
        /// hostname field of the kernel (the nodename field of struct utsname). In Windows
        /// containers, this means setting the registry value of hostname for the registry
        /// key HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters to
        /// FQDN. If a pod does not have FQDN, this has no effect. Default to false.
        /// </summary>
        [JsonPropertyName("setHostnameAsFQDN")]
        public bool? SetHostnameAsFQDN { get; set; }

        /// <summary>
        /// Share a single process namespace between all of the containers in a pod. When
        /// this is set containers will be able to view and signal processes from other
        /// containers in the same pod, and the first process in each container will not be
        /// assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional:
        /// Default to false.
        /// </summary>
        [JsonPropertyName("shareProcessNamespace")]
        public bool? ShareProcessNamespace { get; set; }

        /// <summary>
        /// If specified, the fully qualified Pod hostname will be
        /// &quot;&lt;hostname&gt;.&lt;subdomain&gt;.&lt;pod namespace&gt;.svc.&lt;cluster domain&gt;&quot;. If not specified,
        /// the pod will not have a domainname at all.
        /// </summary>
        [JsonPropertyName("subdomain")]
        public string Subdomain { get; set; }

        /// <summary>
        /// Optional duration in seconds the pod needs to terminate gracefully. May be
        /// decreased in delete request. Value must be non-negative integer. The value zero
        /// indicates stop immediately via the kill signal (no opportunity to shut down). If
        /// this value is nil, the default grace period will be used instead. The grace
        /// period is the duration in seconds after the processes running in the pod are
        /// sent a termination signal and the time when the processes are forcibly halted
        /// with a kill signal. Set this value longer than the expected cleanup time for
        /// your process. Defaults to 30 seconds.
        /// </summary>
        [JsonPropertyName("terminationGracePeriodSeconds")]
        public long? TerminationGracePeriodSeconds { get; set; }

        /// <summary>
        /// If specified, the pod&apos;s tolerations.
        /// </summary>
        [JsonPropertyName("tolerations")]
        public IList<V1Toleration> Tolerations { get; set; }

        /// <summary>
        /// TopologySpreadConstraints describes how a group of pods ought to spread across
        /// topology domains. Scheduler will schedule pods in a way which abides by the
        /// constraints. All topologySpreadConstraints are ANDed.
        /// </summary>
        [JsonPropertyName("topologySpreadConstraints")]
        public IList<V1TopologySpreadConstraint> TopologySpreadConstraints { get; set; }

        /// <summary>
        /// List of volumes that can be mounted by containers belonging to the pod. More
        /// info: https://kubernetes.io/docs/concepts/storage/volumes
        /// </summary>
        [JsonPropertyName("volumes")]
        public IList<V1Volume> Volumes { get; set; }

        /// <summary>
        /// Validate the object.
        /// </summary>
        /// <exception cref="ValidationException">
        /// Thrown if validation fails
        /// </exception>
        public virtual void Validate()
        {
            Affinity?.Validate();
            if (Containers != null){
                foreach(var obj in Containers)
                {
                    obj.Validate();
                }
            }
            DnsConfig?.Validate();
            if (EphemeralContainers != null){
                foreach(var obj in EphemeralContainers)
                {
                    obj.Validate();
                }
            }
            if (HostAliases != null){
                foreach(var obj in HostAliases)
                {
                    obj.Validate();
                }
            }
            if (ImagePullSecrets != null){
                foreach(var obj in ImagePullSecrets)
                {
                    obj.Validate();
                }
            }
            if (InitContainers != null){
                foreach(var obj in InitContainers)
                {
                    obj.Validate();
                }
            }
            Os?.Validate();
            if (ReadinessGates != null){
                foreach(var obj in ReadinessGates)
                {
                    obj.Validate();
                }
            }
            SecurityContext?.Validate();
            if (Tolerations != null){
                foreach(var obj in Tolerations)
                {
                    obj.Validate();
                }
            }
            if (TopologySpreadConstraints != null){
                foreach(var obj in TopologySpreadConstraints)
                {
                    obj.Validate();
                }
            }
            if (Volumes != null){
                foreach(var obj in Volumes)
                {
                    obj.Validate();
                }
            }
        }
    }
}
