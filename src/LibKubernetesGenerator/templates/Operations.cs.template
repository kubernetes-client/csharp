// <auto-generated>
// Code generated by https://github.com/kubernetes-client/csharp/tree/master/src/LibKubernetesGenerator
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace k8s;

public partial class AbstractKubernetes : I{{name}}Operations
{
    {{for api in apis }}
    {{if IfReturnType api.operation "void"}}
    private async Task<HttpOperationResponse> I{{name}}Operations_{{GetMethodName api.operation "WithHttpMessagesAsync"}}(
    {{end}}
    {{if IfReturnType api.operation "obj"}}
    private async Task<HttpOperationResponse<T>> I{{name}}Operations_{{GetMethodName api.operation "WithHttpMessagesAsync"}}<T>(
    {{end}}
    {{if IfReturnType api.operation "stream"}}
    private async Task<HttpOperationResponse<Stream>> I{{name}}Operations_{{GetMethodName api.operation "WithHttpMessagesAsync"}}(
    {{end}}
{{ for parameter in api.operation.parameters}}
        {{GetDotNetTypeOpenApiParameter parameter}} {{GetDotNetNameOpenApiParameter parameter "false"}},
{{end}}
        IReadOnlyDictionary<string, IReadOnlyList<string>> customHeaders,
        CancellationToken cancellationToken)
    {
        using var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
        cts.CancelAfter(HttpClientTimeout);
        {{if IfParamContains api.operation "watch"}}
        if (watch == true)
        {
            cts.CancelAfter(Timeout.InfiniteTimeSpan);
        }
        {{end}}
        cancellationToken = cts.Token;

        {{ for parameter in api.operation.parameters}}
        {{ if parameter.IsRequired}}
        if ({{GetDotNetName parameter.name}} == null)
        {
            throw new ArgumentNullException("{{GetDotNetName parameter.name}}");
        }
        {{end}}
        {{end}}

        // Construct URL
        var url = $"{{ToInterpolationPathString api.path}}";
        {{if IfGroupPathParamContainsGroup api.path}}
        url = url.Replace("apis//", "api/");
        {{end}}
        {{if (array.size api.operation.parameters) > 0}}
        var q = new QueryBuilder();
        {{ for parameter in api.operation.parameters}}
        {{if IfKindIs parameter "query"}}
        q.Append("{{parameter.name}}", {{GetDotNetName parameter.name}});
        {{end}}
        {{end}}
        url += q.ToString();
        {{end}}

        // Create HTTP transport
        {{if IfParamContains api.operation "body"}}
        var httpResponse = await SendRequest(url, HttpMethods.{{api.method}}, customHeaders, body, cancellationToken);
        {{ else }}
        var httpResponse = await SendRequest<object>(url, HttpMethods.{{api.method}}, customHeaders, null, cancellationToken);
        {{end}}
        // Create Result
        var httpRequest = httpResponse.RequestMessage;
        {{if IfReturnType api.operation "void"}}
        HttpOperationResponse result = new HttpOperationResponse() { Request = httpRequest, Response =  httpResponse };
        {{end}}
        {{if IfReturnType api.operation "obj"}}
        var result = await CreateResultAsync<T>(
            httpRequest,
            httpResponse,
            {{if IfParamContains api.operation "watch"}}
            watch,
            {{else}}
            false,
            {{end}}
            cancellationToken);
        {{end}}
        {{if IfReturnType api.operation "stream"}}
        var result = new HttpOperationResponse<Stream>() {
                            Request = httpRequest,
                            Response = httpResponse,
                            Body = await httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false) };
        {{end}}
        return result;
    }

    /// <inheritdoc/>
    async Task<HttpOperationResponse{{GetReturnType api.operation "<>"}}> I{{name}}Operations.{{GetMethodName api.operation "WithHttpMessagesAsync"}}(
{{ for parameter in api.operation.parameters}}
        {{GetDotNetTypeOpenApiParameter parameter}} {{GetDotNetNameOpenApiParameter parameter "false"}},
{{end}}
        IReadOnlyDictionary<string, IReadOnlyList<string>> customHeaders,
        CancellationToken cancellationToken)
    {
        {{if IfReturnType api.operation "void"}}
        return await I{{name}}Operations_{{GetMethodName api.operation "WithHttpMessagesAsync"}}(
{{ for parameter in api.operation.parameters}}
           {{GetDotNetNameOpenApiParameter parameter "false"}},
{{end}}
            customHeaders,
            cancellationToken).ConfigureAwait(false);
        {{end}}
        {{if IfReturnType api.operation "obj"}}
        return await I{{name}}Operations_{{GetMethodName api.operation "WithHttpMessagesAsync"}}{{GetReturnType api.operation "<>"}}(
{{ for parameter in api.operation.parameters}}
           {{GetDotNetNameOpenApiParameter parameter "false"}},
{{end}}
            customHeaders,
            cancellationToken).ConfigureAwait(false);
        {{end}}
        {{if IfReturnType api.operation "stream"}}
        return await I{{name}}Operations_{{GetMethodName api.operation "WithHttpMessagesAsync"}}(
{{ for parameter in api.operation.parameters}}
           {{GetDotNetNameOpenApiParameter parameter "false"}},
{{end}}
            customHeaders,
            cancellationToken).ConfigureAwait(false);
        {{end}}
    }

    {{if IfReturnType api.operation "object"}}
    /// <inheritdoc/>
    async Task<HttpOperationResponse<T>> I{{name}}Operations.{{GetMethodName api.operation "WithHttpMessagesAsync"}}<T>(
{{ for parameter in api.operation.parameters}}
        {{GetDotNetTypeOpenApiParameter parameter}} {{GetDotNetNameOpenApiParameter parameter "false"}},
{{end}}
        IReadOnlyDictionary<string, IReadOnlyList<string>> customHeaders,
        CancellationToken cancellationToken)
    {
        return await I{{name}}Operations_{{GetMethodName api.operation "WithHttpMessagesAsync"}}<T>(
{{ for parameter in api.operation.parameters}}
           {{GetDotNetNameOpenApiParameter parameter "false"}},
{{end}}
            customHeaders,
            cancellationToken).ConfigureAwait(false);
    }
    {{end}}
    {{end}}
}
